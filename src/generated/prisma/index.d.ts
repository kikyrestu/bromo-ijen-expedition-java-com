
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SectionContent
 * 
 */
export type SectionContent = $Result.DefaultSelection<Prisma.$SectionContentPayload>
/**
 * Model Destination
 * 
 */
export type Destination = $Result.DefaultSelection<Prisma.$DestinationPayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model Testimonial
 * 
 */
export type Testimonial = $Result.DefaultSelection<Prisma.$TestimonialPayload>
/**
 * Model GalleryItem
 * 
 */
export type GalleryItem = $Result.DefaultSelection<Prisma.$GalleryItemPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model LocalizedUrlSettings
 * 
 */
export type LocalizedUrlSettings = $Result.DefaultSelection<Prisma.$LocalizedUrlSettingsPayload>
/**
 * Model SeoData
 * 
 */
export type SeoData = $Result.DefaultSelection<Prisma.$SeoDataPayload>
/**
 * Model SitemapLog
 * 
 */
export type SitemapLog = $Result.DefaultSelection<Prisma.$SitemapLogPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model NavigationMenu
 * 
 */
export type NavigationMenu = $Result.DefaultSelection<Prisma.$NavigationMenuPayload>
/**
 * Model NavigationItem
 * 
 */
export type NavigationItem = $Result.DefaultSelection<Prisma.$NavigationItemPayload>
/**
 * Model NavigationItemTranslation
 * 
 */
export type NavigationItemTranslation = $Result.DefaultSelection<Prisma.$NavigationItemTranslationPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model BannerTranslation
 * 
 */
export type BannerTranslation = $Result.DefaultSelection<Prisma.$BannerTranslationPayload>
/**
 * Model BannerPlacement
 * 
 */
export type BannerPlacement = $Result.DefaultSelection<Prisma.$BannerPlacementPayload>
/**
 * Model TopbarSettings
 * 
 */
export type TopbarSettings = $Result.DefaultSelection<Prisma.$TopbarSettingsPayload>
/**
 * Model MobileMenuSettings
 * 
 */
export type MobileMenuSettings = $Result.DefaultSelection<Prisma.$MobileMenuSettingsPayload>
/**
 * Model LanguageSettings
 * 
 */
export type LanguageSettings = $Result.DefaultSelection<Prisma.$LanguageSettingsPayload>
/**
 * Model CustomIcon
 * 
 */
export type CustomIcon = $Result.DefaultSelection<Prisma.$CustomIconPayload>
/**
 * Model PackageTranslation
 * 
 */
export type PackageTranslation = $Result.DefaultSelection<Prisma.$PackageTranslationPayload>
/**
 * Model BlogTranslation
 * 
 */
export type BlogTranslation = $Result.DefaultSelection<Prisma.$BlogTranslationPayload>
/**
 * Model TestimonialTranslation
 * 
 */
export type TestimonialTranslation = $Result.DefaultSelection<Prisma.$TestimonialTranslationPayload>
/**
 * Model GalleryTranslation
 * 
 */
export type GalleryTranslation = $Result.DefaultSelection<Prisma.$GalleryTranslationPayload>
/**
 * Model SectionContentTranslation
 * 
 */
export type SectionContentTranslation = $Result.DefaultSelection<Prisma.$SectionContentTranslationPayload>
/**
 * Model ApiKeySettings
 * 
 */
export type ApiKeySettings = $Result.DefaultSelection<Prisma.$ApiKeySettingsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SectionContents
 * const sectionContents = await prisma.sectionContent.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SectionContents
   * const sectionContents = await prisma.sectionContent.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.sectionContent`: Exposes CRUD operations for the **SectionContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectionContents
    * const sectionContents = await prisma.sectionContent.findMany()
    * ```
    */
  get sectionContent(): Prisma.SectionContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.destination`: Exposes CRUD operations for the **Destination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Destinations
    * const destinations = await prisma.destination.findMany()
    * ```
    */
  get destination(): Prisma.DestinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **Testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.TestimonialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.galleryItem`: Exposes CRUD operations for the **GalleryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GalleryItems
    * const galleryItems = await prisma.galleryItem.findMany()
    * ```
    */
  get galleryItem(): Prisma.GalleryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localizedUrlSettings`: Exposes CRUD operations for the **LocalizedUrlSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalizedUrlSettings
    * const localizedUrlSettings = await prisma.localizedUrlSettings.findMany()
    * ```
    */
  get localizedUrlSettings(): Prisma.LocalizedUrlSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seoData`: Exposes CRUD operations for the **SeoData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeoData
    * const seoData = await prisma.seoData.findMany()
    * ```
    */
  get seoData(): Prisma.SeoDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sitemapLog`: Exposes CRUD operations for the **SitemapLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SitemapLogs
    * const sitemapLogs = await prisma.sitemapLog.findMany()
    * ```
    */
  get sitemapLog(): Prisma.SitemapLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.navigationMenu`: Exposes CRUD operations for the **NavigationMenu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavigationMenus
    * const navigationMenus = await prisma.navigationMenu.findMany()
    * ```
    */
  get navigationMenu(): Prisma.NavigationMenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.navigationItem`: Exposes CRUD operations for the **NavigationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavigationItems
    * const navigationItems = await prisma.navigationItem.findMany()
    * ```
    */
  get navigationItem(): Prisma.NavigationItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.navigationItemTranslation`: Exposes CRUD operations for the **NavigationItemTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NavigationItemTranslations
    * const navigationItemTranslations = await prisma.navigationItemTranslation.findMany()
    * ```
    */
  get navigationItemTranslation(): Prisma.NavigationItemTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerTranslation`: Exposes CRUD operations for the **BannerTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerTranslations
    * const bannerTranslations = await prisma.bannerTranslation.findMany()
    * ```
    */
  get bannerTranslation(): Prisma.BannerTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bannerPlacement`: Exposes CRUD operations for the **BannerPlacement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerPlacements
    * const bannerPlacements = await prisma.bannerPlacement.findMany()
    * ```
    */
  get bannerPlacement(): Prisma.BannerPlacementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topbarSettings`: Exposes CRUD operations for the **TopbarSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopbarSettings
    * const topbarSettings = await prisma.topbarSettings.findMany()
    * ```
    */
  get topbarSettings(): Prisma.TopbarSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mobileMenuSettings`: Exposes CRUD operations for the **MobileMenuSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobileMenuSettings
    * const mobileMenuSettings = await prisma.mobileMenuSettings.findMany()
    * ```
    */
  get mobileMenuSettings(): Prisma.MobileMenuSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.languageSettings`: Exposes CRUD operations for the **LanguageSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LanguageSettings
    * const languageSettings = await prisma.languageSettings.findMany()
    * ```
    */
  get languageSettings(): Prisma.LanguageSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customIcon`: Exposes CRUD operations for the **CustomIcon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomIcons
    * const customIcons = await prisma.customIcon.findMany()
    * ```
    */
  get customIcon(): Prisma.CustomIconDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packageTranslation`: Exposes CRUD operations for the **PackageTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackageTranslations
    * const packageTranslations = await prisma.packageTranslation.findMany()
    * ```
    */
  get packageTranslation(): Prisma.PackageTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogTranslation`: Exposes CRUD operations for the **BlogTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogTranslations
    * const blogTranslations = await prisma.blogTranslation.findMany()
    * ```
    */
  get blogTranslation(): Prisma.BlogTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testimonialTranslation`: Exposes CRUD operations for the **TestimonialTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestimonialTranslations
    * const testimonialTranslations = await prisma.testimonialTranslation.findMany()
    * ```
    */
  get testimonialTranslation(): Prisma.TestimonialTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.galleryTranslation`: Exposes CRUD operations for the **GalleryTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GalleryTranslations
    * const galleryTranslations = await prisma.galleryTranslation.findMany()
    * ```
    */
  get galleryTranslation(): Prisma.GalleryTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sectionContentTranslation`: Exposes CRUD operations for the **SectionContentTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectionContentTranslations
    * const sectionContentTranslations = await prisma.sectionContentTranslation.findMany()
    * ```
    */
  get sectionContentTranslation(): Prisma.SectionContentTranslationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKeySettings`: Exposes CRUD operations for the **ApiKeySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeySettings
    * const apiKeySettings = await prisma.apiKeySettings.findMany()
    * ```
    */
  get apiKeySettings(): Prisma.ApiKeySettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SectionContent: 'SectionContent',
    Destination: 'Destination',
    Package: 'Package',
    Blog: 'Blog',
    Testimonial: 'Testimonial',
    GalleryItem: 'GalleryItem',
    Settings: 'Settings',
    LocalizedUrlSettings: 'LocalizedUrlSettings',
    SeoData: 'SeoData',
    SitemapLog: 'SitemapLog',
    Booking: 'Booking',
    NavigationMenu: 'NavigationMenu',
    NavigationItem: 'NavigationItem',
    NavigationItemTranslation: 'NavigationItemTranslation',
    Banner: 'Banner',
    BannerTranslation: 'BannerTranslation',
    BannerPlacement: 'BannerPlacement',
    TopbarSettings: 'TopbarSettings',
    MobileMenuSettings: 'MobileMenuSettings',
    LanguageSettings: 'LanguageSettings',
    CustomIcon: 'CustomIcon',
    PackageTranslation: 'PackageTranslation',
    BlogTranslation: 'BlogTranslation',
    TestimonialTranslation: 'TestimonialTranslation',
    GalleryTranslation: 'GalleryTranslation',
    SectionContentTranslation: 'SectionContentTranslation',
    ApiKeySettings: 'ApiKeySettings',
    User: 'User',
    Session: 'Session'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "sectionContent" | "destination" | "package" | "blog" | "testimonial" | "galleryItem" | "settings" | "localizedUrlSettings" | "seoData" | "sitemapLog" | "booking" | "navigationMenu" | "navigationItem" | "navigationItemTranslation" | "banner" | "bannerTranslation" | "bannerPlacement" | "topbarSettings" | "mobileMenuSettings" | "languageSettings" | "customIcon" | "packageTranslation" | "blogTranslation" | "testimonialTranslation" | "galleryTranslation" | "sectionContentTranslation" | "apiKeySettings" | "user" | "session"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SectionContent: {
        payload: Prisma.$SectionContentPayload<ExtArgs>
        fields: Prisma.SectionContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>
          }
          findFirst: {
            args: Prisma.SectionContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>
          }
          findMany: {
            args: Prisma.SectionContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>[]
          }
          create: {
            args: Prisma.SectionContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>
          }
          createMany: {
            args: Prisma.SectionContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectionContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>
          }
          update: {
            args: Prisma.SectionContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>
          }
          deleteMany: {
            args: Prisma.SectionContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentPayload>
          }
          aggregate: {
            args: Prisma.SectionContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectionContent>
          }
          groupBy: {
            args: Prisma.SectionContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionContentCountArgs<ExtArgs>
            result: $Utils.Optional<SectionContentCountAggregateOutputType> | number
          }
        }
      }
      Destination: {
        payload: Prisma.$DestinationPayload<ExtArgs>
        fields: Prisma.DestinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DestinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DestinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findFirst: {
            args: Prisma.DestinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DestinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          findMany: {
            args: Prisma.DestinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>[]
          }
          create: {
            args: Prisma.DestinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          createMany: {
            args: Prisma.DestinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DestinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          update: {
            args: Prisma.DestinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          deleteMany: {
            args: Prisma.DestinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DestinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DestinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DestinationPayload>
          }
          aggregate: {
            args: Prisma.DestinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDestination>
          }
          groupBy: {
            args: Prisma.DestinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DestinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DestinationCountArgs<ExtArgs>
            result: $Utils.Optional<DestinationCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      Testimonial: {
        payload: Prisma.$TestimonialPayload<ExtArgs>
        fields: Prisma.TestimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findFirst: {
            args: Prisma.TestimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          findMany: {
            args: Prisma.TestimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>[]
          }
          create: {
            args: Prisma.TestimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          createMany: {
            args: Prisma.TestimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          update: {
            args: Prisma.TestimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.TestimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      GalleryItem: {
        payload: Prisma.$GalleryItemPayload<ExtArgs>
        fields: Prisma.GalleryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GalleryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GalleryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>
          }
          findFirst: {
            args: Prisma.GalleryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GalleryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>
          }
          findMany: {
            args: Prisma.GalleryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>[]
          }
          create: {
            args: Prisma.GalleryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>
          }
          createMany: {
            args: Prisma.GalleryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GalleryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>
          }
          update: {
            args: Prisma.GalleryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>
          }
          deleteMany: {
            args: Prisma.GalleryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GalleryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GalleryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryItemPayload>
          }
          aggregate: {
            args: Prisma.GalleryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGalleryItem>
          }
          groupBy: {
            args: Prisma.GalleryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<GalleryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.GalleryItemCountArgs<ExtArgs>
            result: $Utils.Optional<GalleryItemCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      LocalizedUrlSettings: {
        payload: Prisma.$LocalizedUrlSettingsPayload<ExtArgs>
        fields: Prisma.LocalizedUrlSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalizedUrlSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalizedUrlSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>
          }
          findFirst: {
            args: Prisma.LocalizedUrlSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalizedUrlSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>
          }
          findMany: {
            args: Prisma.LocalizedUrlSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>[]
          }
          create: {
            args: Prisma.LocalizedUrlSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>
          }
          createMany: {
            args: Prisma.LocalizedUrlSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocalizedUrlSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>
          }
          update: {
            args: Prisma.LocalizedUrlSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>
          }
          deleteMany: {
            args: Prisma.LocalizedUrlSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalizedUrlSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalizedUrlSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalizedUrlSettingsPayload>
          }
          aggregate: {
            args: Prisma.LocalizedUrlSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalizedUrlSettings>
          }
          groupBy: {
            args: Prisma.LocalizedUrlSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalizedUrlSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalizedUrlSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<LocalizedUrlSettingsCountAggregateOutputType> | number
          }
        }
      }
      SeoData: {
        payload: Prisma.$SeoDataPayload<ExtArgs>
        fields: Prisma.SeoDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeoDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeoDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>
          }
          findFirst: {
            args: Prisma.SeoDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeoDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>
          }
          findMany: {
            args: Prisma.SeoDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>[]
          }
          create: {
            args: Prisma.SeoDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>
          }
          createMany: {
            args: Prisma.SeoDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeoDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>
          }
          update: {
            args: Prisma.SeoDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>
          }
          deleteMany: {
            args: Prisma.SeoDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeoDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeoDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeoDataPayload>
          }
          aggregate: {
            args: Prisma.SeoDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeoData>
          }
          groupBy: {
            args: Prisma.SeoDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeoDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeoDataCountArgs<ExtArgs>
            result: $Utils.Optional<SeoDataCountAggregateOutputType> | number
          }
        }
      }
      SitemapLog: {
        payload: Prisma.$SitemapLogPayload<ExtArgs>
        fields: Prisma.SitemapLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SitemapLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SitemapLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>
          }
          findFirst: {
            args: Prisma.SitemapLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SitemapLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>
          }
          findMany: {
            args: Prisma.SitemapLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>[]
          }
          create: {
            args: Prisma.SitemapLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>
          }
          createMany: {
            args: Prisma.SitemapLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SitemapLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>
          }
          update: {
            args: Prisma.SitemapLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>
          }
          deleteMany: {
            args: Prisma.SitemapLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SitemapLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SitemapLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SitemapLogPayload>
          }
          aggregate: {
            args: Prisma.SitemapLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSitemapLog>
          }
          groupBy: {
            args: Prisma.SitemapLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SitemapLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SitemapLogCountArgs<ExtArgs>
            result: $Utils.Optional<SitemapLogCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      NavigationMenu: {
        payload: Prisma.$NavigationMenuPayload<ExtArgs>
        fields: Prisma.NavigationMenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavigationMenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavigationMenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>
          }
          findFirst: {
            args: Prisma.NavigationMenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavigationMenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>
          }
          findMany: {
            args: Prisma.NavigationMenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>[]
          }
          create: {
            args: Prisma.NavigationMenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>
          }
          createMany: {
            args: Prisma.NavigationMenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NavigationMenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>
          }
          update: {
            args: Prisma.NavigationMenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>
          }
          deleteMany: {
            args: Prisma.NavigationMenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NavigationMenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NavigationMenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationMenuPayload>
          }
          aggregate: {
            args: Prisma.NavigationMenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNavigationMenu>
          }
          groupBy: {
            args: Prisma.NavigationMenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<NavigationMenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavigationMenuCountArgs<ExtArgs>
            result: $Utils.Optional<NavigationMenuCountAggregateOutputType> | number
          }
        }
      }
      NavigationItem: {
        payload: Prisma.$NavigationItemPayload<ExtArgs>
        fields: Prisma.NavigationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavigationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavigationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>
          }
          findFirst: {
            args: Prisma.NavigationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavigationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>
          }
          findMany: {
            args: Prisma.NavigationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>[]
          }
          create: {
            args: Prisma.NavigationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>
          }
          createMany: {
            args: Prisma.NavigationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NavigationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>
          }
          update: {
            args: Prisma.NavigationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>
          }
          deleteMany: {
            args: Prisma.NavigationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NavigationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NavigationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemPayload>
          }
          aggregate: {
            args: Prisma.NavigationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNavigationItem>
          }
          groupBy: {
            args: Prisma.NavigationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NavigationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavigationItemCountArgs<ExtArgs>
            result: $Utils.Optional<NavigationItemCountAggregateOutputType> | number
          }
        }
      }
      NavigationItemTranslation: {
        payload: Prisma.$NavigationItemTranslationPayload<ExtArgs>
        fields: Prisma.NavigationItemTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NavigationItemTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NavigationItemTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>
          }
          findFirst: {
            args: Prisma.NavigationItemTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NavigationItemTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>
          }
          findMany: {
            args: Prisma.NavigationItemTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>[]
          }
          create: {
            args: Prisma.NavigationItemTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>
          }
          createMany: {
            args: Prisma.NavigationItemTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NavigationItemTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>
          }
          update: {
            args: Prisma.NavigationItemTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>
          }
          deleteMany: {
            args: Prisma.NavigationItemTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NavigationItemTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NavigationItemTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NavigationItemTranslationPayload>
          }
          aggregate: {
            args: Prisma.NavigationItemTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNavigationItemTranslation>
          }
          groupBy: {
            args: Prisma.NavigationItemTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NavigationItemTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NavigationItemTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<NavigationItemTranslationCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      BannerTranslation: {
        payload: Prisma.$BannerTranslationPayload<ExtArgs>
        fields: Prisma.BannerTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>
          }
          findFirst: {
            args: Prisma.BannerTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>
          }
          findMany: {
            args: Prisma.BannerTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>[]
          }
          create: {
            args: Prisma.BannerTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>
          }
          createMany: {
            args: Prisma.BannerTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>
          }
          update: {
            args: Prisma.BannerTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>
          }
          deleteMany: {
            args: Prisma.BannerTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerTranslationPayload>
          }
          aggregate: {
            args: Prisma.BannerTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerTranslation>
          }
          groupBy: {
            args: Prisma.BannerTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<BannerTranslationCountAggregateOutputType> | number
          }
        }
      }
      BannerPlacement: {
        payload: Prisma.$BannerPlacementPayload<ExtArgs>
        fields: Prisma.BannerPlacementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerPlacementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerPlacementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>
          }
          findFirst: {
            args: Prisma.BannerPlacementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerPlacementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>
          }
          findMany: {
            args: Prisma.BannerPlacementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>[]
          }
          create: {
            args: Prisma.BannerPlacementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>
          }
          createMany: {
            args: Prisma.BannerPlacementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerPlacementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>
          }
          update: {
            args: Prisma.BannerPlacementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>
          }
          deleteMany: {
            args: Prisma.BannerPlacementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerPlacementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerPlacementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPlacementPayload>
          }
          aggregate: {
            args: Prisma.BannerPlacementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBannerPlacement>
          }
          groupBy: {
            args: Prisma.BannerPlacementGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerPlacementGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerPlacementCountArgs<ExtArgs>
            result: $Utils.Optional<BannerPlacementCountAggregateOutputType> | number
          }
        }
      }
      TopbarSettings: {
        payload: Prisma.$TopbarSettingsPayload<ExtArgs>
        fields: Prisma.TopbarSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopbarSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopbarSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>
          }
          findFirst: {
            args: Prisma.TopbarSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopbarSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>
          }
          findMany: {
            args: Prisma.TopbarSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>[]
          }
          create: {
            args: Prisma.TopbarSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>
          }
          createMany: {
            args: Prisma.TopbarSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TopbarSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>
          }
          update: {
            args: Prisma.TopbarSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TopbarSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopbarSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TopbarSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopbarSettingsPayload>
          }
          aggregate: {
            args: Prisma.TopbarSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopbarSettings>
          }
          groupBy: {
            args: Prisma.TopbarSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopbarSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopbarSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TopbarSettingsCountAggregateOutputType> | number
          }
        }
      }
      MobileMenuSettings: {
        payload: Prisma.$MobileMenuSettingsPayload<ExtArgs>
        fields: Prisma.MobileMenuSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobileMenuSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobileMenuSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>
          }
          findFirst: {
            args: Prisma.MobileMenuSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobileMenuSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>
          }
          findMany: {
            args: Prisma.MobileMenuSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>[]
          }
          create: {
            args: Prisma.MobileMenuSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>
          }
          createMany: {
            args: Prisma.MobileMenuSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MobileMenuSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>
          }
          update: {
            args: Prisma.MobileMenuSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>
          }
          deleteMany: {
            args: Prisma.MobileMenuSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MobileMenuSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MobileMenuSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileMenuSettingsPayload>
          }
          aggregate: {
            args: Prisma.MobileMenuSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMobileMenuSettings>
          }
          groupBy: {
            args: Prisma.MobileMenuSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MobileMenuSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobileMenuSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<MobileMenuSettingsCountAggregateOutputType> | number
          }
        }
      }
      LanguageSettings: {
        payload: Prisma.$LanguageSettingsPayload<ExtArgs>
        fields: Prisma.LanguageSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>
          }
          findFirst: {
            args: Prisma.LanguageSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>
          }
          findMany: {
            args: Prisma.LanguageSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>[]
          }
          create: {
            args: Prisma.LanguageSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>
          }
          createMany: {
            args: Prisma.LanguageSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LanguageSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>
          }
          update: {
            args: Prisma.LanguageSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>
          }
          deleteMany: {
            args: Prisma.LanguageSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguageSettingsPayload>
          }
          aggregate: {
            args: Prisma.LanguageSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguageSettings>
          }
          groupBy: {
            args: Prisma.LanguageSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageSettingsCountAggregateOutputType> | number
          }
        }
      }
      CustomIcon: {
        payload: Prisma.$CustomIconPayload<ExtArgs>
        fields: Prisma.CustomIconFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomIconFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomIconFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>
          }
          findFirst: {
            args: Prisma.CustomIconFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomIconFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>
          }
          findMany: {
            args: Prisma.CustomIconFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>[]
          }
          create: {
            args: Prisma.CustomIconCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>
          }
          createMany: {
            args: Prisma.CustomIconCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomIconDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>
          }
          update: {
            args: Prisma.CustomIconUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>
          }
          deleteMany: {
            args: Prisma.CustomIconDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomIconUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomIconUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomIconPayload>
          }
          aggregate: {
            args: Prisma.CustomIconAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomIcon>
          }
          groupBy: {
            args: Prisma.CustomIconGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomIconGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomIconCountArgs<ExtArgs>
            result: $Utils.Optional<CustomIconCountAggregateOutputType> | number
          }
        }
      }
      PackageTranslation: {
        payload: Prisma.$PackageTranslationPayload<ExtArgs>
        fields: Prisma.PackageTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>
          }
          findFirst: {
            args: Prisma.PackageTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>
          }
          findMany: {
            args: Prisma.PackageTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>[]
          }
          create: {
            args: Prisma.PackageTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>
          }
          createMany: {
            args: Prisma.PackageTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PackageTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>
          }
          update: {
            args: Prisma.PackageTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>
          }
          deleteMany: {
            args: Prisma.PackageTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackageTranslationPayload>
          }
          aggregate: {
            args: Prisma.PackageTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackageTranslation>
          }
          groupBy: {
            args: Prisma.PackageTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<PackageTranslationCountAggregateOutputType> | number
          }
        }
      }
      BlogTranslation: {
        payload: Prisma.$BlogTranslationPayload<ExtArgs>
        fields: Prisma.BlogTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>
          }
          findFirst: {
            args: Prisma.BlogTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>
          }
          findMany: {
            args: Prisma.BlogTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>[]
          }
          create: {
            args: Prisma.BlogTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>
          }
          createMany: {
            args: Prisma.BlogTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BlogTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>
          }
          update: {
            args: Prisma.BlogTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>
          }
          deleteMany: {
            args: Prisma.BlogTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTranslationPayload>
          }
          aggregate: {
            args: Prisma.BlogTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogTranslation>
          }
          groupBy: {
            args: Prisma.BlogTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<BlogTranslationCountAggregateOutputType> | number
          }
        }
      }
      TestimonialTranslation: {
        payload: Prisma.$TestimonialTranslationPayload<ExtArgs>
        fields: Prisma.TestimonialTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestimonialTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestimonialTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>
          }
          findFirst: {
            args: Prisma.TestimonialTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestimonialTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>
          }
          findMany: {
            args: Prisma.TestimonialTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>[]
          }
          create: {
            args: Prisma.TestimonialTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>
          }
          createMany: {
            args: Prisma.TestimonialTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestimonialTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>
          }
          update: {
            args: Prisma.TestimonialTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>
          }
          deleteMany: {
            args: Prisma.TestimonialTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestimonialTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestimonialTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestimonialTranslationPayload>
          }
          aggregate: {
            args: Prisma.TestimonialTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonialTranslation>
          }
          groupBy: {
            args: Prisma.TestimonialTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestimonialTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialTranslationCountAggregateOutputType> | number
          }
        }
      }
      GalleryTranslation: {
        payload: Prisma.$GalleryTranslationPayload<ExtArgs>
        fields: Prisma.GalleryTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GalleryTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GalleryTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>
          }
          findFirst: {
            args: Prisma.GalleryTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GalleryTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>
          }
          findMany: {
            args: Prisma.GalleryTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>[]
          }
          create: {
            args: Prisma.GalleryTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>
          }
          createMany: {
            args: Prisma.GalleryTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GalleryTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>
          }
          update: {
            args: Prisma.GalleryTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>
          }
          deleteMany: {
            args: Prisma.GalleryTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GalleryTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GalleryTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GalleryTranslationPayload>
          }
          aggregate: {
            args: Prisma.GalleryTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGalleryTranslation>
          }
          groupBy: {
            args: Prisma.GalleryTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GalleryTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GalleryTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<GalleryTranslationCountAggregateOutputType> | number
          }
        }
      }
      SectionContentTranslation: {
        payload: Prisma.$SectionContentTranslationPayload<ExtArgs>
        fields: Prisma.SectionContentTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionContentTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionContentTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>
          }
          findFirst: {
            args: Prisma.SectionContentTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionContentTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>
          }
          findMany: {
            args: Prisma.SectionContentTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>[]
          }
          create: {
            args: Prisma.SectionContentTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>
          }
          createMany: {
            args: Prisma.SectionContentTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectionContentTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>
          }
          update: {
            args: Prisma.SectionContentTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>
          }
          deleteMany: {
            args: Prisma.SectionContentTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionContentTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionContentTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionContentTranslationPayload>
          }
          aggregate: {
            args: Prisma.SectionContentTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectionContentTranslation>
          }
          groupBy: {
            args: Prisma.SectionContentTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionContentTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionContentTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<SectionContentTranslationCountAggregateOutputType> | number
          }
        }
      }
      ApiKeySettings: {
        payload: Prisma.$ApiKeySettingsPayload<ExtArgs>
        fields: Prisma.ApiKeySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>
          }
          findFirst: {
            args: Prisma.ApiKeySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>
          }
          findMany: {
            args: Prisma.ApiKeySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>[]
          }
          create: {
            args: Prisma.ApiKeySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>
          }
          createMany: {
            args: Prisma.ApiKeySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApiKeySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>
          }
          update: {
            args: Prisma.ApiKeySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeySettingsPayload>
          }
          aggregate: {
            args: Prisma.ApiKeySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKeySettings>
          }
          groupBy: {
            args: Prisma.ApiKeySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeySettingsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    sectionContent?: SectionContentOmit
    destination?: DestinationOmit
    package?: PackageOmit
    blog?: BlogOmit
    testimonial?: TestimonialOmit
    galleryItem?: GalleryItemOmit
    settings?: SettingsOmit
    localizedUrlSettings?: LocalizedUrlSettingsOmit
    seoData?: SeoDataOmit
    sitemapLog?: SitemapLogOmit
    booking?: BookingOmit
    navigationMenu?: NavigationMenuOmit
    navigationItem?: NavigationItemOmit
    navigationItemTranslation?: NavigationItemTranslationOmit
    banner?: BannerOmit
    bannerTranslation?: BannerTranslationOmit
    bannerPlacement?: BannerPlacementOmit
    topbarSettings?: TopbarSettingsOmit
    mobileMenuSettings?: MobileMenuSettingsOmit
    languageSettings?: LanguageSettingsOmit
    customIcon?: CustomIconOmit
    packageTranslation?: PackageTranslationOmit
    blogTranslation?: BlogTranslationOmit
    testimonialTranslation?: TestimonialTranslationOmit
    galleryTranslation?: GalleryTranslationOmit
    sectionContentTranslation?: SectionContentTranslationOmit
    apiKeySettings?: ApiKeySettingsOmit
    user?: UserOmit
    session?: SessionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type NavigationMenuCountOutputType
   */

  export type NavigationMenuCountOutputType = {
    items: number
  }

  export type NavigationMenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NavigationMenuCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * NavigationMenuCountOutputType without action
   */
  export type NavigationMenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenuCountOutputType
     */
    select?: NavigationMenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NavigationMenuCountOutputType without action
   */
  export type NavigationMenuCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigationItemWhereInput
  }


  /**
   * Count Type NavigationItemCountOutputType
   */

  export type NavigationItemCountOutputType = {
    translations: number
    children: number
  }

  export type NavigationItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | NavigationItemCountOutputTypeCountTranslationsArgs
    children?: boolean | NavigationItemCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * NavigationItemCountOutputType without action
   */
  export type NavigationItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemCountOutputType
     */
    select?: NavigationItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NavigationItemCountOutputType without action
   */
  export type NavigationItemCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigationItemTranslationWhereInput
  }

  /**
   * NavigationItemCountOutputType without action
   */
  export type NavigationItemCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigationItemWhereInput
  }


  /**
   * Count Type BannerCountOutputType
   */

  export type BannerCountOutputType = {
    translations: number
    placements: number
  }

  export type BannerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | BannerCountOutputTypeCountTranslationsArgs
    placements?: boolean | BannerCountOutputTypeCountPlacementsArgs
  }

  // Custom InputTypes
  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerCountOutputType
     */
    select?: BannerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerTranslationWhereInput
  }

  /**
   * BannerCountOutputType without action
   */
  export type BannerCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerPlacementWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SectionContent
   */

  export type AggregateSectionContent = {
    _count: SectionContentCountAggregateOutputType | null
    _avg: SectionContentAvgAggregateOutputType | null
    _sum: SectionContentSumAggregateOutputType | null
    _min: SectionContentMinAggregateOutputType | null
    _max: SectionContentMaxAggregateOutputType | null
  }

  export type SectionContentAvgAggregateOutputType = {
    displayCount: number | null
    autoSlideInterval: number | null
  }

  export type SectionContentSumAggregateOutputType = {
    displayCount: number | null
    autoSlideInterval: number | null
  }

  export type SectionContentMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    ctaLink: string | null
    buttonText: string | null
    image: string | null
    logo: string | null
    phone: string | null
    email: string | null
    backgroundVideo: string | null
    destinations: string | null
    features: string | null
    stats: string | null
    packages: string | null
    testimonials: string | null
    posts: string | null
    items: string | null
    categories: string | null
    displayCount: number | null
    featuredOnly: boolean | null
    category: string | null
    sortBy: string | null
    layoutStyle: string | null
    showFilters: boolean | null
    enableLightbox: boolean | null
    enableAutoSlide: boolean | null
    autoSlideInterval: number | null
    transitionEffect: string | null
    animationSpeed: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SectionContentMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    ctaLink: string | null
    buttonText: string | null
    image: string | null
    logo: string | null
    phone: string | null
    email: string | null
    backgroundVideo: string | null
    destinations: string | null
    features: string | null
    stats: string | null
    packages: string | null
    testimonials: string | null
    posts: string | null
    items: string | null
    categories: string | null
    displayCount: number | null
    featuredOnly: boolean | null
    category: string | null
    sortBy: string | null
    layoutStyle: string | null
    showFilters: boolean | null
    enableLightbox: boolean | null
    enableAutoSlide: boolean | null
    autoSlideInterval: number | null
    transitionEffect: string | null
    animationSpeed: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SectionContentCountAggregateOutputType = {
    id: number
    sectionId: number
    title: number
    subtitle: number
    description: number
    ctaText: number
    ctaLink: number
    buttonText: number
    image: number
    logo: number
    phone: number
    email: number
    backgroundVideo: number
    destinations: number
    features: number
    stats: number
    packages: number
    testimonials: number
    posts: number
    items: number
    categories: number
    displayCount: number
    featuredOnly: number
    category: number
    sortBy: number
    layoutStyle: number
    showFilters: number
    enableLightbox: number
    enableAutoSlide: number
    autoSlideInterval: number
    transitionEffect: number
    animationSpeed: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type SectionContentAvgAggregateInputType = {
    displayCount?: true
    autoSlideInterval?: true
  }

  export type SectionContentSumAggregateInputType = {
    displayCount?: true
    autoSlideInterval?: true
  }

  export type SectionContentMinAggregateInputType = {
    id?: true
    sectionId?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    ctaLink?: true
    buttonText?: true
    image?: true
    logo?: true
    phone?: true
    email?: true
    backgroundVideo?: true
    destinations?: true
    features?: true
    stats?: true
    packages?: true
    testimonials?: true
    posts?: true
    items?: true
    categories?: true
    displayCount?: true
    featuredOnly?: true
    category?: true
    sortBy?: true
    layoutStyle?: true
    showFilters?: true
    enableLightbox?: true
    enableAutoSlide?: true
    autoSlideInterval?: true
    transitionEffect?: true
    animationSpeed?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SectionContentMaxAggregateInputType = {
    id?: true
    sectionId?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    ctaLink?: true
    buttonText?: true
    image?: true
    logo?: true
    phone?: true
    email?: true
    backgroundVideo?: true
    destinations?: true
    features?: true
    stats?: true
    packages?: true
    testimonials?: true
    posts?: true
    items?: true
    categories?: true
    displayCount?: true
    featuredOnly?: true
    category?: true
    sortBy?: true
    layoutStyle?: true
    showFilters?: true
    enableLightbox?: true
    enableAutoSlide?: true
    autoSlideInterval?: true
    transitionEffect?: true
    animationSpeed?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SectionContentCountAggregateInputType = {
    id?: true
    sectionId?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    ctaLink?: true
    buttonText?: true
    image?: true
    logo?: true
    phone?: true
    email?: true
    backgroundVideo?: true
    destinations?: true
    features?: true
    stats?: true
    packages?: true
    testimonials?: true
    posts?: true
    items?: true
    categories?: true
    displayCount?: true
    featuredOnly?: true
    category?: true
    sortBy?: true
    layoutStyle?: true
    showFilters?: true
    enableLightbox?: true
    enableAutoSlide?: true
    autoSlideInterval?: true
    transitionEffect?: true
    animationSpeed?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SectionContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionContent to aggregate.
     */
    where?: SectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContents to fetch.
     */
    orderBy?: SectionContentOrderByWithRelationInput | SectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectionContents
    **/
    _count?: true | SectionContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionContentMaxAggregateInputType
  }

  export type GetSectionContentAggregateType<T extends SectionContentAggregateArgs> = {
        [P in keyof T & keyof AggregateSectionContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectionContent[P]>
      : GetScalarType<T[P], AggregateSectionContent[P]>
  }




  export type SectionContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionContentWhereInput
    orderBy?: SectionContentOrderByWithAggregationInput | SectionContentOrderByWithAggregationInput[]
    by: SectionContentScalarFieldEnum[] | SectionContentScalarFieldEnum
    having?: SectionContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionContentCountAggregateInputType | true
    _avg?: SectionContentAvgAggregateInputType
    _sum?: SectionContentSumAggregateInputType
    _min?: SectionContentMinAggregateInputType
    _max?: SectionContentMaxAggregateInputType
  }

  export type SectionContentGroupByOutputType = {
    id: string
    sectionId: string
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    ctaLink: string | null
    buttonText: string | null
    image: string | null
    logo: string | null
    phone: string | null
    email: string | null
    backgroundVideo: string | null
    destinations: string | null
    features: string | null
    stats: string | null
    packages: string | null
    testimonials: string | null
    posts: string | null
    items: string | null
    categories: string | null
    displayCount: number | null
    featuredOnly: boolean | null
    category: string | null
    sortBy: string | null
    layoutStyle: string | null
    showFilters: boolean | null
    enableLightbox: boolean | null
    enableAutoSlide: boolean | null
    autoSlideInterval: number | null
    transitionEffect: string | null
    animationSpeed: string | null
    updatedAt: Date
    createdAt: Date
    _count: SectionContentCountAggregateOutputType | null
    _avg: SectionContentAvgAggregateOutputType | null
    _sum: SectionContentSumAggregateOutputType | null
    _min: SectionContentMinAggregateOutputType | null
    _max: SectionContentMaxAggregateOutputType | null
  }

  type GetSectionContentGroupByPayload<T extends SectionContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionContentGroupByOutputType[P]>
            : GetScalarType<T[P], SectionContentGroupByOutputType[P]>
        }
      >
    >


  export type SectionContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    ctaText?: boolean
    ctaLink?: boolean
    buttonText?: boolean
    image?: boolean
    logo?: boolean
    phone?: boolean
    email?: boolean
    backgroundVideo?: boolean
    destinations?: boolean
    features?: boolean
    stats?: boolean
    packages?: boolean
    testimonials?: boolean
    posts?: boolean
    items?: boolean
    categories?: boolean
    displayCount?: boolean
    featuredOnly?: boolean
    category?: boolean
    sortBy?: boolean
    layoutStyle?: boolean
    showFilters?: boolean
    enableLightbox?: boolean
    enableAutoSlide?: boolean
    autoSlideInterval?: boolean
    transitionEffect?: boolean
    animationSpeed?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sectionContent"]>



  export type SectionContentSelectScalar = {
    id?: boolean
    sectionId?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    ctaText?: boolean
    ctaLink?: boolean
    buttonText?: boolean
    image?: boolean
    logo?: boolean
    phone?: boolean
    email?: boolean
    backgroundVideo?: boolean
    destinations?: boolean
    features?: boolean
    stats?: boolean
    packages?: boolean
    testimonials?: boolean
    posts?: boolean
    items?: boolean
    categories?: boolean
    displayCount?: boolean
    featuredOnly?: boolean
    category?: boolean
    sortBy?: boolean
    layoutStyle?: boolean
    showFilters?: boolean
    enableLightbox?: boolean
    enableAutoSlide?: boolean
    autoSlideInterval?: boolean
    transitionEffect?: boolean
    animationSpeed?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type SectionContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "title" | "subtitle" | "description" | "ctaText" | "ctaLink" | "buttonText" | "image" | "logo" | "phone" | "email" | "backgroundVideo" | "destinations" | "features" | "stats" | "packages" | "testimonials" | "posts" | "items" | "categories" | "displayCount" | "featuredOnly" | "category" | "sortBy" | "layoutStyle" | "showFilters" | "enableLightbox" | "enableAutoSlide" | "autoSlideInterval" | "transitionEffect" | "animationSpeed" | "updatedAt" | "createdAt", ExtArgs["result"]["sectionContent"]>

  export type $SectionContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SectionContent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      title: string | null
      subtitle: string | null
      description: string | null
      ctaText: string | null
      ctaLink: string | null
      buttonText: string | null
      image: string | null
      logo: string | null
      phone: string | null
      email: string | null
      backgroundVideo: string | null
      destinations: string | null
      features: string | null
      stats: string | null
      packages: string | null
      testimonials: string | null
      posts: string | null
      items: string | null
      categories: string | null
      displayCount: number | null
      featuredOnly: boolean | null
      category: string | null
      sortBy: string | null
      layoutStyle: string | null
      showFilters: boolean | null
      enableLightbox: boolean | null
      enableAutoSlide: boolean | null
      autoSlideInterval: number | null
      transitionEffect: string | null
      animationSpeed: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["sectionContent"]>
    composites: {}
  }

  type SectionContentGetPayload<S extends boolean | null | undefined | SectionContentDefaultArgs> = $Result.GetResult<Prisma.$SectionContentPayload, S>

  type SectionContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionContentCountAggregateInputType | true
    }

  export interface SectionContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectionContent'], meta: { name: 'SectionContent' } }
    /**
     * Find zero or one SectionContent that matches the filter.
     * @param {SectionContentFindUniqueArgs} args - Arguments to find a SectionContent
     * @example
     * // Get one SectionContent
     * const sectionContent = await prisma.sectionContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionContentFindUniqueArgs>(args: SelectSubset<T, SectionContentFindUniqueArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SectionContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionContentFindUniqueOrThrowArgs} args - Arguments to find a SectionContent
     * @example
     * // Get one SectionContent
     * const sectionContent = await prisma.sectionContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionContentFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectionContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentFindFirstArgs} args - Arguments to find a SectionContent
     * @example
     * // Get one SectionContent
     * const sectionContent = await prisma.sectionContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionContentFindFirstArgs>(args?: SelectSubset<T, SectionContentFindFirstArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectionContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentFindFirstOrThrowArgs} args - Arguments to find a SectionContent
     * @example
     * // Get one SectionContent
     * const sectionContent = await prisma.sectionContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionContentFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SectionContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectionContents
     * const sectionContents = await prisma.sectionContent.findMany()
     * 
     * // Get first 10 SectionContents
     * const sectionContents = await prisma.sectionContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionContentWithIdOnly = await prisma.sectionContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionContentFindManyArgs>(args?: SelectSubset<T, SectionContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SectionContent.
     * @param {SectionContentCreateArgs} args - Arguments to create a SectionContent.
     * @example
     * // Create one SectionContent
     * const SectionContent = await prisma.sectionContent.create({
     *   data: {
     *     // ... data to create a SectionContent
     *   }
     * })
     * 
     */
    create<T extends SectionContentCreateArgs>(args: SelectSubset<T, SectionContentCreateArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SectionContents.
     * @param {SectionContentCreateManyArgs} args - Arguments to create many SectionContents.
     * @example
     * // Create many SectionContents
     * const sectionContent = await prisma.sectionContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionContentCreateManyArgs>(args?: SelectSubset<T, SectionContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SectionContent.
     * @param {SectionContentDeleteArgs} args - Arguments to delete one SectionContent.
     * @example
     * // Delete one SectionContent
     * const SectionContent = await prisma.sectionContent.delete({
     *   where: {
     *     // ... filter to delete one SectionContent
     *   }
     * })
     * 
     */
    delete<T extends SectionContentDeleteArgs>(args: SelectSubset<T, SectionContentDeleteArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SectionContent.
     * @param {SectionContentUpdateArgs} args - Arguments to update one SectionContent.
     * @example
     * // Update one SectionContent
     * const sectionContent = await prisma.sectionContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionContentUpdateArgs>(args: SelectSubset<T, SectionContentUpdateArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SectionContents.
     * @param {SectionContentDeleteManyArgs} args - Arguments to filter SectionContents to delete.
     * @example
     * // Delete a few SectionContents
     * const { count } = await prisma.sectionContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionContentDeleteManyArgs>(args?: SelectSubset<T, SectionContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectionContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectionContents
     * const sectionContent = await prisma.sectionContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionContentUpdateManyArgs>(args: SelectSubset<T, SectionContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SectionContent.
     * @param {SectionContentUpsertArgs} args - Arguments to update or create a SectionContent.
     * @example
     * // Update or create a SectionContent
     * const sectionContent = await prisma.sectionContent.upsert({
     *   create: {
     *     // ... data to create a SectionContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectionContent we want to update
     *   }
     * })
     */
    upsert<T extends SectionContentUpsertArgs>(args: SelectSubset<T, SectionContentUpsertArgs<ExtArgs>>): Prisma__SectionContentClient<$Result.GetResult<Prisma.$SectionContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SectionContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentCountArgs} args - Arguments to filter SectionContents to count.
     * @example
     * // Count the number of SectionContents
     * const count = await prisma.sectionContent.count({
     *   where: {
     *     // ... the filter for the SectionContents we want to count
     *   }
     * })
    **/
    count<T extends SectionContentCountArgs>(
      args?: Subset<T, SectionContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectionContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionContentAggregateArgs>(args: Subset<T, SectionContentAggregateArgs>): Prisma.PrismaPromise<GetSectionContentAggregateType<T>>

    /**
     * Group by SectionContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionContentGroupByArgs['orderBy'] }
        : { orderBy?: SectionContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SectionContent model
   */
  readonly fields: SectionContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SectionContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SectionContent model
   */
  interface SectionContentFieldRefs {
    readonly id: FieldRef<"SectionContent", 'String'>
    readonly sectionId: FieldRef<"SectionContent", 'String'>
    readonly title: FieldRef<"SectionContent", 'String'>
    readonly subtitle: FieldRef<"SectionContent", 'String'>
    readonly description: FieldRef<"SectionContent", 'String'>
    readonly ctaText: FieldRef<"SectionContent", 'String'>
    readonly ctaLink: FieldRef<"SectionContent", 'String'>
    readonly buttonText: FieldRef<"SectionContent", 'String'>
    readonly image: FieldRef<"SectionContent", 'String'>
    readonly logo: FieldRef<"SectionContent", 'String'>
    readonly phone: FieldRef<"SectionContent", 'String'>
    readonly email: FieldRef<"SectionContent", 'String'>
    readonly backgroundVideo: FieldRef<"SectionContent", 'String'>
    readonly destinations: FieldRef<"SectionContent", 'String'>
    readonly features: FieldRef<"SectionContent", 'String'>
    readonly stats: FieldRef<"SectionContent", 'String'>
    readonly packages: FieldRef<"SectionContent", 'String'>
    readonly testimonials: FieldRef<"SectionContent", 'String'>
    readonly posts: FieldRef<"SectionContent", 'String'>
    readonly items: FieldRef<"SectionContent", 'String'>
    readonly categories: FieldRef<"SectionContent", 'String'>
    readonly displayCount: FieldRef<"SectionContent", 'Int'>
    readonly featuredOnly: FieldRef<"SectionContent", 'Boolean'>
    readonly category: FieldRef<"SectionContent", 'String'>
    readonly sortBy: FieldRef<"SectionContent", 'String'>
    readonly layoutStyle: FieldRef<"SectionContent", 'String'>
    readonly showFilters: FieldRef<"SectionContent", 'Boolean'>
    readonly enableLightbox: FieldRef<"SectionContent", 'Boolean'>
    readonly enableAutoSlide: FieldRef<"SectionContent", 'Boolean'>
    readonly autoSlideInterval: FieldRef<"SectionContent", 'Int'>
    readonly transitionEffect: FieldRef<"SectionContent", 'String'>
    readonly animationSpeed: FieldRef<"SectionContent", 'String'>
    readonly updatedAt: FieldRef<"SectionContent", 'DateTime'>
    readonly createdAt: FieldRef<"SectionContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SectionContent findUnique
   */
  export type SectionContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * Filter, which SectionContent to fetch.
     */
    where: SectionContentWhereUniqueInput
  }

  /**
   * SectionContent findUniqueOrThrow
   */
  export type SectionContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * Filter, which SectionContent to fetch.
     */
    where: SectionContentWhereUniqueInput
  }

  /**
   * SectionContent findFirst
   */
  export type SectionContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * Filter, which SectionContent to fetch.
     */
    where?: SectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContents to fetch.
     */
    orderBy?: SectionContentOrderByWithRelationInput | SectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionContents.
     */
    cursor?: SectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionContents.
     */
    distinct?: SectionContentScalarFieldEnum | SectionContentScalarFieldEnum[]
  }

  /**
   * SectionContent findFirstOrThrow
   */
  export type SectionContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * Filter, which SectionContent to fetch.
     */
    where?: SectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContents to fetch.
     */
    orderBy?: SectionContentOrderByWithRelationInput | SectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionContents.
     */
    cursor?: SectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionContents.
     */
    distinct?: SectionContentScalarFieldEnum | SectionContentScalarFieldEnum[]
  }

  /**
   * SectionContent findMany
   */
  export type SectionContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * Filter, which SectionContents to fetch.
     */
    where?: SectionContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContents to fetch.
     */
    orderBy?: SectionContentOrderByWithRelationInput | SectionContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectionContents.
     */
    cursor?: SectionContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContents.
     */
    skip?: number
    distinct?: SectionContentScalarFieldEnum | SectionContentScalarFieldEnum[]
  }

  /**
   * SectionContent create
   */
  export type SectionContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * The data needed to create a SectionContent.
     */
    data: XOR<SectionContentCreateInput, SectionContentUncheckedCreateInput>
  }

  /**
   * SectionContent createMany
   */
  export type SectionContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SectionContents.
     */
    data: SectionContentCreateManyInput | SectionContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SectionContent update
   */
  export type SectionContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * The data needed to update a SectionContent.
     */
    data: XOR<SectionContentUpdateInput, SectionContentUncheckedUpdateInput>
    /**
     * Choose, which SectionContent to update.
     */
    where: SectionContentWhereUniqueInput
  }

  /**
   * SectionContent updateMany
   */
  export type SectionContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SectionContents.
     */
    data: XOR<SectionContentUpdateManyMutationInput, SectionContentUncheckedUpdateManyInput>
    /**
     * Filter which SectionContents to update
     */
    where?: SectionContentWhereInput
    /**
     * Limit how many SectionContents to update.
     */
    limit?: number
  }

  /**
   * SectionContent upsert
   */
  export type SectionContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * The filter to search for the SectionContent to update in case it exists.
     */
    where: SectionContentWhereUniqueInput
    /**
     * In case the SectionContent found by the `where` argument doesn't exist, create a new SectionContent with this data.
     */
    create: XOR<SectionContentCreateInput, SectionContentUncheckedCreateInput>
    /**
     * In case the SectionContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionContentUpdateInput, SectionContentUncheckedUpdateInput>
  }

  /**
   * SectionContent delete
   */
  export type SectionContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
    /**
     * Filter which SectionContent to delete.
     */
    where: SectionContentWhereUniqueInput
  }

  /**
   * SectionContent deleteMany
   */
  export type SectionContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionContents to delete
     */
    where?: SectionContentWhereInput
    /**
     * Limit how many SectionContents to delete.
     */
    limit?: number
  }

  /**
   * SectionContent without action
   */
  export type SectionContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContent
     */
    select?: SectionContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContent
     */
    omit?: SectionContentOmit<ExtArgs> | null
  }


  /**
   * Model Destination
   */

  export type AggregateDestination = {
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  export type DestinationAvgAggregateOutputType = {
    rating: number | null
  }

  export type DestinationSumAggregateOutputType = {
    rating: number | null
  }

  export type DestinationMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    category: string | null
    rating: number | null
    visitors: string | null
    duration: string | null
    price: string | null
    description: string | null
    highlights: string | null
    image: string | null
    featured: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type DestinationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    category: string | null
    rating: number | null
    visitors: string | null
    duration: string | null
    price: string | null
    description: string | null
    highlights: string | null
    image: string | null
    featured: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type DestinationCountAggregateOutputType = {
    id: number
    name: number
    location: number
    category: number
    rating: number
    visitors: number
    duration: number
    price: number
    description: number
    highlights: number
    image: number
    featured: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type DestinationAvgAggregateInputType = {
    rating?: true
  }

  export type DestinationSumAggregateInputType = {
    rating?: true
  }

  export type DestinationMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    category?: true
    rating?: true
    visitors?: true
    duration?: true
    price?: true
    description?: true
    highlights?: true
    image?: true
    featured?: true
    updatedAt?: true
    createdAt?: true
  }

  export type DestinationMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    category?: true
    rating?: true
    visitors?: true
    duration?: true
    price?: true
    description?: true
    highlights?: true
    image?: true
    featured?: true
    updatedAt?: true
    createdAt?: true
  }

  export type DestinationCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    category?: true
    rating?: true
    visitors?: true
    duration?: true
    price?: true
    description?: true
    highlights?: true
    image?: true
    featured?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type DestinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destination to aggregate.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Destinations
    **/
    _count?: true | DestinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DestinationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DestinationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DestinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DestinationMaxAggregateInputType
  }

  export type GetDestinationAggregateType<T extends DestinationAggregateArgs> = {
        [P in keyof T & keyof AggregateDestination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDestination[P]>
      : GetScalarType<T[P], AggregateDestination[P]>
  }




  export type DestinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DestinationWhereInput
    orderBy?: DestinationOrderByWithAggregationInput | DestinationOrderByWithAggregationInput[]
    by: DestinationScalarFieldEnum[] | DestinationScalarFieldEnum
    having?: DestinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DestinationCountAggregateInputType | true
    _avg?: DestinationAvgAggregateInputType
    _sum?: DestinationSumAggregateInputType
    _min?: DestinationMinAggregateInputType
    _max?: DestinationMaxAggregateInputType
  }

  export type DestinationGroupByOutputType = {
    id: string
    name: string
    location: string
    category: string
    rating: number
    visitors: string
    duration: string
    price: string
    description: string
    highlights: string
    image: string
    featured: boolean
    updatedAt: Date
    createdAt: Date
    _count: DestinationCountAggregateOutputType | null
    _avg: DestinationAvgAggregateOutputType | null
    _sum: DestinationSumAggregateOutputType | null
    _min: DestinationMinAggregateOutputType | null
    _max: DestinationMaxAggregateOutputType | null
  }

  type GetDestinationGroupByPayload<T extends DestinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DestinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DestinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DestinationGroupByOutputType[P]>
            : GetScalarType<T[P], DestinationGroupByOutputType[P]>
        }
      >
    >


  export type DestinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    category?: boolean
    rating?: boolean
    visitors?: boolean
    duration?: boolean
    price?: boolean
    description?: boolean
    highlights?: boolean
    image?: boolean
    featured?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["destination"]>



  export type DestinationSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    category?: boolean
    rating?: boolean
    visitors?: boolean
    duration?: boolean
    price?: boolean
    description?: boolean
    highlights?: boolean
    image?: boolean
    featured?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type DestinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "category" | "rating" | "visitors" | "duration" | "price" | "description" | "highlights" | "image" | "featured" | "updatedAt" | "createdAt", ExtArgs["result"]["destination"]>

  export type $DestinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Destination"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      category: string
      rating: number
      visitors: string
      duration: string
      price: string
      description: string
      highlights: string
      image: string
      featured: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["destination"]>
    composites: {}
  }

  type DestinationGetPayload<S extends boolean | null | undefined | DestinationDefaultArgs> = $Result.GetResult<Prisma.$DestinationPayload, S>

  type DestinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DestinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DestinationCountAggregateInputType | true
    }

  export interface DestinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Destination'], meta: { name: 'Destination' } }
    /**
     * Find zero or one Destination that matches the filter.
     * @param {DestinationFindUniqueArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DestinationFindUniqueArgs>(args: SelectSubset<T, DestinationFindUniqueArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Destination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DestinationFindUniqueOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DestinationFindUniqueOrThrowArgs>(args: SelectSubset<T, DestinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DestinationFindFirstArgs>(args?: SelectSubset<T, DestinationFindFirstArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Destination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindFirstOrThrowArgs} args - Arguments to find a Destination
     * @example
     * // Get one Destination
     * const destination = await prisma.destination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DestinationFindFirstOrThrowArgs>(args?: SelectSubset<T, DestinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Destinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Destinations
     * const destinations = await prisma.destination.findMany()
     * 
     * // Get first 10 Destinations
     * const destinations = await prisma.destination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const destinationWithIdOnly = await prisma.destination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DestinationFindManyArgs>(args?: SelectSubset<T, DestinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Destination.
     * @param {DestinationCreateArgs} args - Arguments to create a Destination.
     * @example
     * // Create one Destination
     * const Destination = await prisma.destination.create({
     *   data: {
     *     // ... data to create a Destination
     *   }
     * })
     * 
     */
    create<T extends DestinationCreateArgs>(args: SelectSubset<T, DestinationCreateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Destinations.
     * @param {DestinationCreateManyArgs} args - Arguments to create many Destinations.
     * @example
     * // Create many Destinations
     * const destination = await prisma.destination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DestinationCreateManyArgs>(args?: SelectSubset<T, DestinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Destination.
     * @param {DestinationDeleteArgs} args - Arguments to delete one Destination.
     * @example
     * // Delete one Destination
     * const Destination = await prisma.destination.delete({
     *   where: {
     *     // ... filter to delete one Destination
     *   }
     * })
     * 
     */
    delete<T extends DestinationDeleteArgs>(args: SelectSubset<T, DestinationDeleteArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Destination.
     * @param {DestinationUpdateArgs} args - Arguments to update one Destination.
     * @example
     * // Update one Destination
     * const destination = await prisma.destination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DestinationUpdateArgs>(args: SelectSubset<T, DestinationUpdateArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Destinations.
     * @param {DestinationDeleteManyArgs} args - Arguments to filter Destinations to delete.
     * @example
     * // Delete a few Destinations
     * const { count } = await prisma.destination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DestinationDeleteManyArgs>(args?: SelectSubset<T, DestinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Destinations
     * const destination = await prisma.destination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DestinationUpdateManyArgs>(args: SelectSubset<T, DestinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Destination.
     * @param {DestinationUpsertArgs} args - Arguments to update or create a Destination.
     * @example
     * // Update or create a Destination
     * const destination = await prisma.destination.upsert({
     *   create: {
     *     // ... data to create a Destination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Destination we want to update
     *   }
     * })
     */
    upsert<T extends DestinationUpsertArgs>(args: SelectSubset<T, DestinationUpsertArgs<ExtArgs>>): Prisma__DestinationClient<$Result.GetResult<Prisma.$DestinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Destinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationCountArgs} args - Arguments to filter Destinations to count.
     * @example
     * // Count the number of Destinations
     * const count = await prisma.destination.count({
     *   where: {
     *     // ... the filter for the Destinations we want to count
     *   }
     * })
    **/
    count<T extends DestinationCountArgs>(
      args?: Subset<T, DestinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DestinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DestinationAggregateArgs>(args: Subset<T, DestinationAggregateArgs>): Prisma.PrismaPromise<GetDestinationAggregateType<T>>

    /**
     * Group by Destination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DestinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DestinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DestinationGroupByArgs['orderBy'] }
        : { orderBy?: DestinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DestinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDestinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Destination model
   */
  readonly fields: DestinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Destination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DestinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Destination model
   */
  interface DestinationFieldRefs {
    readonly id: FieldRef<"Destination", 'String'>
    readonly name: FieldRef<"Destination", 'String'>
    readonly location: FieldRef<"Destination", 'String'>
    readonly category: FieldRef<"Destination", 'String'>
    readonly rating: FieldRef<"Destination", 'Float'>
    readonly visitors: FieldRef<"Destination", 'String'>
    readonly duration: FieldRef<"Destination", 'String'>
    readonly price: FieldRef<"Destination", 'String'>
    readonly description: FieldRef<"Destination", 'String'>
    readonly highlights: FieldRef<"Destination", 'String'>
    readonly image: FieldRef<"Destination", 'String'>
    readonly featured: FieldRef<"Destination", 'Boolean'>
    readonly updatedAt: FieldRef<"Destination", 'DateTime'>
    readonly createdAt: FieldRef<"Destination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Destination findUnique
   */
  export type DestinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findUniqueOrThrow
   */
  export type DestinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination findFirst
   */
  export type DestinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findFirstOrThrow
   */
  export type DestinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Filter, which Destination to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Destinations.
     */
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination findMany
   */
  export type DestinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Filter, which Destinations to fetch.
     */
    where?: DestinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Destinations to fetch.
     */
    orderBy?: DestinationOrderByWithRelationInput | DestinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Destinations.
     */
    cursor?: DestinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Destinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Destinations.
     */
    skip?: number
    distinct?: DestinationScalarFieldEnum | DestinationScalarFieldEnum[]
  }

  /**
   * Destination create
   */
  export type DestinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data needed to create a Destination.
     */
    data: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
  }

  /**
   * Destination createMany
   */
  export type DestinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Destinations.
     */
    data: DestinationCreateManyInput | DestinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Destination update
   */
  export type DestinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The data needed to update a Destination.
     */
    data: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
    /**
     * Choose, which Destination to update.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination updateMany
   */
  export type DestinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Destinations.
     */
    data: XOR<DestinationUpdateManyMutationInput, DestinationUncheckedUpdateManyInput>
    /**
     * Filter which Destinations to update
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to update.
     */
    limit?: number
  }

  /**
   * Destination upsert
   */
  export type DestinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * The filter to search for the Destination to update in case it exists.
     */
    where: DestinationWhereUniqueInput
    /**
     * In case the Destination found by the `where` argument doesn't exist, create a new Destination with this data.
     */
    create: XOR<DestinationCreateInput, DestinationUncheckedCreateInput>
    /**
     * In case the Destination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DestinationUpdateInput, DestinationUncheckedUpdateInput>
  }

  /**
   * Destination delete
   */
  export type DestinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
    /**
     * Filter which Destination to delete.
     */
    where: DestinationWhereUniqueInput
  }

  /**
   * Destination deleteMany
   */
  export type DestinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Destinations to delete
     */
    where?: DestinationWhereInput
    /**
     * Limit how many Destinations to delete.
     */
    limit?: number
  }

  /**
   * Destination without action
   */
  export type DestinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Destination
     */
    select?: DestinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Destination
     */
    omit?: DestinationOmit<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    price: number | null
    originalPrice: number | null
    rating: number | null
    reviewCount: number | null
    totalPeople: number | null
  }

  export type PackageSumAggregateOutputType = {
    price: number | null
    originalPrice: number | null
    rating: number | null
    reviewCount: number | null
    totalPeople: number | null
  }

  export type PackageMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    duration: string | null
    price: number | null
    originalPrice: number | null
    discount: string | null
    rating: number | null
    reviewCount: number | null
    category: string | null
    description: string | null
    longDescription: string | null
    destinations: string | null
    includes: string | null
    excludes: string | null
    highlights: string | null
    itinerary: string | null
    gallery: string | null
    faqs: string | null
    groupSize: string | null
    difficulty: string | null
    bestFor: string | null
    image: string | null
    departure: string | null
    return: string | null
    totalPeople: number | null
    location: string | null
    mapEmbedUrl: string | null
    featured: boolean | null
    available: boolean | null
    status: string | null
    localizedUrls: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PackageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    duration: string | null
    price: number | null
    originalPrice: number | null
    discount: string | null
    rating: number | null
    reviewCount: number | null
    category: string | null
    description: string | null
    longDescription: string | null
    destinations: string | null
    includes: string | null
    excludes: string | null
    highlights: string | null
    itinerary: string | null
    gallery: string | null
    faqs: string | null
    groupSize: string | null
    difficulty: string | null
    bestFor: string | null
    image: string | null
    departure: string | null
    return: string | null
    totalPeople: number | null
    location: string | null
    mapEmbedUrl: string | null
    featured: boolean | null
    available: boolean | null
    status: string | null
    localizedUrls: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    duration: number
    price: number
    originalPrice: number
    discount: number
    rating: number
    reviewCount: number
    category: number
    description: number
    longDescription: number
    destinations: number
    includes: number
    excludes: number
    highlights: number
    itinerary: number
    gallery: number
    faqs: number
    groupSize: number
    difficulty: number
    bestFor: number
    image: number
    departure: number
    return: number
    totalPeople: number
    location: number
    mapEmbedUrl: number
    featured: number
    available: number
    status: number
    localizedUrls: number
    urlPathEn: number
    urlPathDe: number
    urlPathNl: number
    urlPathZh: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    price?: true
    originalPrice?: true
    rating?: true
    reviewCount?: true
    totalPeople?: true
  }

  export type PackageSumAggregateInputType = {
    price?: true
    originalPrice?: true
    rating?: true
    reviewCount?: true
    totalPeople?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    duration?: true
    price?: true
    originalPrice?: true
    discount?: true
    rating?: true
    reviewCount?: true
    category?: true
    description?: true
    longDescription?: true
    destinations?: true
    includes?: true
    excludes?: true
    highlights?: true
    itinerary?: true
    gallery?: true
    faqs?: true
    groupSize?: true
    difficulty?: true
    bestFor?: true
    image?: true
    departure?: true
    return?: true
    totalPeople?: true
    location?: true
    mapEmbedUrl?: true
    featured?: true
    available?: true
    status?: true
    localizedUrls?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    duration?: true
    price?: true
    originalPrice?: true
    discount?: true
    rating?: true
    reviewCount?: true
    category?: true
    description?: true
    longDescription?: true
    destinations?: true
    includes?: true
    excludes?: true
    highlights?: true
    itinerary?: true
    gallery?: true
    faqs?: true
    groupSize?: true
    difficulty?: true
    bestFor?: true
    image?: true
    departure?: true
    return?: true
    totalPeople?: true
    location?: true
    mapEmbedUrl?: true
    featured?: true
    available?: true
    status?: true
    localizedUrls?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    duration?: true
    price?: true
    originalPrice?: true
    discount?: true
    rating?: true
    reviewCount?: true
    category?: true
    description?: true
    longDescription?: true
    destinations?: true
    includes?: true
    excludes?: true
    highlights?: true
    itinerary?: true
    gallery?: true
    faqs?: true
    groupSize?: true
    difficulty?: true
    bestFor?: true
    image?: true
    departure?: true
    return?: true
    totalPeople?: true
    location?: true
    mapEmbedUrl?: true
    featured?: true
    available?: true
    status?: true
    localizedUrls?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: string
    title: string
    slug: string | null
    duration: string
    price: number
    originalPrice: number | null
    discount: string | null
    rating: number
    reviewCount: number
    category: string
    description: string
    longDescription: string | null
    destinations: string
    includes: string
    excludes: string | null
    highlights: string
    itinerary: string | null
    gallery: string | null
    faqs: string | null
    groupSize: string
    difficulty: string
    bestFor: string
    image: string
    departure: string | null
    return: string | null
    totalPeople: number | null
    location: string | null
    mapEmbedUrl: string | null
    featured: boolean
    available: boolean
    status: string
    localizedUrls: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    updatedAt: Date
    createdAt: Date
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    duration?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    rating?: boolean
    reviewCount?: boolean
    category?: boolean
    description?: boolean
    longDescription?: boolean
    destinations?: boolean
    includes?: boolean
    excludes?: boolean
    highlights?: boolean
    itinerary?: boolean
    gallery?: boolean
    faqs?: boolean
    groupSize?: boolean
    difficulty?: boolean
    bestFor?: boolean
    image?: boolean
    departure?: boolean
    return?: boolean
    totalPeople?: boolean
    location?: boolean
    mapEmbedUrl?: boolean
    featured?: boolean
    available?: boolean
    status?: boolean
    localizedUrls?: boolean
    urlPathEn?: boolean
    urlPathDe?: boolean
    urlPathNl?: boolean
    urlPathZh?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["package"]>



  export type PackageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    duration?: boolean
    price?: boolean
    originalPrice?: boolean
    discount?: boolean
    rating?: boolean
    reviewCount?: boolean
    category?: boolean
    description?: boolean
    longDescription?: boolean
    destinations?: boolean
    includes?: boolean
    excludes?: boolean
    highlights?: boolean
    itinerary?: boolean
    gallery?: boolean
    faqs?: boolean
    groupSize?: boolean
    difficulty?: boolean
    bestFor?: boolean
    image?: boolean
    departure?: boolean
    return?: boolean
    totalPeople?: boolean
    location?: boolean
    mapEmbedUrl?: boolean
    featured?: boolean
    available?: boolean
    status?: boolean
    localizedUrls?: boolean
    urlPathEn?: boolean
    urlPathDe?: boolean
    urlPathNl?: boolean
    urlPathZh?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type PackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "duration" | "price" | "originalPrice" | "discount" | "rating" | "reviewCount" | "category" | "description" | "longDescription" | "destinations" | "includes" | "excludes" | "highlights" | "itinerary" | "gallery" | "faqs" | "groupSize" | "difficulty" | "bestFor" | "image" | "departure" | "return" | "totalPeople" | "location" | "mapEmbedUrl" | "featured" | "available" | "status" | "localizedUrls" | "urlPathEn" | "urlPathDe" | "urlPathNl" | "urlPathZh" | "updatedAt" | "createdAt", ExtArgs["result"]["package"]>

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string | null
      duration: string
      price: number
      originalPrice: number | null
      discount: string | null
      rating: number
      reviewCount: number
      category: string
      description: string
      longDescription: string | null
      destinations: string
      includes: string
      excludes: string | null
      highlights: string
      itinerary: string | null
      gallery: string | null
      faqs: string | null
      groupSize: string
      difficulty: string
      bestFor: string
      image: string
      departure: string | null
      return: string | null
      totalPeople: number | null
      location: string | null
      mapEmbedUrl: string | null
      featured: boolean
      available: boolean
      status: string
      localizedUrls: string | null
      urlPathEn: string | null
      urlPathDe: string | null
      urlPathNl: string | null
      urlPathZh: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'String'>
    readonly title: FieldRef<"Package", 'String'>
    readonly slug: FieldRef<"Package", 'String'>
    readonly duration: FieldRef<"Package", 'String'>
    readonly price: FieldRef<"Package", 'Float'>
    readonly originalPrice: FieldRef<"Package", 'Float'>
    readonly discount: FieldRef<"Package", 'String'>
    readonly rating: FieldRef<"Package", 'Float'>
    readonly reviewCount: FieldRef<"Package", 'Int'>
    readonly category: FieldRef<"Package", 'String'>
    readonly description: FieldRef<"Package", 'String'>
    readonly longDescription: FieldRef<"Package", 'String'>
    readonly destinations: FieldRef<"Package", 'String'>
    readonly includes: FieldRef<"Package", 'String'>
    readonly excludes: FieldRef<"Package", 'String'>
    readonly highlights: FieldRef<"Package", 'String'>
    readonly itinerary: FieldRef<"Package", 'String'>
    readonly gallery: FieldRef<"Package", 'String'>
    readonly faqs: FieldRef<"Package", 'String'>
    readonly groupSize: FieldRef<"Package", 'String'>
    readonly difficulty: FieldRef<"Package", 'String'>
    readonly bestFor: FieldRef<"Package", 'String'>
    readonly image: FieldRef<"Package", 'String'>
    readonly departure: FieldRef<"Package", 'String'>
    readonly return: FieldRef<"Package", 'String'>
    readonly totalPeople: FieldRef<"Package", 'Int'>
    readonly location: FieldRef<"Package", 'String'>
    readonly mapEmbedUrl: FieldRef<"Package", 'String'>
    readonly featured: FieldRef<"Package", 'Boolean'>
    readonly available: FieldRef<"Package", 'Boolean'>
    readonly status: FieldRef<"Package", 'String'>
    readonly localizedUrls: FieldRef<"Package", 'String'>
    readonly urlPathEn: FieldRef<"Package", 'String'>
    readonly urlPathDe: FieldRef<"Package", 'String'>
    readonly urlPathNl: FieldRef<"Package", 'String'>
    readonly urlPathZh: FieldRef<"Package", 'String'>
    readonly updatedAt: FieldRef<"Package", 'DateTime'>
    readonly createdAt: FieldRef<"Package", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to delete.
     */
    limit?: number
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    author: string | null
    publishDate: Date | null
    readTime: string | null
    category: string | null
    tags: string | null
    image: string | null
    featured: boolean | null
    status: string | null
    localizedUrls: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    author: string | null
    publishDate: Date | null
    readTime: string | null
    category: string | null
    tags: string | null
    image: string | null
    featured: boolean | null
    status: string | null
    localizedUrls: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    excerpt: number
    content: number
    author: number
    publishDate: number
    readTime: number
    category: number
    tags: number
    image: number
    featured: number
    status: number
    localizedUrls: number
    urlPathEn: number
    urlPathDe: number
    urlPathNl: number
    urlPathZh: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type BlogMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    excerpt?: true
    content?: true
    author?: true
    publishDate?: true
    readTime?: true
    category?: true
    tags?: true
    image?: true
    featured?: true
    status?: true
    localizedUrls?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    excerpt?: true
    content?: true
    author?: true
    publishDate?: true
    readTime?: true
    category?: true
    tags?: true
    image?: true
    featured?: true
    status?: true
    localizedUrls?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    excerpt?: true
    content?: true
    author?: true
    publishDate?: true
    readTime?: true
    category?: true
    tags?: true
    image?: true
    featured?: true
    status?: true
    localizedUrls?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: string
    slug: string | null
    title: string
    excerpt: string
    content: string
    author: string
    publishDate: Date
    readTime: string
    category: string
    tags: string
    image: string
    featured: boolean
    status: string
    localizedUrls: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    updatedAt: Date
    createdAt: Date
    _count: BlogCountAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    author?: boolean
    publishDate?: boolean
    readTime?: boolean
    category?: boolean
    tags?: boolean
    image?: boolean
    featured?: boolean
    status?: boolean
    localizedUrls?: boolean
    urlPathEn?: boolean
    urlPathDe?: boolean
    urlPathNl?: boolean
    urlPathZh?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blog"]>



  export type BlogSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    author?: boolean
    publishDate?: boolean
    readTime?: boolean
    category?: boolean
    tags?: boolean
    image?: boolean
    featured?: boolean
    status?: boolean
    localizedUrls?: boolean
    urlPathEn?: boolean
    urlPathDe?: boolean
    urlPathNl?: boolean
    urlPathZh?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type BlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "excerpt" | "content" | "author" | "publishDate" | "readTime" | "category" | "tags" | "image" | "featured" | "status" | "localizedUrls" | "urlPathEn" | "urlPathDe" | "urlPathNl" | "urlPathZh" | "updatedAt" | "createdAt", ExtArgs["result"]["blog"]>

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string | null
      title: string
      excerpt: string
      content: string
      author: string
      publishDate: Date
      readTime: string
      category: string
      tags: string
      image: string
      featured: boolean
      status: string
      localizedUrls: string | null
      urlPathEn: string | null
      urlPathDe: string | null
      urlPathNl: string | null
      urlPathZh: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'String'>
    readonly slug: FieldRef<"Blog", 'String'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly excerpt: FieldRef<"Blog", 'String'>
    readonly content: FieldRef<"Blog", 'String'>
    readonly author: FieldRef<"Blog", 'String'>
    readonly publishDate: FieldRef<"Blog", 'DateTime'>
    readonly readTime: FieldRef<"Blog", 'String'>
    readonly category: FieldRef<"Blog", 'String'>
    readonly tags: FieldRef<"Blog", 'String'>
    readonly image: FieldRef<"Blog", 'String'>
    readonly featured: FieldRef<"Blog", 'Boolean'>
    readonly status: FieldRef<"Blog", 'String'>
    readonly localizedUrls: FieldRef<"Blog", 'String'>
    readonly urlPathEn: FieldRef<"Blog", 'String'>
    readonly urlPathDe: FieldRef<"Blog", 'String'>
    readonly urlPathNl: FieldRef<"Blog", 'String'>
    readonly urlPathZh: FieldRef<"Blog", 'String'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to delete.
     */
    limit?: number
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
  }


  /**
   * Model Testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialAvgAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialSumAggregateOutputType = {
    rating: number | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    content: string | null
    rating: number | null
    image: string | null
    packageName: string | null
    location: string | null
    status: string | null
    featured: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    content: string | null
    rating: number | null
    image: string | null
    packageName: string | null
    location: string | null
    status: string | null
    featured: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    name: number
    role: number
    content: number
    rating: number
    image: number
    packageName: number
    location: number
    status: number
    featured: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type TestimonialAvgAggregateInputType = {
    rating?: true
  }

  export type TestimonialSumAggregateInputType = {
    rating?: true
  }

  export type TestimonialMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    content?: true
    rating?: true
    image?: true
    packageName?: true
    location?: true
    status?: true
    featured?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    content?: true
    rating?: true
    image?: true
    packageName?: true
    location?: true
    status?: true
    featured?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    content?: true
    rating?: true
    image?: true
    packageName?: true
    location?: true
    status?: true
    featured?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonial to aggregate.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestimonialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestimonialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type TestimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialWhereInput
    orderBy?: TestimonialOrderByWithAggregationInput | TestimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: TestimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _avg?: TestimonialAvgAggregateInputType
    _sum?: TestimonialSumAggregateInputType
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    name: string
    role: string
    content: string
    rating: number
    image: string | null
    packageName: string
    location: string
    status: string
    featured: boolean
    updatedAt: Date
    createdAt: Date
    _count: TestimonialCountAggregateOutputType | null
    _avg: TestimonialAvgAggregateOutputType | null
    _sum: TestimonialSumAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends TestimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    content?: boolean
    rating?: boolean
    image?: boolean
    packageName?: boolean
    location?: boolean
    status?: boolean
    featured?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["testimonial"]>



  export type TestimonialSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    content?: boolean
    rating?: boolean
    image?: boolean
    packageName?: boolean
    location?: boolean
    status?: boolean
    featured?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type TestimonialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "content" | "rating" | "image" | "packageName" | "location" | "status" | "featured" | "updatedAt" | "createdAt", ExtArgs["result"]["testimonial"]>

  export type $TestimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Testimonial"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      content: string
      rating: number
      image: string | null
      packageName: string
      location: string
      status: string
      featured: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type TestimonialGetPayload<S extends boolean | null | undefined | TestimonialDefaultArgs> = $Result.GetResult<Prisma.$TestimonialPayload, S>

  type TestimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface TestimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Testimonial'], meta: { name: 'Testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {TestimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialFindUniqueArgs>(args: SelectSubset<T, TestimonialFindUniqueArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialFindFirstArgs>(args?: SelectSubset<T, TestimonialFindFirstArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialFindManyArgs>(args?: SelectSubset<T, TestimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testimonial.
     * @param {TestimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends TestimonialCreateArgs>(args: SelectSubset<T, TestimonialCreateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testimonials.
     * @param {TestimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialCreateManyArgs>(args?: SelectSubset<T, TestimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testimonial.
     * @param {TestimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends TestimonialDeleteArgs>(args: SelectSubset<T, TestimonialDeleteArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testimonial.
     * @param {TestimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialUpdateArgs>(args: SelectSubset<T, TestimonialUpdateArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testimonials.
     * @param {TestimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialDeleteManyArgs>(args?: SelectSubset<T, TestimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialUpdateManyArgs>(args: SelectSubset<T, TestimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {TestimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialUpsertArgs>(args: SelectSubset<T, TestimonialUpsertArgs<ExtArgs>>): Prisma__TestimonialClient<$Result.GetResult<Prisma.$TestimonialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends TestimonialCountArgs>(
      args?: Subset<T, TestimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Testimonial model
   */
  readonly fields: TestimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Testimonial model
   */
  interface TestimonialFieldRefs {
    readonly id: FieldRef<"Testimonial", 'String'>
    readonly name: FieldRef<"Testimonial", 'String'>
    readonly role: FieldRef<"Testimonial", 'String'>
    readonly content: FieldRef<"Testimonial", 'String'>
    readonly rating: FieldRef<"Testimonial", 'Int'>
    readonly image: FieldRef<"Testimonial", 'String'>
    readonly packageName: FieldRef<"Testimonial", 'String'>
    readonly location: FieldRef<"Testimonial", 'String'>
    readonly status: FieldRef<"Testimonial", 'String'>
    readonly featured: FieldRef<"Testimonial", 'Boolean'>
    readonly updatedAt: FieldRef<"Testimonial", 'DateTime'>
    readonly createdAt: FieldRef<"Testimonial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Testimonial findUnique
   */
  export type TestimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findUniqueOrThrow
   */
  export type TestimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial findFirst
   */
  export type TestimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findFirstOrThrow
   */
  export type TestimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonial to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial findMany
   */
  export type TestimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter, which Testimonials to fetch.
     */
    where?: TestimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Testimonials to fetch.
     */
    orderBy?: TestimonialOrderByWithRelationInput | TestimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Testimonials.
     */
    cursor?: TestimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * Testimonial create
   */
  export type TestimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data needed to create a Testimonial.
     */
    data: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
  }

  /**
   * Testimonial createMany
   */
  export type TestimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Testimonials.
     */
    data: TestimonialCreateManyInput | TestimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Testimonial update
   */
  export type TestimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The data needed to update a Testimonial.
     */
    data: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
    /**
     * Choose, which Testimonial to update.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial updateMany
   */
  export type TestimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Testimonials.
     */
    data: XOR<TestimonialUpdateManyMutationInput, TestimonialUncheckedUpdateManyInput>
    /**
     * Filter which Testimonials to update
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to update.
     */
    limit?: number
  }

  /**
   * Testimonial upsert
   */
  export type TestimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * The filter to search for the Testimonial to update in case it exists.
     */
    where: TestimonialWhereUniqueInput
    /**
     * In case the Testimonial found by the `where` argument doesn't exist, create a new Testimonial with this data.
     */
    create: XOR<TestimonialCreateInput, TestimonialUncheckedCreateInput>
    /**
     * In case the Testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialUpdateInput, TestimonialUncheckedUpdateInput>
  }

  /**
   * Testimonial delete
   */
  export type TestimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
    /**
     * Filter which Testimonial to delete.
     */
    where: TestimonialWhereUniqueInput
  }

  /**
   * Testimonial deleteMany
   */
  export type TestimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Testimonials to delete
     */
    where?: TestimonialWhereInput
    /**
     * Limit how many Testimonials to delete.
     */
    limit?: number
  }

  /**
   * Testimonial without action
   */
  export type TestimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Testimonial
     */
    select?: TestimonialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Testimonial
     */
    omit?: TestimonialOmit<ExtArgs> | null
  }


  /**
   * Model GalleryItem
   */

  export type AggregateGalleryItem = {
    _count: GalleryItemCountAggregateOutputType | null
    _avg: GalleryItemAvgAggregateOutputType | null
    _sum: GalleryItemSumAggregateOutputType | null
    _min: GalleryItemMinAggregateOutputType | null
    _max: GalleryItemMaxAggregateOutputType | null
  }

  export type GalleryItemAvgAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type GalleryItemSumAggregateOutputType = {
    likes: number | null
    views: number | null
  }

  export type GalleryItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    category: string | null
    image: string | null
    description: string | null
    tags: string | null
    likes: number | null
    views: number | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type GalleryItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    category: string | null
    image: string | null
    description: string | null
    tags: string | null
    likes: number | null
    views: number | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type GalleryItemCountAggregateOutputType = {
    id: number
    title: number
    category: number
    image: number
    description: number
    tags: number
    likes: number
    views: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type GalleryItemAvgAggregateInputType = {
    likes?: true
    views?: true
  }

  export type GalleryItemSumAggregateInputType = {
    likes?: true
    views?: true
  }

  export type GalleryItemMinAggregateInputType = {
    id?: true
    title?: true
    category?: true
    image?: true
    description?: true
    tags?: true
    likes?: true
    views?: true
    updatedAt?: true
    createdAt?: true
  }

  export type GalleryItemMaxAggregateInputType = {
    id?: true
    title?: true
    category?: true
    image?: true
    description?: true
    tags?: true
    likes?: true
    views?: true
    updatedAt?: true
    createdAt?: true
  }

  export type GalleryItemCountAggregateInputType = {
    id?: true
    title?: true
    category?: true
    image?: true
    description?: true
    tags?: true
    likes?: true
    views?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type GalleryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GalleryItem to aggregate.
     */
    where?: GalleryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryItems to fetch.
     */
    orderBy?: GalleryItemOrderByWithRelationInput | GalleryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GalleryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GalleryItems
    **/
    _count?: true | GalleryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GalleryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GalleryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GalleryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GalleryItemMaxAggregateInputType
  }

  export type GetGalleryItemAggregateType<T extends GalleryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateGalleryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGalleryItem[P]>
      : GetScalarType<T[P], AggregateGalleryItem[P]>
  }




  export type GalleryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GalleryItemWhereInput
    orderBy?: GalleryItemOrderByWithAggregationInput | GalleryItemOrderByWithAggregationInput[]
    by: GalleryItemScalarFieldEnum[] | GalleryItemScalarFieldEnum
    having?: GalleryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GalleryItemCountAggregateInputType | true
    _avg?: GalleryItemAvgAggregateInputType
    _sum?: GalleryItemSumAggregateInputType
    _min?: GalleryItemMinAggregateInputType
    _max?: GalleryItemMaxAggregateInputType
  }

  export type GalleryItemGroupByOutputType = {
    id: string
    title: string
    category: string
    image: string
    description: string | null
    tags: string
    likes: number
    views: number
    updatedAt: Date
    createdAt: Date
    _count: GalleryItemCountAggregateOutputType | null
    _avg: GalleryItemAvgAggregateOutputType | null
    _sum: GalleryItemSumAggregateOutputType | null
    _min: GalleryItemMinAggregateOutputType | null
    _max: GalleryItemMaxAggregateOutputType | null
  }

  type GetGalleryItemGroupByPayload<T extends GalleryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GalleryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GalleryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GalleryItemGroupByOutputType[P]>
            : GetScalarType<T[P], GalleryItemGroupByOutputType[P]>
        }
      >
    >


  export type GalleryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    category?: boolean
    image?: boolean
    description?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["galleryItem"]>



  export type GalleryItemSelectScalar = {
    id?: boolean
    title?: boolean
    category?: boolean
    image?: boolean
    description?: boolean
    tags?: boolean
    likes?: boolean
    views?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type GalleryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "category" | "image" | "description" | "tags" | "likes" | "views" | "updatedAt" | "createdAt", ExtArgs["result"]["galleryItem"]>

  export type $GalleryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GalleryItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      category: string
      image: string
      description: string | null
      tags: string
      likes: number
      views: number
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["galleryItem"]>
    composites: {}
  }

  type GalleryItemGetPayload<S extends boolean | null | undefined | GalleryItemDefaultArgs> = $Result.GetResult<Prisma.$GalleryItemPayload, S>

  type GalleryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GalleryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GalleryItemCountAggregateInputType | true
    }

  export interface GalleryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GalleryItem'], meta: { name: 'GalleryItem' } }
    /**
     * Find zero or one GalleryItem that matches the filter.
     * @param {GalleryItemFindUniqueArgs} args - Arguments to find a GalleryItem
     * @example
     * // Get one GalleryItem
     * const galleryItem = await prisma.galleryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GalleryItemFindUniqueArgs>(args: SelectSubset<T, GalleryItemFindUniqueArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GalleryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GalleryItemFindUniqueOrThrowArgs} args - Arguments to find a GalleryItem
     * @example
     * // Get one GalleryItem
     * const galleryItem = await prisma.galleryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GalleryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, GalleryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GalleryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemFindFirstArgs} args - Arguments to find a GalleryItem
     * @example
     * // Get one GalleryItem
     * const galleryItem = await prisma.galleryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GalleryItemFindFirstArgs>(args?: SelectSubset<T, GalleryItemFindFirstArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GalleryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemFindFirstOrThrowArgs} args - Arguments to find a GalleryItem
     * @example
     * // Get one GalleryItem
     * const galleryItem = await prisma.galleryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GalleryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, GalleryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GalleryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GalleryItems
     * const galleryItems = await prisma.galleryItem.findMany()
     * 
     * // Get first 10 GalleryItems
     * const galleryItems = await prisma.galleryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const galleryItemWithIdOnly = await prisma.galleryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GalleryItemFindManyArgs>(args?: SelectSubset<T, GalleryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GalleryItem.
     * @param {GalleryItemCreateArgs} args - Arguments to create a GalleryItem.
     * @example
     * // Create one GalleryItem
     * const GalleryItem = await prisma.galleryItem.create({
     *   data: {
     *     // ... data to create a GalleryItem
     *   }
     * })
     * 
     */
    create<T extends GalleryItemCreateArgs>(args: SelectSubset<T, GalleryItemCreateArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GalleryItems.
     * @param {GalleryItemCreateManyArgs} args - Arguments to create many GalleryItems.
     * @example
     * // Create many GalleryItems
     * const galleryItem = await prisma.galleryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GalleryItemCreateManyArgs>(args?: SelectSubset<T, GalleryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GalleryItem.
     * @param {GalleryItemDeleteArgs} args - Arguments to delete one GalleryItem.
     * @example
     * // Delete one GalleryItem
     * const GalleryItem = await prisma.galleryItem.delete({
     *   where: {
     *     // ... filter to delete one GalleryItem
     *   }
     * })
     * 
     */
    delete<T extends GalleryItemDeleteArgs>(args: SelectSubset<T, GalleryItemDeleteArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GalleryItem.
     * @param {GalleryItemUpdateArgs} args - Arguments to update one GalleryItem.
     * @example
     * // Update one GalleryItem
     * const galleryItem = await prisma.galleryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GalleryItemUpdateArgs>(args: SelectSubset<T, GalleryItemUpdateArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GalleryItems.
     * @param {GalleryItemDeleteManyArgs} args - Arguments to filter GalleryItems to delete.
     * @example
     * // Delete a few GalleryItems
     * const { count } = await prisma.galleryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GalleryItemDeleteManyArgs>(args?: SelectSubset<T, GalleryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GalleryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GalleryItems
     * const galleryItem = await prisma.galleryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GalleryItemUpdateManyArgs>(args: SelectSubset<T, GalleryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GalleryItem.
     * @param {GalleryItemUpsertArgs} args - Arguments to update or create a GalleryItem.
     * @example
     * // Update or create a GalleryItem
     * const galleryItem = await prisma.galleryItem.upsert({
     *   create: {
     *     // ... data to create a GalleryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GalleryItem we want to update
     *   }
     * })
     */
    upsert<T extends GalleryItemUpsertArgs>(args: SelectSubset<T, GalleryItemUpsertArgs<ExtArgs>>): Prisma__GalleryItemClient<$Result.GetResult<Prisma.$GalleryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GalleryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemCountArgs} args - Arguments to filter GalleryItems to count.
     * @example
     * // Count the number of GalleryItems
     * const count = await prisma.galleryItem.count({
     *   where: {
     *     // ... the filter for the GalleryItems we want to count
     *   }
     * })
    **/
    count<T extends GalleryItemCountArgs>(
      args?: Subset<T, GalleryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GalleryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GalleryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GalleryItemAggregateArgs>(args: Subset<T, GalleryItemAggregateArgs>): Prisma.PrismaPromise<GetGalleryItemAggregateType<T>>

    /**
     * Group by GalleryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GalleryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GalleryItemGroupByArgs['orderBy'] }
        : { orderBy?: GalleryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GalleryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGalleryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GalleryItem model
   */
  readonly fields: GalleryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GalleryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GalleryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GalleryItem model
   */
  interface GalleryItemFieldRefs {
    readonly id: FieldRef<"GalleryItem", 'String'>
    readonly title: FieldRef<"GalleryItem", 'String'>
    readonly category: FieldRef<"GalleryItem", 'String'>
    readonly image: FieldRef<"GalleryItem", 'String'>
    readonly description: FieldRef<"GalleryItem", 'String'>
    readonly tags: FieldRef<"GalleryItem", 'String'>
    readonly likes: FieldRef<"GalleryItem", 'Int'>
    readonly views: FieldRef<"GalleryItem", 'Int'>
    readonly updatedAt: FieldRef<"GalleryItem", 'DateTime'>
    readonly createdAt: FieldRef<"GalleryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GalleryItem findUnique
   */
  export type GalleryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * Filter, which GalleryItem to fetch.
     */
    where: GalleryItemWhereUniqueInput
  }

  /**
   * GalleryItem findUniqueOrThrow
   */
  export type GalleryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * Filter, which GalleryItem to fetch.
     */
    where: GalleryItemWhereUniqueInput
  }

  /**
   * GalleryItem findFirst
   */
  export type GalleryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * Filter, which GalleryItem to fetch.
     */
    where?: GalleryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryItems to fetch.
     */
    orderBy?: GalleryItemOrderByWithRelationInput | GalleryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GalleryItems.
     */
    cursor?: GalleryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GalleryItems.
     */
    distinct?: GalleryItemScalarFieldEnum | GalleryItemScalarFieldEnum[]
  }

  /**
   * GalleryItem findFirstOrThrow
   */
  export type GalleryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * Filter, which GalleryItem to fetch.
     */
    where?: GalleryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryItems to fetch.
     */
    orderBy?: GalleryItemOrderByWithRelationInput | GalleryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GalleryItems.
     */
    cursor?: GalleryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GalleryItems.
     */
    distinct?: GalleryItemScalarFieldEnum | GalleryItemScalarFieldEnum[]
  }

  /**
   * GalleryItem findMany
   */
  export type GalleryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * Filter, which GalleryItems to fetch.
     */
    where?: GalleryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryItems to fetch.
     */
    orderBy?: GalleryItemOrderByWithRelationInput | GalleryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GalleryItems.
     */
    cursor?: GalleryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryItems.
     */
    skip?: number
    distinct?: GalleryItemScalarFieldEnum | GalleryItemScalarFieldEnum[]
  }

  /**
   * GalleryItem create
   */
  export type GalleryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * The data needed to create a GalleryItem.
     */
    data: XOR<GalleryItemCreateInput, GalleryItemUncheckedCreateInput>
  }

  /**
   * GalleryItem createMany
   */
  export type GalleryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GalleryItems.
     */
    data: GalleryItemCreateManyInput | GalleryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GalleryItem update
   */
  export type GalleryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * The data needed to update a GalleryItem.
     */
    data: XOR<GalleryItemUpdateInput, GalleryItemUncheckedUpdateInput>
    /**
     * Choose, which GalleryItem to update.
     */
    where: GalleryItemWhereUniqueInput
  }

  /**
   * GalleryItem updateMany
   */
  export type GalleryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GalleryItems.
     */
    data: XOR<GalleryItemUpdateManyMutationInput, GalleryItemUncheckedUpdateManyInput>
    /**
     * Filter which GalleryItems to update
     */
    where?: GalleryItemWhereInput
    /**
     * Limit how many GalleryItems to update.
     */
    limit?: number
  }

  /**
   * GalleryItem upsert
   */
  export type GalleryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * The filter to search for the GalleryItem to update in case it exists.
     */
    where: GalleryItemWhereUniqueInput
    /**
     * In case the GalleryItem found by the `where` argument doesn't exist, create a new GalleryItem with this data.
     */
    create: XOR<GalleryItemCreateInput, GalleryItemUncheckedCreateInput>
    /**
     * In case the GalleryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GalleryItemUpdateInput, GalleryItemUncheckedUpdateInput>
  }

  /**
   * GalleryItem delete
   */
  export type GalleryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
    /**
     * Filter which GalleryItem to delete.
     */
    where: GalleryItemWhereUniqueInput
  }

  /**
   * GalleryItem deleteMany
   */
  export type GalleryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GalleryItems to delete
     */
    where?: GalleryItemWhereInput
    /**
     * Limit how many GalleryItems to delete.
     */
    limit?: number
  }

  /**
   * GalleryItem without action
   */
  export type GalleryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryItem
     */
    select?: GalleryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryItem
     */
    omit?: GalleryItemOmit<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    whatsappNumber: string | null
    whatsappGreeting: string | null
    providerName: string | null
    memberSince: string | null
    providerPhone: string | null
    providerEmail: string | null
    brandName: string | null
    siteLogo: string | null
    siteTagline: string | null
    favicon: string | null
    siteName: string | null
    siteDescription: string | null
    defaultOgImage: string | null
    siteUrl: string | null
    googleSiteVerification: string | null
    bingSiteVerification: string | null
    activeTemplate: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    whatsappNumber: string | null
    whatsappGreeting: string | null
    providerName: string | null
    memberSince: string | null
    providerPhone: string | null
    providerEmail: string | null
    brandName: string | null
    siteLogo: string | null
    siteTagline: string | null
    favicon: string | null
    siteName: string | null
    siteDescription: string | null
    defaultOgImage: string | null
    siteUrl: string | null
    googleSiteVerification: string | null
    bingSiteVerification: string | null
    activeTemplate: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    whatsappNumber: number
    whatsappGreeting: number
    providerName: number
    memberSince: number
    providerPhone: number
    providerEmail: number
    brandName: number
    siteLogo: number
    siteTagline: number
    favicon: number
    siteName: number
    siteDescription: number
    defaultOgImage: number
    siteUrl: number
    googleSiteVerification: number
    bingSiteVerification: number
    activeTemplate: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    whatsappNumber?: true
    whatsappGreeting?: true
    providerName?: true
    memberSince?: true
    providerPhone?: true
    providerEmail?: true
    brandName?: true
    siteLogo?: true
    siteTagline?: true
    favicon?: true
    siteName?: true
    siteDescription?: true
    defaultOgImage?: true
    siteUrl?: true
    googleSiteVerification?: true
    bingSiteVerification?: true
    activeTemplate?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    whatsappNumber?: true
    whatsappGreeting?: true
    providerName?: true
    memberSince?: true
    providerPhone?: true
    providerEmail?: true
    brandName?: true
    siteLogo?: true
    siteTagline?: true
    favicon?: true
    siteName?: true
    siteDescription?: true
    defaultOgImage?: true
    siteUrl?: true
    googleSiteVerification?: true
    bingSiteVerification?: true
    activeTemplate?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    whatsappNumber?: true
    whatsappGreeting?: true
    providerName?: true
    memberSince?: true
    providerPhone?: true
    providerEmail?: true
    brandName?: true
    siteLogo?: true
    siteTagline?: true
    favicon?: true
    siteName?: true
    siteDescription?: true
    defaultOgImage?: true
    siteUrl?: true
    googleSiteVerification?: true
    bingSiteVerification?: true
    activeTemplate?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    whatsappNumber: string
    whatsappGreeting: string | null
    providerName: string
    memberSince: string
    providerPhone: string
    providerEmail: string
    brandName: string | null
    siteLogo: string | null
    siteTagline: string | null
    favicon: string | null
    siteName: string
    siteDescription: string | null
    defaultOgImage: string
    siteUrl: string
    googleSiteVerification: string
    bingSiteVerification: string
    activeTemplate: string
    updatedAt: Date
    createdAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    whatsappNumber?: boolean
    whatsappGreeting?: boolean
    providerName?: boolean
    memberSince?: boolean
    providerPhone?: boolean
    providerEmail?: boolean
    brandName?: boolean
    siteLogo?: boolean
    siteTagline?: boolean
    favicon?: boolean
    siteName?: boolean
    siteDescription?: boolean
    defaultOgImage?: boolean
    siteUrl?: boolean
    googleSiteVerification?: boolean
    bingSiteVerification?: boolean
    activeTemplate?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["settings"]>



  export type SettingsSelectScalar = {
    id?: boolean
    whatsappNumber?: boolean
    whatsappGreeting?: boolean
    providerName?: boolean
    memberSince?: boolean
    providerPhone?: boolean
    providerEmail?: boolean
    brandName?: boolean
    siteLogo?: boolean
    siteTagline?: boolean
    favicon?: boolean
    siteName?: boolean
    siteDescription?: boolean
    defaultOgImage?: boolean
    siteUrl?: boolean
    googleSiteVerification?: boolean
    bingSiteVerification?: boolean
    activeTemplate?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "whatsappNumber" | "whatsappGreeting" | "providerName" | "memberSince" | "providerPhone" | "providerEmail" | "brandName" | "siteLogo" | "siteTagline" | "favicon" | "siteName" | "siteDescription" | "defaultOgImage" | "siteUrl" | "googleSiteVerification" | "bingSiteVerification" | "activeTemplate" | "updatedAt" | "createdAt", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      whatsappNumber: string
      whatsappGreeting: string | null
      providerName: string
      memberSince: string
      providerPhone: string
      providerEmail: string
      brandName: string | null
      siteLogo: string | null
      siteTagline: string | null
      favicon: string | null
      siteName: string
      siteDescription: string | null
      defaultOgImage: string
      siteUrl: string
      googleSiteVerification: string
      bingSiteVerification: string
      activeTemplate: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly whatsappNumber: FieldRef<"Settings", 'String'>
    readonly whatsappGreeting: FieldRef<"Settings", 'String'>
    readonly providerName: FieldRef<"Settings", 'String'>
    readonly memberSince: FieldRef<"Settings", 'String'>
    readonly providerPhone: FieldRef<"Settings", 'String'>
    readonly providerEmail: FieldRef<"Settings", 'String'>
    readonly brandName: FieldRef<"Settings", 'String'>
    readonly siteLogo: FieldRef<"Settings", 'String'>
    readonly siteTagline: FieldRef<"Settings", 'String'>
    readonly favicon: FieldRef<"Settings", 'String'>
    readonly siteName: FieldRef<"Settings", 'String'>
    readonly siteDescription: FieldRef<"Settings", 'String'>
    readonly defaultOgImage: FieldRef<"Settings", 'String'>
    readonly siteUrl: FieldRef<"Settings", 'String'>
    readonly googleSiteVerification: FieldRef<"Settings", 'String'>
    readonly bingSiteVerification: FieldRef<"Settings", 'String'>
    readonly activeTemplate: FieldRef<"Settings", 'String'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
    readonly createdAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model LocalizedUrlSettings
   */

  export type AggregateLocalizedUrlSettings = {
    _count: LocalizedUrlSettingsCountAggregateOutputType | null
    _min: LocalizedUrlSettingsMinAggregateOutputType | null
    _max: LocalizedUrlSettingsMaxAggregateOutputType | null
  }

  export type LocalizedUrlSettingsMinAggregateOutputType = {
    id: string | null
    contentType: string | null
    urlPathId: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    autoGenerate: boolean | null
    customPattern: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LocalizedUrlSettingsMaxAggregateOutputType = {
    id: string | null
    contentType: string | null
    urlPathId: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    autoGenerate: boolean | null
    customPattern: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LocalizedUrlSettingsCountAggregateOutputType = {
    id: number
    contentType: number
    urlPathId: number
    urlPathEn: number
    urlPathDe: number
    urlPathNl: number
    urlPathZh: number
    autoGenerate: number
    customPattern: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type LocalizedUrlSettingsMinAggregateInputType = {
    id?: true
    contentType?: true
    urlPathId?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    autoGenerate?: true
    customPattern?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LocalizedUrlSettingsMaxAggregateInputType = {
    id?: true
    contentType?: true
    urlPathId?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    autoGenerate?: true
    customPattern?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LocalizedUrlSettingsCountAggregateInputType = {
    id?: true
    contentType?: true
    urlPathId?: true
    urlPathEn?: true
    urlPathDe?: true
    urlPathNl?: true
    urlPathZh?: true
    autoGenerate?: true
    customPattern?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LocalizedUrlSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalizedUrlSettings to aggregate.
     */
    where?: LocalizedUrlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizedUrlSettings to fetch.
     */
    orderBy?: LocalizedUrlSettingsOrderByWithRelationInput | LocalizedUrlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalizedUrlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizedUrlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizedUrlSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalizedUrlSettings
    **/
    _count?: true | LocalizedUrlSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalizedUrlSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalizedUrlSettingsMaxAggregateInputType
  }

  export type GetLocalizedUrlSettingsAggregateType<T extends LocalizedUrlSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalizedUrlSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalizedUrlSettings[P]>
      : GetScalarType<T[P], AggregateLocalizedUrlSettings[P]>
  }




  export type LocalizedUrlSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalizedUrlSettingsWhereInput
    orderBy?: LocalizedUrlSettingsOrderByWithAggregationInput | LocalizedUrlSettingsOrderByWithAggregationInput[]
    by: LocalizedUrlSettingsScalarFieldEnum[] | LocalizedUrlSettingsScalarFieldEnum
    having?: LocalizedUrlSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalizedUrlSettingsCountAggregateInputType | true
    _min?: LocalizedUrlSettingsMinAggregateInputType
    _max?: LocalizedUrlSettingsMaxAggregateInputType
  }

  export type LocalizedUrlSettingsGroupByOutputType = {
    id: string
    contentType: string
    urlPathId: string | null
    urlPathEn: string | null
    urlPathDe: string | null
    urlPathNl: string | null
    urlPathZh: string | null
    autoGenerate: boolean
    customPattern: string | null
    updatedAt: Date
    createdAt: Date
    _count: LocalizedUrlSettingsCountAggregateOutputType | null
    _min: LocalizedUrlSettingsMinAggregateOutputType | null
    _max: LocalizedUrlSettingsMaxAggregateOutputType | null
  }

  type GetLocalizedUrlSettingsGroupByPayload<T extends LocalizedUrlSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalizedUrlSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalizedUrlSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalizedUrlSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], LocalizedUrlSettingsGroupByOutputType[P]>
        }
      >
    >


  export type LocalizedUrlSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentType?: boolean
    urlPathId?: boolean
    urlPathEn?: boolean
    urlPathDe?: boolean
    urlPathNl?: boolean
    urlPathZh?: boolean
    autoGenerate?: boolean
    customPattern?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["localizedUrlSettings"]>



  export type LocalizedUrlSettingsSelectScalar = {
    id?: boolean
    contentType?: boolean
    urlPathId?: boolean
    urlPathEn?: boolean
    urlPathDe?: boolean
    urlPathNl?: boolean
    urlPathZh?: boolean
    autoGenerate?: boolean
    customPattern?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type LocalizedUrlSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentType" | "urlPathId" | "urlPathEn" | "urlPathDe" | "urlPathNl" | "urlPathZh" | "autoGenerate" | "customPattern" | "updatedAt" | "createdAt", ExtArgs["result"]["localizedUrlSettings"]>

  export type $LocalizedUrlSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalizedUrlSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentType: string
      urlPathId: string | null
      urlPathEn: string | null
      urlPathDe: string | null
      urlPathNl: string | null
      urlPathZh: string | null
      autoGenerate: boolean
      customPattern: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["localizedUrlSettings"]>
    composites: {}
  }

  type LocalizedUrlSettingsGetPayload<S extends boolean | null | undefined | LocalizedUrlSettingsDefaultArgs> = $Result.GetResult<Prisma.$LocalizedUrlSettingsPayload, S>

  type LocalizedUrlSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocalizedUrlSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalizedUrlSettingsCountAggregateInputType | true
    }

  export interface LocalizedUrlSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalizedUrlSettings'], meta: { name: 'LocalizedUrlSettings' } }
    /**
     * Find zero or one LocalizedUrlSettings that matches the filter.
     * @param {LocalizedUrlSettingsFindUniqueArgs} args - Arguments to find a LocalizedUrlSettings
     * @example
     * // Get one LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalizedUrlSettingsFindUniqueArgs>(args: SelectSubset<T, LocalizedUrlSettingsFindUniqueArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocalizedUrlSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocalizedUrlSettingsFindUniqueOrThrowArgs} args - Arguments to find a LocalizedUrlSettings
     * @example
     * // Get one LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalizedUrlSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalizedUrlSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalizedUrlSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsFindFirstArgs} args - Arguments to find a LocalizedUrlSettings
     * @example
     * // Get one LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalizedUrlSettingsFindFirstArgs>(args?: SelectSubset<T, LocalizedUrlSettingsFindFirstArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalizedUrlSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsFindFirstOrThrowArgs} args - Arguments to find a LocalizedUrlSettings
     * @example
     * // Get one LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalizedUrlSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalizedUrlSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalizedUrlSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.findMany()
     * 
     * // Get first 10 LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localizedUrlSettingsWithIdOnly = await prisma.localizedUrlSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalizedUrlSettingsFindManyArgs>(args?: SelectSubset<T, LocalizedUrlSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocalizedUrlSettings.
     * @param {LocalizedUrlSettingsCreateArgs} args - Arguments to create a LocalizedUrlSettings.
     * @example
     * // Create one LocalizedUrlSettings
     * const LocalizedUrlSettings = await prisma.localizedUrlSettings.create({
     *   data: {
     *     // ... data to create a LocalizedUrlSettings
     *   }
     * })
     * 
     */
    create<T extends LocalizedUrlSettingsCreateArgs>(args: SelectSubset<T, LocalizedUrlSettingsCreateArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocalizedUrlSettings.
     * @param {LocalizedUrlSettingsCreateManyArgs} args - Arguments to create many LocalizedUrlSettings.
     * @example
     * // Create many LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalizedUrlSettingsCreateManyArgs>(args?: SelectSubset<T, LocalizedUrlSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocalizedUrlSettings.
     * @param {LocalizedUrlSettingsDeleteArgs} args - Arguments to delete one LocalizedUrlSettings.
     * @example
     * // Delete one LocalizedUrlSettings
     * const LocalizedUrlSettings = await prisma.localizedUrlSettings.delete({
     *   where: {
     *     // ... filter to delete one LocalizedUrlSettings
     *   }
     * })
     * 
     */
    delete<T extends LocalizedUrlSettingsDeleteArgs>(args: SelectSubset<T, LocalizedUrlSettingsDeleteArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocalizedUrlSettings.
     * @param {LocalizedUrlSettingsUpdateArgs} args - Arguments to update one LocalizedUrlSettings.
     * @example
     * // Update one LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalizedUrlSettingsUpdateArgs>(args: SelectSubset<T, LocalizedUrlSettingsUpdateArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocalizedUrlSettings.
     * @param {LocalizedUrlSettingsDeleteManyArgs} args - Arguments to filter LocalizedUrlSettings to delete.
     * @example
     * // Delete a few LocalizedUrlSettings
     * const { count } = await prisma.localizedUrlSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalizedUrlSettingsDeleteManyArgs>(args?: SelectSubset<T, LocalizedUrlSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalizedUrlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalizedUrlSettingsUpdateManyArgs>(args: SelectSubset<T, LocalizedUrlSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalizedUrlSettings.
     * @param {LocalizedUrlSettingsUpsertArgs} args - Arguments to update or create a LocalizedUrlSettings.
     * @example
     * // Update or create a LocalizedUrlSettings
     * const localizedUrlSettings = await prisma.localizedUrlSettings.upsert({
     *   create: {
     *     // ... data to create a LocalizedUrlSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalizedUrlSettings we want to update
     *   }
     * })
     */
    upsert<T extends LocalizedUrlSettingsUpsertArgs>(args: SelectSubset<T, LocalizedUrlSettingsUpsertArgs<ExtArgs>>): Prisma__LocalizedUrlSettingsClient<$Result.GetResult<Prisma.$LocalizedUrlSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocalizedUrlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsCountArgs} args - Arguments to filter LocalizedUrlSettings to count.
     * @example
     * // Count the number of LocalizedUrlSettings
     * const count = await prisma.localizedUrlSettings.count({
     *   where: {
     *     // ... the filter for the LocalizedUrlSettings we want to count
     *   }
     * })
    **/
    count<T extends LocalizedUrlSettingsCountArgs>(
      args?: Subset<T, LocalizedUrlSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalizedUrlSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalizedUrlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalizedUrlSettingsAggregateArgs>(args: Subset<T, LocalizedUrlSettingsAggregateArgs>): Prisma.PrismaPromise<GetLocalizedUrlSettingsAggregateType<T>>

    /**
     * Group by LocalizedUrlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalizedUrlSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalizedUrlSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalizedUrlSettingsGroupByArgs['orderBy'] }
        : { orderBy?: LocalizedUrlSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalizedUrlSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalizedUrlSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalizedUrlSettings model
   */
  readonly fields: LocalizedUrlSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalizedUrlSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalizedUrlSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalizedUrlSettings model
   */
  interface LocalizedUrlSettingsFieldRefs {
    readonly id: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly contentType: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly urlPathId: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly urlPathEn: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly urlPathDe: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly urlPathNl: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly urlPathZh: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly autoGenerate: FieldRef<"LocalizedUrlSettings", 'Boolean'>
    readonly customPattern: FieldRef<"LocalizedUrlSettings", 'String'>
    readonly updatedAt: FieldRef<"LocalizedUrlSettings", 'DateTime'>
    readonly createdAt: FieldRef<"LocalizedUrlSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalizedUrlSettings findUnique
   */
  export type LocalizedUrlSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalizedUrlSettings to fetch.
     */
    where: LocalizedUrlSettingsWhereUniqueInput
  }

  /**
   * LocalizedUrlSettings findUniqueOrThrow
   */
  export type LocalizedUrlSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalizedUrlSettings to fetch.
     */
    where: LocalizedUrlSettingsWhereUniqueInput
  }

  /**
   * LocalizedUrlSettings findFirst
   */
  export type LocalizedUrlSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalizedUrlSettings to fetch.
     */
    where?: LocalizedUrlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizedUrlSettings to fetch.
     */
    orderBy?: LocalizedUrlSettingsOrderByWithRelationInput | LocalizedUrlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalizedUrlSettings.
     */
    cursor?: LocalizedUrlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizedUrlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizedUrlSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalizedUrlSettings.
     */
    distinct?: LocalizedUrlSettingsScalarFieldEnum | LocalizedUrlSettingsScalarFieldEnum[]
  }

  /**
   * LocalizedUrlSettings findFirstOrThrow
   */
  export type LocalizedUrlSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalizedUrlSettings to fetch.
     */
    where?: LocalizedUrlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizedUrlSettings to fetch.
     */
    orderBy?: LocalizedUrlSettingsOrderByWithRelationInput | LocalizedUrlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalizedUrlSettings.
     */
    cursor?: LocalizedUrlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizedUrlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizedUrlSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalizedUrlSettings.
     */
    distinct?: LocalizedUrlSettingsScalarFieldEnum | LocalizedUrlSettingsScalarFieldEnum[]
  }

  /**
   * LocalizedUrlSettings findMany
   */
  export type LocalizedUrlSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalizedUrlSettings to fetch.
     */
    where?: LocalizedUrlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalizedUrlSettings to fetch.
     */
    orderBy?: LocalizedUrlSettingsOrderByWithRelationInput | LocalizedUrlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalizedUrlSettings.
     */
    cursor?: LocalizedUrlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalizedUrlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalizedUrlSettings.
     */
    skip?: number
    distinct?: LocalizedUrlSettingsScalarFieldEnum | LocalizedUrlSettingsScalarFieldEnum[]
  }

  /**
   * LocalizedUrlSettings create
   */
  export type LocalizedUrlSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a LocalizedUrlSettings.
     */
    data: XOR<LocalizedUrlSettingsCreateInput, LocalizedUrlSettingsUncheckedCreateInput>
  }

  /**
   * LocalizedUrlSettings createMany
   */
  export type LocalizedUrlSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalizedUrlSettings.
     */
    data: LocalizedUrlSettingsCreateManyInput | LocalizedUrlSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocalizedUrlSettings update
   */
  export type LocalizedUrlSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a LocalizedUrlSettings.
     */
    data: XOR<LocalizedUrlSettingsUpdateInput, LocalizedUrlSettingsUncheckedUpdateInput>
    /**
     * Choose, which LocalizedUrlSettings to update.
     */
    where: LocalizedUrlSettingsWhereUniqueInput
  }

  /**
   * LocalizedUrlSettings updateMany
   */
  export type LocalizedUrlSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalizedUrlSettings.
     */
    data: XOR<LocalizedUrlSettingsUpdateManyMutationInput, LocalizedUrlSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LocalizedUrlSettings to update
     */
    where?: LocalizedUrlSettingsWhereInput
    /**
     * Limit how many LocalizedUrlSettings to update.
     */
    limit?: number
  }

  /**
   * LocalizedUrlSettings upsert
   */
  export type LocalizedUrlSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the LocalizedUrlSettings to update in case it exists.
     */
    where: LocalizedUrlSettingsWhereUniqueInput
    /**
     * In case the LocalizedUrlSettings found by the `where` argument doesn't exist, create a new LocalizedUrlSettings with this data.
     */
    create: XOR<LocalizedUrlSettingsCreateInput, LocalizedUrlSettingsUncheckedCreateInput>
    /**
     * In case the LocalizedUrlSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalizedUrlSettingsUpdateInput, LocalizedUrlSettingsUncheckedUpdateInput>
  }

  /**
   * LocalizedUrlSettings delete
   */
  export type LocalizedUrlSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
    /**
     * Filter which LocalizedUrlSettings to delete.
     */
    where: LocalizedUrlSettingsWhereUniqueInput
  }

  /**
   * LocalizedUrlSettings deleteMany
   */
  export type LocalizedUrlSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalizedUrlSettings to delete
     */
    where?: LocalizedUrlSettingsWhereInput
    /**
     * Limit how many LocalizedUrlSettings to delete.
     */
    limit?: number
  }

  /**
   * LocalizedUrlSettings without action
   */
  export type LocalizedUrlSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalizedUrlSettings
     */
    select?: LocalizedUrlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalizedUrlSettings
     */
    omit?: LocalizedUrlSettingsOmit<ExtArgs> | null
  }


  /**
   * Model SeoData
   */

  export type AggregateSeoData = {
    _count: SeoDataCountAggregateOutputType | null
    _min: SeoDataMinAggregateOutputType | null
    _max: SeoDataMaxAggregateOutputType | null
  }

  export type SeoDataMinAggregateOutputType = {
    id: string | null
    pageType: string | null
    pageSlug: string | null
    title: string | null
    description: string | null
    keywords: string | null
    canonicalUrl: string | null
    ogImage: string | null
    ogType: string | null
    noIndex: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SeoDataMaxAggregateOutputType = {
    id: string | null
    pageType: string | null
    pageSlug: string | null
    title: string | null
    description: string | null
    keywords: string | null
    canonicalUrl: string | null
    ogImage: string | null
    ogType: string | null
    noIndex: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SeoDataCountAggregateOutputType = {
    id: number
    pageType: number
    pageSlug: number
    title: number
    description: number
    keywords: number
    canonicalUrl: number
    ogImage: number
    ogType: number
    noIndex: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type SeoDataMinAggregateInputType = {
    id?: true
    pageType?: true
    pageSlug?: true
    title?: true
    description?: true
    keywords?: true
    canonicalUrl?: true
    ogImage?: true
    ogType?: true
    noIndex?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SeoDataMaxAggregateInputType = {
    id?: true
    pageType?: true
    pageSlug?: true
    title?: true
    description?: true
    keywords?: true
    canonicalUrl?: true
    ogImage?: true
    ogType?: true
    noIndex?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SeoDataCountAggregateInputType = {
    id?: true
    pageType?: true
    pageSlug?: true
    title?: true
    description?: true
    keywords?: true
    canonicalUrl?: true
    ogImage?: true
    ogType?: true
    noIndex?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SeoDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoData to aggregate.
     */
    where?: SeoDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoData to fetch.
     */
    orderBy?: SeoDataOrderByWithRelationInput | SeoDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeoDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeoData
    **/
    _count?: true | SeoDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeoDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeoDataMaxAggregateInputType
  }

  export type GetSeoDataAggregateType<T extends SeoDataAggregateArgs> = {
        [P in keyof T & keyof AggregateSeoData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeoData[P]>
      : GetScalarType<T[P], AggregateSeoData[P]>
  }




  export type SeoDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeoDataWhereInput
    orderBy?: SeoDataOrderByWithAggregationInput | SeoDataOrderByWithAggregationInput[]
    by: SeoDataScalarFieldEnum[] | SeoDataScalarFieldEnum
    having?: SeoDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeoDataCountAggregateInputType | true
    _min?: SeoDataMinAggregateInputType
    _max?: SeoDataMaxAggregateInputType
  }

  export type SeoDataGroupByOutputType = {
    id: string
    pageType: string
    pageSlug: string
    title: string
    description: string
    keywords: string | null
    canonicalUrl: string
    ogImage: string | null
    ogType: string
    noIndex: boolean
    updatedAt: Date
    createdAt: Date
    _count: SeoDataCountAggregateOutputType | null
    _min: SeoDataMinAggregateOutputType | null
    _max: SeoDataMaxAggregateOutputType | null
  }

  type GetSeoDataGroupByPayload<T extends SeoDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeoDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeoDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeoDataGroupByOutputType[P]>
            : GetScalarType<T[P], SeoDataGroupByOutputType[P]>
        }
      >
    >


  export type SeoDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageType?: boolean
    pageSlug?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    canonicalUrl?: boolean
    ogImage?: boolean
    ogType?: boolean
    noIndex?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["seoData"]>



  export type SeoDataSelectScalar = {
    id?: boolean
    pageType?: boolean
    pageSlug?: boolean
    title?: boolean
    description?: boolean
    keywords?: boolean
    canonicalUrl?: boolean
    ogImage?: boolean
    ogType?: boolean
    noIndex?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type SeoDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageType" | "pageSlug" | "title" | "description" | "keywords" | "canonicalUrl" | "ogImage" | "ogType" | "noIndex" | "updatedAt" | "createdAt", ExtArgs["result"]["seoData"]>

  export type $SeoDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SeoData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageType: string
      pageSlug: string
      title: string
      description: string
      keywords: string | null
      canonicalUrl: string
      ogImage: string | null
      ogType: string
      noIndex: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["seoData"]>
    composites: {}
  }

  type SeoDataGetPayload<S extends boolean | null | undefined | SeoDataDefaultArgs> = $Result.GetResult<Prisma.$SeoDataPayload, S>

  type SeoDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeoDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeoDataCountAggregateInputType | true
    }

  export interface SeoDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SeoData'], meta: { name: 'SeoData' } }
    /**
     * Find zero or one SeoData that matches the filter.
     * @param {SeoDataFindUniqueArgs} args - Arguments to find a SeoData
     * @example
     * // Get one SeoData
     * const seoData = await prisma.seoData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeoDataFindUniqueArgs>(args: SelectSubset<T, SeoDataFindUniqueArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SeoData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeoDataFindUniqueOrThrowArgs} args - Arguments to find a SeoData
     * @example
     * // Get one SeoData
     * const seoData = await prisma.seoData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeoDataFindUniqueOrThrowArgs>(args: SelectSubset<T, SeoDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataFindFirstArgs} args - Arguments to find a SeoData
     * @example
     * // Get one SeoData
     * const seoData = await prisma.seoData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeoDataFindFirstArgs>(args?: SelectSubset<T, SeoDataFindFirstArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SeoData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataFindFirstOrThrowArgs} args - Arguments to find a SeoData
     * @example
     * // Get one SeoData
     * const seoData = await prisma.seoData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeoDataFindFirstOrThrowArgs>(args?: SelectSubset<T, SeoDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SeoData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeoData
     * const seoData = await prisma.seoData.findMany()
     * 
     * // Get first 10 SeoData
     * const seoData = await prisma.seoData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seoDataWithIdOnly = await prisma.seoData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeoDataFindManyArgs>(args?: SelectSubset<T, SeoDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SeoData.
     * @param {SeoDataCreateArgs} args - Arguments to create a SeoData.
     * @example
     * // Create one SeoData
     * const SeoData = await prisma.seoData.create({
     *   data: {
     *     // ... data to create a SeoData
     *   }
     * })
     * 
     */
    create<T extends SeoDataCreateArgs>(args: SelectSubset<T, SeoDataCreateArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SeoData.
     * @param {SeoDataCreateManyArgs} args - Arguments to create many SeoData.
     * @example
     * // Create many SeoData
     * const seoData = await prisma.seoData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeoDataCreateManyArgs>(args?: SelectSubset<T, SeoDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeoData.
     * @param {SeoDataDeleteArgs} args - Arguments to delete one SeoData.
     * @example
     * // Delete one SeoData
     * const SeoData = await prisma.seoData.delete({
     *   where: {
     *     // ... filter to delete one SeoData
     *   }
     * })
     * 
     */
    delete<T extends SeoDataDeleteArgs>(args: SelectSubset<T, SeoDataDeleteArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SeoData.
     * @param {SeoDataUpdateArgs} args - Arguments to update one SeoData.
     * @example
     * // Update one SeoData
     * const seoData = await prisma.seoData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeoDataUpdateArgs>(args: SelectSubset<T, SeoDataUpdateArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SeoData.
     * @param {SeoDataDeleteManyArgs} args - Arguments to filter SeoData to delete.
     * @example
     * // Delete a few SeoData
     * const { count } = await prisma.seoData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeoDataDeleteManyArgs>(args?: SelectSubset<T, SeoDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeoData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeoData
     * const seoData = await prisma.seoData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeoDataUpdateManyArgs>(args: SelectSubset<T, SeoDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeoData.
     * @param {SeoDataUpsertArgs} args - Arguments to update or create a SeoData.
     * @example
     * // Update or create a SeoData
     * const seoData = await prisma.seoData.upsert({
     *   create: {
     *     // ... data to create a SeoData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeoData we want to update
     *   }
     * })
     */
    upsert<T extends SeoDataUpsertArgs>(args: SelectSubset<T, SeoDataUpsertArgs<ExtArgs>>): Prisma__SeoDataClient<$Result.GetResult<Prisma.$SeoDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SeoData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataCountArgs} args - Arguments to filter SeoData to count.
     * @example
     * // Count the number of SeoData
     * const count = await prisma.seoData.count({
     *   where: {
     *     // ... the filter for the SeoData we want to count
     *   }
     * })
    **/
    count<T extends SeoDataCountArgs>(
      args?: Subset<T, SeoDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeoDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeoData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeoDataAggregateArgs>(args: Subset<T, SeoDataAggregateArgs>): Prisma.PrismaPromise<GetSeoDataAggregateType<T>>

    /**
     * Group by SeoData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeoDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeoDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeoDataGroupByArgs['orderBy'] }
        : { orderBy?: SeoDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeoDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeoDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SeoData model
   */
  readonly fields: SeoDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SeoData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeoDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SeoData model
   */
  interface SeoDataFieldRefs {
    readonly id: FieldRef<"SeoData", 'String'>
    readonly pageType: FieldRef<"SeoData", 'String'>
    readonly pageSlug: FieldRef<"SeoData", 'String'>
    readonly title: FieldRef<"SeoData", 'String'>
    readonly description: FieldRef<"SeoData", 'String'>
    readonly keywords: FieldRef<"SeoData", 'String'>
    readonly canonicalUrl: FieldRef<"SeoData", 'String'>
    readonly ogImage: FieldRef<"SeoData", 'String'>
    readonly ogType: FieldRef<"SeoData", 'String'>
    readonly noIndex: FieldRef<"SeoData", 'Boolean'>
    readonly updatedAt: FieldRef<"SeoData", 'DateTime'>
    readonly createdAt: FieldRef<"SeoData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SeoData findUnique
   */
  export type SeoDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * Filter, which SeoData to fetch.
     */
    where: SeoDataWhereUniqueInput
  }

  /**
   * SeoData findUniqueOrThrow
   */
  export type SeoDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * Filter, which SeoData to fetch.
     */
    where: SeoDataWhereUniqueInput
  }

  /**
   * SeoData findFirst
   */
  export type SeoDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * Filter, which SeoData to fetch.
     */
    where?: SeoDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoData to fetch.
     */
    orderBy?: SeoDataOrderByWithRelationInput | SeoDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoData.
     */
    cursor?: SeoDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoData.
     */
    distinct?: SeoDataScalarFieldEnum | SeoDataScalarFieldEnum[]
  }

  /**
   * SeoData findFirstOrThrow
   */
  export type SeoDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * Filter, which SeoData to fetch.
     */
    where?: SeoDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoData to fetch.
     */
    orderBy?: SeoDataOrderByWithRelationInput | SeoDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeoData.
     */
    cursor?: SeoDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeoData.
     */
    distinct?: SeoDataScalarFieldEnum | SeoDataScalarFieldEnum[]
  }

  /**
   * SeoData findMany
   */
  export type SeoDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * Filter, which SeoData to fetch.
     */
    where?: SeoDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeoData to fetch.
     */
    orderBy?: SeoDataOrderByWithRelationInput | SeoDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeoData.
     */
    cursor?: SeoDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeoData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeoData.
     */
    skip?: number
    distinct?: SeoDataScalarFieldEnum | SeoDataScalarFieldEnum[]
  }

  /**
   * SeoData create
   */
  export type SeoDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * The data needed to create a SeoData.
     */
    data: XOR<SeoDataCreateInput, SeoDataUncheckedCreateInput>
  }

  /**
   * SeoData createMany
   */
  export type SeoDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SeoData.
     */
    data: SeoDataCreateManyInput | SeoDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SeoData update
   */
  export type SeoDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * The data needed to update a SeoData.
     */
    data: XOR<SeoDataUpdateInput, SeoDataUncheckedUpdateInput>
    /**
     * Choose, which SeoData to update.
     */
    where: SeoDataWhereUniqueInput
  }

  /**
   * SeoData updateMany
   */
  export type SeoDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SeoData.
     */
    data: XOR<SeoDataUpdateManyMutationInput, SeoDataUncheckedUpdateManyInput>
    /**
     * Filter which SeoData to update
     */
    where?: SeoDataWhereInput
    /**
     * Limit how many SeoData to update.
     */
    limit?: number
  }

  /**
   * SeoData upsert
   */
  export type SeoDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * The filter to search for the SeoData to update in case it exists.
     */
    where: SeoDataWhereUniqueInput
    /**
     * In case the SeoData found by the `where` argument doesn't exist, create a new SeoData with this data.
     */
    create: XOR<SeoDataCreateInput, SeoDataUncheckedCreateInput>
    /**
     * In case the SeoData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeoDataUpdateInput, SeoDataUncheckedUpdateInput>
  }

  /**
   * SeoData delete
   */
  export type SeoDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
    /**
     * Filter which SeoData to delete.
     */
    where: SeoDataWhereUniqueInput
  }

  /**
   * SeoData deleteMany
   */
  export type SeoDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SeoData to delete
     */
    where?: SeoDataWhereInput
    /**
     * Limit how many SeoData to delete.
     */
    limit?: number
  }

  /**
   * SeoData without action
   */
  export type SeoDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeoData
     */
    select?: SeoDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SeoData
     */
    omit?: SeoDataOmit<ExtArgs> | null
  }


  /**
   * Model SitemapLog
   */

  export type AggregateSitemapLog = {
    _count: SitemapLogCountAggregateOutputType | null
    _avg: SitemapLogAvgAggregateOutputType | null
    _sum: SitemapLogSumAggregateOutputType | null
    _min: SitemapLogMinAggregateOutputType | null
    _max: SitemapLogMaxAggregateOutputType | null
  }

  export type SitemapLogAvgAggregateOutputType = {
    totalPages: number | null
  }

  export type SitemapLogSumAggregateOutputType = {
    totalPages: number | null
  }

  export type SitemapLogMinAggregateOutputType = {
    id: string | null
    totalPages: number | null
    lastGenerated: Date | null
    googlePinged: boolean | null
    bingPinged: boolean | null
    createdAt: Date | null
  }

  export type SitemapLogMaxAggregateOutputType = {
    id: string | null
    totalPages: number | null
    lastGenerated: Date | null
    googlePinged: boolean | null
    bingPinged: boolean | null
    createdAt: Date | null
  }

  export type SitemapLogCountAggregateOutputType = {
    id: number
    totalPages: number
    lastGenerated: number
    googlePinged: number
    bingPinged: number
    createdAt: number
    _all: number
  }


  export type SitemapLogAvgAggregateInputType = {
    totalPages?: true
  }

  export type SitemapLogSumAggregateInputType = {
    totalPages?: true
  }

  export type SitemapLogMinAggregateInputType = {
    id?: true
    totalPages?: true
    lastGenerated?: true
    googlePinged?: true
    bingPinged?: true
    createdAt?: true
  }

  export type SitemapLogMaxAggregateInputType = {
    id?: true
    totalPages?: true
    lastGenerated?: true
    googlePinged?: true
    bingPinged?: true
    createdAt?: true
  }

  export type SitemapLogCountAggregateInputType = {
    id?: true
    totalPages?: true
    lastGenerated?: true
    googlePinged?: true
    bingPinged?: true
    createdAt?: true
    _all?: true
  }

  export type SitemapLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SitemapLog to aggregate.
     */
    where?: SitemapLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapLogs to fetch.
     */
    orderBy?: SitemapLogOrderByWithRelationInput | SitemapLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SitemapLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SitemapLogs
    **/
    _count?: true | SitemapLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SitemapLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SitemapLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SitemapLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SitemapLogMaxAggregateInputType
  }

  export type GetSitemapLogAggregateType<T extends SitemapLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSitemapLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSitemapLog[P]>
      : GetScalarType<T[P], AggregateSitemapLog[P]>
  }




  export type SitemapLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SitemapLogWhereInput
    orderBy?: SitemapLogOrderByWithAggregationInput | SitemapLogOrderByWithAggregationInput[]
    by: SitemapLogScalarFieldEnum[] | SitemapLogScalarFieldEnum
    having?: SitemapLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SitemapLogCountAggregateInputType | true
    _avg?: SitemapLogAvgAggregateInputType
    _sum?: SitemapLogSumAggregateInputType
    _min?: SitemapLogMinAggregateInputType
    _max?: SitemapLogMaxAggregateInputType
  }

  export type SitemapLogGroupByOutputType = {
    id: string
    totalPages: number
    lastGenerated: Date
    googlePinged: boolean
    bingPinged: boolean
    createdAt: Date
    _count: SitemapLogCountAggregateOutputType | null
    _avg: SitemapLogAvgAggregateOutputType | null
    _sum: SitemapLogSumAggregateOutputType | null
    _min: SitemapLogMinAggregateOutputType | null
    _max: SitemapLogMaxAggregateOutputType | null
  }

  type GetSitemapLogGroupByPayload<T extends SitemapLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SitemapLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SitemapLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SitemapLogGroupByOutputType[P]>
            : GetScalarType<T[P], SitemapLogGroupByOutputType[P]>
        }
      >
    >


  export type SitemapLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalPages?: boolean
    lastGenerated?: boolean
    googlePinged?: boolean
    bingPinged?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sitemapLog"]>



  export type SitemapLogSelectScalar = {
    id?: boolean
    totalPages?: boolean
    lastGenerated?: boolean
    googlePinged?: boolean
    bingPinged?: boolean
    createdAt?: boolean
  }

  export type SitemapLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalPages" | "lastGenerated" | "googlePinged" | "bingPinged" | "createdAt", ExtArgs["result"]["sitemapLog"]>

  export type $SitemapLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SitemapLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      totalPages: number
      lastGenerated: Date
      googlePinged: boolean
      bingPinged: boolean
      createdAt: Date
    }, ExtArgs["result"]["sitemapLog"]>
    composites: {}
  }

  type SitemapLogGetPayload<S extends boolean | null | undefined | SitemapLogDefaultArgs> = $Result.GetResult<Prisma.$SitemapLogPayload, S>

  type SitemapLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SitemapLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SitemapLogCountAggregateInputType | true
    }

  export interface SitemapLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SitemapLog'], meta: { name: 'SitemapLog' } }
    /**
     * Find zero or one SitemapLog that matches the filter.
     * @param {SitemapLogFindUniqueArgs} args - Arguments to find a SitemapLog
     * @example
     * // Get one SitemapLog
     * const sitemapLog = await prisma.sitemapLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SitemapLogFindUniqueArgs>(args: SelectSubset<T, SitemapLogFindUniqueArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SitemapLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SitemapLogFindUniqueOrThrowArgs} args - Arguments to find a SitemapLog
     * @example
     * // Get one SitemapLog
     * const sitemapLog = await prisma.sitemapLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SitemapLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SitemapLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SitemapLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogFindFirstArgs} args - Arguments to find a SitemapLog
     * @example
     * // Get one SitemapLog
     * const sitemapLog = await prisma.sitemapLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SitemapLogFindFirstArgs>(args?: SelectSubset<T, SitemapLogFindFirstArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SitemapLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogFindFirstOrThrowArgs} args - Arguments to find a SitemapLog
     * @example
     * // Get one SitemapLog
     * const sitemapLog = await prisma.sitemapLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SitemapLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SitemapLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SitemapLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SitemapLogs
     * const sitemapLogs = await prisma.sitemapLog.findMany()
     * 
     * // Get first 10 SitemapLogs
     * const sitemapLogs = await prisma.sitemapLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sitemapLogWithIdOnly = await prisma.sitemapLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SitemapLogFindManyArgs>(args?: SelectSubset<T, SitemapLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SitemapLog.
     * @param {SitemapLogCreateArgs} args - Arguments to create a SitemapLog.
     * @example
     * // Create one SitemapLog
     * const SitemapLog = await prisma.sitemapLog.create({
     *   data: {
     *     // ... data to create a SitemapLog
     *   }
     * })
     * 
     */
    create<T extends SitemapLogCreateArgs>(args: SelectSubset<T, SitemapLogCreateArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SitemapLogs.
     * @param {SitemapLogCreateManyArgs} args - Arguments to create many SitemapLogs.
     * @example
     * // Create many SitemapLogs
     * const sitemapLog = await prisma.sitemapLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SitemapLogCreateManyArgs>(args?: SelectSubset<T, SitemapLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SitemapLog.
     * @param {SitemapLogDeleteArgs} args - Arguments to delete one SitemapLog.
     * @example
     * // Delete one SitemapLog
     * const SitemapLog = await prisma.sitemapLog.delete({
     *   where: {
     *     // ... filter to delete one SitemapLog
     *   }
     * })
     * 
     */
    delete<T extends SitemapLogDeleteArgs>(args: SelectSubset<T, SitemapLogDeleteArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SitemapLog.
     * @param {SitemapLogUpdateArgs} args - Arguments to update one SitemapLog.
     * @example
     * // Update one SitemapLog
     * const sitemapLog = await prisma.sitemapLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SitemapLogUpdateArgs>(args: SelectSubset<T, SitemapLogUpdateArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SitemapLogs.
     * @param {SitemapLogDeleteManyArgs} args - Arguments to filter SitemapLogs to delete.
     * @example
     * // Delete a few SitemapLogs
     * const { count } = await prisma.sitemapLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SitemapLogDeleteManyArgs>(args?: SelectSubset<T, SitemapLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SitemapLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SitemapLogs
     * const sitemapLog = await prisma.sitemapLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SitemapLogUpdateManyArgs>(args: SelectSubset<T, SitemapLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SitemapLog.
     * @param {SitemapLogUpsertArgs} args - Arguments to update or create a SitemapLog.
     * @example
     * // Update or create a SitemapLog
     * const sitemapLog = await prisma.sitemapLog.upsert({
     *   create: {
     *     // ... data to create a SitemapLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SitemapLog we want to update
     *   }
     * })
     */
    upsert<T extends SitemapLogUpsertArgs>(args: SelectSubset<T, SitemapLogUpsertArgs<ExtArgs>>): Prisma__SitemapLogClient<$Result.GetResult<Prisma.$SitemapLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SitemapLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogCountArgs} args - Arguments to filter SitemapLogs to count.
     * @example
     * // Count the number of SitemapLogs
     * const count = await prisma.sitemapLog.count({
     *   where: {
     *     // ... the filter for the SitemapLogs we want to count
     *   }
     * })
    **/
    count<T extends SitemapLogCountArgs>(
      args?: Subset<T, SitemapLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SitemapLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SitemapLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SitemapLogAggregateArgs>(args: Subset<T, SitemapLogAggregateArgs>): Prisma.PrismaPromise<GetSitemapLogAggregateType<T>>

    /**
     * Group by SitemapLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SitemapLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SitemapLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SitemapLogGroupByArgs['orderBy'] }
        : { orderBy?: SitemapLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SitemapLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSitemapLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SitemapLog model
   */
  readonly fields: SitemapLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SitemapLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SitemapLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SitemapLog model
   */
  interface SitemapLogFieldRefs {
    readonly id: FieldRef<"SitemapLog", 'String'>
    readonly totalPages: FieldRef<"SitemapLog", 'Int'>
    readonly lastGenerated: FieldRef<"SitemapLog", 'DateTime'>
    readonly googlePinged: FieldRef<"SitemapLog", 'Boolean'>
    readonly bingPinged: FieldRef<"SitemapLog", 'Boolean'>
    readonly createdAt: FieldRef<"SitemapLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SitemapLog findUnique
   */
  export type SitemapLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * Filter, which SitemapLog to fetch.
     */
    where: SitemapLogWhereUniqueInput
  }

  /**
   * SitemapLog findUniqueOrThrow
   */
  export type SitemapLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * Filter, which SitemapLog to fetch.
     */
    where: SitemapLogWhereUniqueInput
  }

  /**
   * SitemapLog findFirst
   */
  export type SitemapLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * Filter, which SitemapLog to fetch.
     */
    where?: SitemapLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapLogs to fetch.
     */
    orderBy?: SitemapLogOrderByWithRelationInput | SitemapLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SitemapLogs.
     */
    cursor?: SitemapLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SitemapLogs.
     */
    distinct?: SitemapLogScalarFieldEnum | SitemapLogScalarFieldEnum[]
  }

  /**
   * SitemapLog findFirstOrThrow
   */
  export type SitemapLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * Filter, which SitemapLog to fetch.
     */
    where?: SitemapLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapLogs to fetch.
     */
    orderBy?: SitemapLogOrderByWithRelationInput | SitemapLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SitemapLogs.
     */
    cursor?: SitemapLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SitemapLogs.
     */
    distinct?: SitemapLogScalarFieldEnum | SitemapLogScalarFieldEnum[]
  }

  /**
   * SitemapLog findMany
   */
  export type SitemapLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * Filter, which SitemapLogs to fetch.
     */
    where?: SitemapLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SitemapLogs to fetch.
     */
    orderBy?: SitemapLogOrderByWithRelationInput | SitemapLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SitemapLogs.
     */
    cursor?: SitemapLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SitemapLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SitemapLogs.
     */
    skip?: number
    distinct?: SitemapLogScalarFieldEnum | SitemapLogScalarFieldEnum[]
  }

  /**
   * SitemapLog create
   */
  export type SitemapLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SitemapLog.
     */
    data: XOR<SitemapLogCreateInput, SitemapLogUncheckedCreateInput>
  }

  /**
   * SitemapLog createMany
   */
  export type SitemapLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SitemapLogs.
     */
    data: SitemapLogCreateManyInput | SitemapLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SitemapLog update
   */
  export type SitemapLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SitemapLog.
     */
    data: XOR<SitemapLogUpdateInput, SitemapLogUncheckedUpdateInput>
    /**
     * Choose, which SitemapLog to update.
     */
    where: SitemapLogWhereUniqueInput
  }

  /**
   * SitemapLog updateMany
   */
  export type SitemapLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SitemapLogs.
     */
    data: XOR<SitemapLogUpdateManyMutationInput, SitemapLogUncheckedUpdateManyInput>
    /**
     * Filter which SitemapLogs to update
     */
    where?: SitemapLogWhereInput
    /**
     * Limit how many SitemapLogs to update.
     */
    limit?: number
  }

  /**
   * SitemapLog upsert
   */
  export type SitemapLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SitemapLog to update in case it exists.
     */
    where: SitemapLogWhereUniqueInput
    /**
     * In case the SitemapLog found by the `where` argument doesn't exist, create a new SitemapLog with this data.
     */
    create: XOR<SitemapLogCreateInput, SitemapLogUncheckedCreateInput>
    /**
     * In case the SitemapLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SitemapLogUpdateInput, SitemapLogUncheckedUpdateInput>
  }

  /**
   * SitemapLog delete
   */
  export type SitemapLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
    /**
     * Filter which SitemapLog to delete.
     */
    where: SitemapLogWhereUniqueInput
  }

  /**
   * SitemapLog deleteMany
   */
  export type SitemapLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SitemapLogs to delete
     */
    where?: SitemapLogWhereInput
    /**
     * Limit how many SitemapLogs to delete.
     */
    limit?: number
  }

  /**
   * SitemapLog without action
   */
  export type SitemapLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SitemapLog
     */
    select?: SitemapLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SitemapLog
     */
    omit?: SitemapLogOmit<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    adults: number | null
    children: number | null
    infants: number | null
    totalPrice: number | null
  }

  export type BookingSumAggregateOutputType = {
    adults: number | null
    children: number | null
    infants: number | null
    totalPrice: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    packageId: string | null
    packageName: string | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    adults: number | null
    children: number | null
    infants: number | null
    totalPrice: number | null
    status: string | null
    paymentStatus: string | null
    specialRequests: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    packageId: string | null
    packageName: string | null
    customerName: string | null
    customerEmail: string | null
    customerPhone: string | null
    checkInDate: Date | null
    checkOutDate: Date | null
    adults: number | null
    children: number | null
    infants: number | null
    totalPrice: number | null
    status: string | null
    paymentStatus: string | null
    specialRequests: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    packageId: number
    packageName: number
    customerName: number
    customerEmail: number
    customerPhone: number
    checkInDate: number
    checkOutDate: number
    adults: number
    children: number
    infants: number
    totalPrice: number
    status: number
    paymentStatus: number
    specialRequests: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    adults?: true
    children?: true
    infants?: true
    totalPrice?: true
  }

  export type BookingSumAggregateInputType = {
    adults?: true
    children?: true
    infants?: true
    totalPrice?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    packageId?: true
    packageName?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    checkInDate?: true
    checkOutDate?: true
    adults?: true
    children?: true
    infants?: true
    totalPrice?: true
    status?: true
    paymentStatus?: true
    specialRequests?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    packageId?: true
    packageName?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    checkInDate?: true
    checkOutDate?: true
    adults?: true
    children?: true
    infants?: true
    totalPrice?: true
    status?: true
    paymentStatus?: true
    specialRequests?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    packageId?: true
    packageName?: true
    customerName?: true
    customerEmail?: true
    customerPhone?: true
    checkInDate?: true
    checkOutDate?: true
    adults?: true
    children?: true
    infants?: true
    totalPrice?: true
    status?: true
    paymentStatus?: true
    specialRequests?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    packageId: string
    packageName: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkInDate: Date
    checkOutDate: Date
    adults: number
    children: number
    infants: number
    totalPrice: number
    status: string
    paymentStatus: string
    specialRequests: string | null
    updatedAt: Date
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    packageName?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    adults?: boolean
    children?: boolean
    infants?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    specialRequests?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["booking"]>



  export type BookingSelectScalar = {
    id?: boolean
    packageId?: boolean
    packageName?: boolean
    customerName?: boolean
    customerEmail?: boolean
    customerPhone?: boolean
    checkInDate?: boolean
    checkOutDate?: boolean
    adults?: boolean
    children?: boolean
    infants?: boolean
    totalPrice?: boolean
    status?: boolean
    paymentStatus?: boolean
    specialRequests?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "packageId" | "packageName" | "customerName" | "customerEmail" | "customerPhone" | "checkInDate" | "checkOutDate" | "adults" | "children" | "infants" | "totalPrice" | "status" | "paymentStatus" | "specialRequests" | "updatedAt" | "createdAt", ExtArgs["result"]["booking"]>

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      packageId: string
      packageName: string
      customerName: string
      customerEmail: string
      customerPhone: string
      checkInDate: Date
      checkOutDate: Date
      adults: number
      children: number
      infants: number
      totalPrice: number
      status: string
      paymentStatus: string
      specialRequests: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly packageId: FieldRef<"Booking", 'String'>
    readonly packageName: FieldRef<"Booking", 'String'>
    readonly customerName: FieldRef<"Booking", 'String'>
    readonly customerEmail: FieldRef<"Booking", 'String'>
    readonly customerPhone: FieldRef<"Booking", 'String'>
    readonly checkInDate: FieldRef<"Booking", 'DateTime'>
    readonly checkOutDate: FieldRef<"Booking", 'DateTime'>
    readonly adults: FieldRef<"Booking", 'Int'>
    readonly children: FieldRef<"Booking", 'Int'>
    readonly infants: FieldRef<"Booking", 'Int'>
    readonly totalPrice: FieldRef<"Booking", 'Float'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly paymentStatus: FieldRef<"Booking", 'String'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
  }


  /**
   * Model NavigationMenu
   */

  export type AggregateNavigationMenu = {
    _count: NavigationMenuCountAggregateOutputType | null
    _min: NavigationMenuMinAggregateOutputType | null
    _max: NavigationMenuMaxAggregateOutputType | null
  }

  export type NavigationMenuMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavigationMenuMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavigationMenuCountAggregateOutputType = {
    id: number
    name: number
    location: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NavigationMenuMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavigationMenuMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavigationMenuCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NavigationMenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigationMenu to aggregate.
     */
    where?: NavigationMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationMenus to fetch.
     */
    orderBy?: NavigationMenuOrderByWithRelationInput | NavigationMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavigationMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavigationMenus
    **/
    _count?: true | NavigationMenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavigationMenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavigationMenuMaxAggregateInputType
  }

  export type GetNavigationMenuAggregateType<T extends NavigationMenuAggregateArgs> = {
        [P in keyof T & keyof AggregateNavigationMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavigationMenu[P]>
      : GetScalarType<T[P], AggregateNavigationMenu[P]>
  }




  export type NavigationMenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigationMenuWhereInput
    orderBy?: NavigationMenuOrderByWithAggregationInput | NavigationMenuOrderByWithAggregationInput[]
    by: NavigationMenuScalarFieldEnum[] | NavigationMenuScalarFieldEnum
    having?: NavigationMenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavigationMenuCountAggregateInputType | true
    _min?: NavigationMenuMinAggregateInputType
    _max?: NavigationMenuMaxAggregateInputType
  }

  export type NavigationMenuGroupByOutputType = {
    id: string
    name: string
    location: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: NavigationMenuCountAggregateOutputType | null
    _min: NavigationMenuMinAggregateOutputType | null
    _max: NavigationMenuMaxAggregateOutputType | null
  }

  type GetNavigationMenuGroupByPayload<T extends NavigationMenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavigationMenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavigationMenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavigationMenuGroupByOutputType[P]>
            : GetScalarType<T[P], NavigationMenuGroupByOutputType[P]>
        }
      >
    >


  export type NavigationMenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | NavigationMenu$itemsArgs<ExtArgs>
    _count?: boolean | NavigationMenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["navigationMenu"]>



  export type NavigationMenuSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NavigationMenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["navigationMenu"]>
  export type NavigationMenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | NavigationMenu$itemsArgs<ExtArgs>
    _count?: boolean | NavigationMenuCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NavigationMenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NavigationMenu"
    objects: {
      items: Prisma.$NavigationItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      location: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["navigationMenu"]>
    composites: {}
  }

  type NavigationMenuGetPayload<S extends boolean | null | undefined | NavigationMenuDefaultArgs> = $Result.GetResult<Prisma.$NavigationMenuPayload, S>

  type NavigationMenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NavigationMenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NavigationMenuCountAggregateInputType | true
    }

  export interface NavigationMenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavigationMenu'], meta: { name: 'NavigationMenu' } }
    /**
     * Find zero or one NavigationMenu that matches the filter.
     * @param {NavigationMenuFindUniqueArgs} args - Arguments to find a NavigationMenu
     * @example
     * // Get one NavigationMenu
     * const navigationMenu = await prisma.navigationMenu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NavigationMenuFindUniqueArgs>(args: SelectSubset<T, NavigationMenuFindUniqueArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NavigationMenu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NavigationMenuFindUniqueOrThrowArgs} args - Arguments to find a NavigationMenu
     * @example
     * // Get one NavigationMenu
     * const navigationMenu = await prisma.navigationMenu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NavigationMenuFindUniqueOrThrowArgs>(args: SelectSubset<T, NavigationMenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NavigationMenu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuFindFirstArgs} args - Arguments to find a NavigationMenu
     * @example
     * // Get one NavigationMenu
     * const navigationMenu = await prisma.navigationMenu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NavigationMenuFindFirstArgs>(args?: SelectSubset<T, NavigationMenuFindFirstArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NavigationMenu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuFindFirstOrThrowArgs} args - Arguments to find a NavigationMenu
     * @example
     * // Get one NavigationMenu
     * const navigationMenu = await prisma.navigationMenu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NavigationMenuFindFirstOrThrowArgs>(args?: SelectSubset<T, NavigationMenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NavigationMenus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavigationMenus
     * const navigationMenus = await prisma.navigationMenu.findMany()
     * 
     * // Get first 10 NavigationMenus
     * const navigationMenus = await prisma.navigationMenu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const navigationMenuWithIdOnly = await prisma.navigationMenu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NavigationMenuFindManyArgs>(args?: SelectSubset<T, NavigationMenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NavigationMenu.
     * @param {NavigationMenuCreateArgs} args - Arguments to create a NavigationMenu.
     * @example
     * // Create one NavigationMenu
     * const NavigationMenu = await prisma.navigationMenu.create({
     *   data: {
     *     // ... data to create a NavigationMenu
     *   }
     * })
     * 
     */
    create<T extends NavigationMenuCreateArgs>(args: SelectSubset<T, NavigationMenuCreateArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NavigationMenus.
     * @param {NavigationMenuCreateManyArgs} args - Arguments to create many NavigationMenus.
     * @example
     * // Create many NavigationMenus
     * const navigationMenu = await prisma.navigationMenu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NavigationMenuCreateManyArgs>(args?: SelectSubset<T, NavigationMenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavigationMenu.
     * @param {NavigationMenuDeleteArgs} args - Arguments to delete one NavigationMenu.
     * @example
     * // Delete one NavigationMenu
     * const NavigationMenu = await prisma.navigationMenu.delete({
     *   where: {
     *     // ... filter to delete one NavigationMenu
     *   }
     * })
     * 
     */
    delete<T extends NavigationMenuDeleteArgs>(args: SelectSubset<T, NavigationMenuDeleteArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NavigationMenu.
     * @param {NavigationMenuUpdateArgs} args - Arguments to update one NavigationMenu.
     * @example
     * // Update one NavigationMenu
     * const navigationMenu = await prisma.navigationMenu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NavigationMenuUpdateArgs>(args: SelectSubset<T, NavigationMenuUpdateArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NavigationMenus.
     * @param {NavigationMenuDeleteManyArgs} args - Arguments to filter NavigationMenus to delete.
     * @example
     * // Delete a few NavigationMenus
     * const { count } = await prisma.navigationMenu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NavigationMenuDeleteManyArgs>(args?: SelectSubset<T, NavigationMenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavigationMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavigationMenus
     * const navigationMenu = await prisma.navigationMenu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NavigationMenuUpdateManyArgs>(args: SelectSubset<T, NavigationMenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavigationMenu.
     * @param {NavigationMenuUpsertArgs} args - Arguments to update or create a NavigationMenu.
     * @example
     * // Update or create a NavigationMenu
     * const navigationMenu = await prisma.navigationMenu.upsert({
     *   create: {
     *     // ... data to create a NavigationMenu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavigationMenu we want to update
     *   }
     * })
     */
    upsert<T extends NavigationMenuUpsertArgs>(args: SelectSubset<T, NavigationMenuUpsertArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NavigationMenus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuCountArgs} args - Arguments to filter NavigationMenus to count.
     * @example
     * // Count the number of NavigationMenus
     * const count = await prisma.navigationMenu.count({
     *   where: {
     *     // ... the filter for the NavigationMenus we want to count
     *   }
     * })
    **/
    count<T extends NavigationMenuCountArgs>(
      args?: Subset<T, NavigationMenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavigationMenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavigationMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavigationMenuAggregateArgs>(args: Subset<T, NavigationMenuAggregateArgs>): Prisma.PrismaPromise<GetNavigationMenuAggregateType<T>>

    /**
     * Group by NavigationMenu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationMenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavigationMenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavigationMenuGroupByArgs['orderBy'] }
        : { orderBy?: NavigationMenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavigationMenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavigationMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavigationMenu model
   */
  readonly fields: NavigationMenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavigationMenu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavigationMenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends NavigationMenu$itemsArgs<ExtArgs> = {}>(args?: Subset<T, NavigationMenu$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NavigationMenu model
   */
  interface NavigationMenuFieldRefs {
    readonly id: FieldRef<"NavigationMenu", 'String'>
    readonly name: FieldRef<"NavigationMenu", 'String'>
    readonly location: FieldRef<"NavigationMenu", 'String'>
    readonly isActive: FieldRef<"NavigationMenu", 'Boolean'>
    readonly createdAt: FieldRef<"NavigationMenu", 'DateTime'>
    readonly updatedAt: FieldRef<"NavigationMenu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NavigationMenu findUnique
   */
  export type NavigationMenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * Filter, which NavigationMenu to fetch.
     */
    where: NavigationMenuWhereUniqueInput
  }

  /**
   * NavigationMenu findUniqueOrThrow
   */
  export type NavigationMenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * Filter, which NavigationMenu to fetch.
     */
    where: NavigationMenuWhereUniqueInput
  }

  /**
   * NavigationMenu findFirst
   */
  export type NavigationMenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * Filter, which NavigationMenu to fetch.
     */
    where?: NavigationMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationMenus to fetch.
     */
    orderBy?: NavigationMenuOrderByWithRelationInput | NavigationMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigationMenus.
     */
    cursor?: NavigationMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigationMenus.
     */
    distinct?: NavigationMenuScalarFieldEnum | NavigationMenuScalarFieldEnum[]
  }

  /**
   * NavigationMenu findFirstOrThrow
   */
  export type NavigationMenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * Filter, which NavigationMenu to fetch.
     */
    where?: NavigationMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationMenus to fetch.
     */
    orderBy?: NavigationMenuOrderByWithRelationInput | NavigationMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigationMenus.
     */
    cursor?: NavigationMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationMenus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigationMenus.
     */
    distinct?: NavigationMenuScalarFieldEnum | NavigationMenuScalarFieldEnum[]
  }

  /**
   * NavigationMenu findMany
   */
  export type NavigationMenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * Filter, which NavigationMenus to fetch.
     */
    where?: NavigationMenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationMenus to fetch.
     */
    orderBy?: NavigationMenuOrderByWithRelationInput | NavigationMenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavigationMenus.
     */
    cursor?: NavigationMenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationMenus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationMenus.
     */
    skip?: number
    distinct?: NavigationMenuScalarFieldEnum | NavigationMenuScalarFieldEnum[]
  }

  /**
   * NavigationMenu create
   */
  export type NavigationMenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * The data needed to create a NavigationMenu.
     */
    data: XOR<NavigationMenuCreateInput, NavigationMenuUncheckedCreateInput>
  }

  /**
   * NavigationMenu createMany
   */
  export type NavigationMenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavigationMenus.
     */
    data: NavigationMenuCreateManyInput | NavigationMenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NavigationMenu update
   */
  export type NavigationMenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * The data needed to update a NavigationMenu.
     */
    data: XOR<NavigationMenuUpdateInput, NavigationMenuUncheckedUpdateInput>
    /**
     * Choose, which NavigationMenu to update.
     */
    where: NavigationMenuWhereUniqueInput
  }

  /**
   * NavigationMenu updateMany
   */
  export type NavigationMenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavigationMenus.
     */
    data: XOR<NavigationMenuUpdateManyMutationInput, NavigationMenuUncheckedUpdateManyInput>
    /**
     * Filter which NavigationMenus to update
     */
    where?: NavigationMenuWhereInput
    /**
     * Limit how many NavigationMenus to update.
     */
    limit?: number
  }

  /**
   * NavigationMenu upsert
   */
  export type NavigationMenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * The filter to search for the NavigationMenu to update in case it exists.
     */
    where: NavigationMenuWhereUniqueInput
    /**
     * In case the NavigationMenu found by the `where` argument doesn't exist, create a new NavigationMenu with this data.
     */
    create: XOR<NavigationMenuCreateInput, NavigationMenuUncheckedCreateInput>
    /**
     * In case the NavigationMenu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavigationMenuUpdateInput, NavigationMenuUncheckedUpdateInput>
  }

  /**
   * NavigationMenu delete
   */
  export type NavigationMenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
    /**
     * Filter which NavigationMenu to delete.
     */
    where: NavigationMenuWhereUniqueInput
  }

  /**
   * NavigationMenu deleteMany
   */
  export type NavigationMenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigationMenus to delete
     */
    where?: NavigationMenuWhereInput
    /**
     * Limit how many NavigationMenus to delete.
     */
    limit?: number
  }

  /**
   * NavigationMenu.items
   */
  export type NavigationMenu$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    where?: NavigationItemWhereInput
    orderBy?: NavigationItemOrderByWithRelationInput | NavigationItemOrderByWithRelationInput[]
    cursor?: NavigationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NavigationItemScalarFieldEnum | NavigationItemScalarFieldEnum[]
  }

  /**
   * NavigationMenu without action
   */
  export type NavigationMenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationMenu
     */
    select?: NavigationMenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationMenu
     */
    omit?: NavigationMenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationMenuInclude<ExtArgs> | null
  }


  /**
   * Model NavigationItem
   */

  export type AggregateNavigationItem = {
    _count: NavigationItemCountAggregateOutputType | null
    _avg: NavigationItemAvgAggregateOutputType | null
    _sum: NavigationItemSumAggregateOutputType | null
    _min: NavigationItemMinAggregateOutputType | null
    _max: NavigationItemMaxAggregateOutputType | null
  }

  export type NavigationItemAvgAggregateOutputType = {
    order: number | null
  }

  export type NavigationItemSumAggregateOutputType = {
    order: number | null
  }

  export type NavigationItemMinAggregateOutputType = {
    id: string | null
    menuId: string | null
    parentId: string | null
    order: number | null
    isActive: boolean | null
    isExternal: boolean | null
    target: string | null
    iconType: string | null
    iconName: string | null
    iconUrl: string | null
    backgroundColor: string | null
    textColor: string | null
    hoverColor: string | null
    activeColor: string | null
    fontFamily: string | null
    fontSize: string | null
    fontWeight: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavigationItemMaxAggregateOutputType = {
    id: string | null
    menuId: string | null
    parentId: string | null
    order: number | null
    isActive: boolean | null
    isExternal: boolean | null
    target: string | null
    iconType: string | null
    iconName: string | null
    iconUrl: string | null
    backgroundColor: string | null
    textColor: string | null
    hoverColor: string | null
    activeColor: string | null
    fontFamily: string | null
    fontSize: string | null
    fontWeight: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NavigationItemCountAggregateOutputType = {
    id: number
    menuId: number
    parentId: number
    order: number
    isActive: number
    isExternal: number
    target: number
    iconType: number
    iconName: number
    iconUrl: number
    backgroundColor: number
    textColor: number
    hoverColor: number
    activeColor: number
    fontFamily: number
    fontSize: number
    fontWeight: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NavigationItemAvgAggregateInputType = {
    order?: true
  }

  export type NavigationItemSumAggregateInputType = {
    order?: true
  }

  export type NavigationItemMinAggregateInputType = {
    id?: true
    menuId?: true
    parentId?: true
    order?: true
    isActive?: true
    isExternal?: true
    target?: true
    iconType?: true
    iconName?: true
    iconUrl?: true
    backgroundColor?: true
    textColor?: true
    hoverColor?: true
    activeColor?: true
    fontFamily?: true
    fontSize?: true
    fontWeight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavigationItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    parentId?: true
    order?: true
    isActive?: true
    isExternal?: true
    target?: true
    iconType?: true
    iconName?: true
    iconUrl?: true
    backgroundColor?: true
    textColor?: true
    hoverColor?: true
    activeColor?: true
    fontFamily?: true
    fontSize?: true
    fontWeight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NavigationItemCountAggregateInputType = {
    id?: true
    menuId?: true
    parentId?: true
    order?: true
    isActive?: true
    isExternal?: true
    target?: true
    iconType?: true
    iconName?: true
    iconUrl?: true
    backgroundColor?: true
    textColor?: true
    hoverColor?: true
    activeColor?: true
    fontFamily?: true
    fontSize?: true
    fontWeight?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NavigationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigationItem to aggregate.
     */
    where?: NavigationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItems to fetch.
     */
    orderBy?: NavigationItemOrderByWithRelationInput | NavigationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavigationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavigationItems
    **/
    _count?: true | NavigationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NavigationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NavigationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavigationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavigationItemMaxAggregateInputType
  }

  export type GetNavigationItemAggregateType<T extends NavigationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateNavigationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavigationItem[P]>
      : GetScalarType<T[P], AggregateNavigationItem[P]>
  }




  export type NavigationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigationItemWhereInput
    orderBy?: NavigationItemOrderByWithAggregationInput | NavigationItemOrderByWithAggregationInput[]
    by: NavigationItemScalarFieldEnum[] | NavigationItemScalarFieldEnum
    having?: NavigationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavigationItemCountAggregateInputType | true
    _avg?: NavigationItemAvgAggregateInputType
    _sum?: NavigationItemSumAggregateInputType
    _min?: NavigationItemMinAggregateInputType
    _max?: NavigationItemMaxAggregateInputType
  }

  export type NavigationItemGroupByOutputType = {
    id: string
    menuId: string
    parentId: string | null
    order: number
    isActive: boolean
    isExternal: boolean
    target: string
    iconType: string
    iconName: string | null
    iconUrl: string | null
    backgroundColor: string | null
    textColor: string | null
    hoverColor: string | null
    activeColor: string | null
    fontFamily: string | null
    fontSize: string | null
    fontWeight: string | null
    createdAt: Date
    updatedAt: Date
    _count: NavigationItemCountAggregateOutputType | null
    _avg: NavigationItemAvgAggregateOutputType | null
    _sum: NavigationItemSumAggregateOutputType | null
    _min: NavigationItemMinAggregateOutputType | null
    _max: NavigationItemMaxAggregateOutputType | null
  }

  type GetNavigationItemGroupByPayload<T extends NavigationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavigationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavigationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavigationItemGroupByOutputType[P]>
            : GetScalarType<T[P], NavigationItemGroupByOutputType[P]>
        }
      >
    >


  export type NavigationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    parentId?: boolean
    order?: boolean
    isActive?: boolean
    isExternal?: boolean
    target?: boolean
    iconType?: boolean
    iconName?: boolean
    iconUrl?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    hoverColor?: boolean
    activeColor?: boolean
    fontFamily?: boolean
    fontSize?: boolean
    fontWeight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | NavigationItem$translationsArgs<ExtArgs>
    menu?: boolean | NavigationMenuDefaultArgs<ExtArgs>
    parent?: boolean | NavigationItem$parentArgs<ExtArgs>
    children?: boolean | NavigationItem$childrenArgs<ExtArgs>
    _count?: boolean | NavigationItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["navigationItem"]>



  export type NavigationItemSelectScalar = {
    id?: boolean
    menuId?: boolean
    parentId?: boolean
    order?: boolean
    isActive?: boolean
    isExternal?: boolean
    target?: boolean
    iconType?: boolean
    iconName?: boolean
    iconUrl?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    hoverColor?: boolean
    activeColor?: boolean
    fontFamily?: boolean
    fontSize?: boolean
    fontWeight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NavigationItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuId" | "parentId" | "order" | "isActive" | "isExternal" | "target" | "iconType" | "iconName" | "iconUrl" | "backgroundColor" | "textColor" | "hoverColor" | "activeColor" | "fontFamily" | "fontSize" | "fontWeight" | "createdAt" | "updatedAt", ExtArgs["result"]["navigationItem"]>
  export type NavigationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | NavigationItem$translationsArgs<ExtArgs>
    menu?: boolean | NavigationMenuDefaultArgs<ExtArgs>
    parent?: boolean | NavigationItem$parentArgs<ExtArgs>
    children?: boolean | NavigationItem$childrenArgs<ExtArgs>
    _count?: boolean | NavigationItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NavigationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NavigationItem"
    objects: {
      translations: Prisma.$NavigationItemTranslationPayload<ExtArgs>[]
      menu: Prisma.$NavigationMenuPayload<ExtArgs>
      parent: Prisma.$NavigationItemPayload<ExtArgs> | null
      children: Prisma.$NavigationItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      menuId: string
      parentId: string | null
      order: number
      isActive: boolean
      isExternal: boolean
      target: string
      iconType: string
      iconName: string | null
      iconUrl: string | null
      backgroundColor: string | null
      textColor: string | null
      hoverColor: string | null
      activeColor: string | null
      fontFamily: string | null
      fontSize: string | null
      fontWeight: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["navigationItem"]>
    composites: {}
  }

  type NavigationItemGetPayload<S extends boolean | null | undefined | NavigationItemDefaultArgs> = $Result.GetResult<Prisma.$NavigationItemPayload, S>

  type NavigationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NavigationItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NavigationItemCountAggregateInputType | true
    }

  export interface NavigationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavigationItem'], meta: { name: 'NavigationItem' } }
    /**
     * Find zero or one NavigationItem that matches the filter.
     * @param {NavigationItemFindUniqueArgs} args - Arguments to find a NavigationItem
     * @example
     * // Get one NavigationItem
     * const navigationItem = await prisma.navigationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NavigationItemFindUniqueArgs>(args: SelectSubset<T, NavigationItemFindUniqueArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NavigationItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NavigationItemFindUniqueOrThrowArgs} args - Arguments to find a NavigationItem
     * @example
     * // Get one NavigationItem
     * const navigationItem = await prisma.navigationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NavigationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, NavigationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NavigationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemFindFirstArgs} args - Arguments to find a NavigationItem
     * @example
     * // Get one NavigationItem
     * const navigationItem = await prisma.navigationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NavigationItemFindFirstArgs>(args?: SelectSubset<T, NavigationItemFindFirstArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NavigationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemFindFirstOrThrowArgs} args - Arguments to find a NavigationItem
     * @example
     * // Get one NavigationItem
     * const navigationItem = await prisma.navigationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NavigationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, NavigationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NavigationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavigationItems
     * const navigationItems = await prisma.navigationItem.findMany()
     * 
     * // Get first 10 NavigationItems
     * const navigationItems = await prisma.navigationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const navigationItemWithIdOnly = await prisma.navigationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NavigationItemFindManyArgs>(args?: SelectSubset<T, NavigationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NavigationItem.
     * @param {NavigationItemCreateArgs} args - Arguments to create a NavigationItem.
     * @example
     * // Create one NavigationItem
     * const NavigationItem = await prisma.navigationItem.create({
     *   data: {
     *     // ... data to create a NavigationItem
     *   }
     * })
     * 
     */
    create<T extends NavigationItemCreateArgs>(args: SelectSubset<T, NavigationItemCreateArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NavigationItems.
     * @param {NavigationItemCreateManyArgs} args - Arguments to create many NavigationItems.
     * @example
     * // Create many NavigationItems
     * const navigationItem = await prisma.navigationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NavigationItemCreateManyArgs>(args?: SelectSubset<T, NavigationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavigationItem.
     * @param {NavigationItemDeleteArgs} args - Arguments to delete one NavigationItem.
     * @example
     * // Delete one NavigationItem
     * const NavigationItem = await prisma.navigationItem.delete({
     *   where: {
     *     // ... filter to delete one NavigationItem
     *   }
     * })
     * 
     */
    delete<T extends NavigationItemDeleteArgs>(args: SelectSubset<T, NavigationItemDeleteArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NavigationItem.
     * @param {NavigationItemUpdateArgs} args - Arguments to update one NavigationItem.
     * @example
     * // Update one NavigationItem
     * const navigationItem = await prisma.navigationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NavigationItemUpdateArgs>(args: SelectSubset<T, NavigationItemUpdateArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NavigationItems.
     * @param {NavigationItemDeleteManyArgs} args - Arguments to filter NavigationItems to delete.
     * @example
     * // Delete a few NavigationItems
     * const { count } = await prisma.navigationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NavigationItemDeleteManyArgs>(args?: SelectSubset<T, NavigationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavigationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavigationItems
     * const navigationItem = await prisma.navigationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NavigationItemUpdateManyArgs>(args: SelectSubset<T, NavigationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavigationItem.
     * @param {NavigationItemUpsertArgs} args - Arguments to update or create a NavigationItem.
     * @example
     * // Update or create a NavigationItem
     * const navigationItem = await prisma.navigationItem.upsert({
     *   create: {
     *     // ... data to create a NavigationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavigationItem we want to update
     *   }
     * })
     */
    upsert<T extends NavigationItemUpsertArgs>(args: SelectSubset<T, NavigationItemUpsertArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NavigationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemCountArgs} args - Arguments to filter NavigationItems to count.
     * @example
     * // Count the number of NavigationItems
     * const count = await prisma.navigationItem.count({
     *   where: {
     *     // ... the filter for the NavigationItems we want to count
     *   }
     * })
    **/
    count<T extends NavigationItemCountArgs>(
      args?: Subset<T, NavigationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavigationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavigationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavigationItemAggregateArgs>(args: Subset<T, NavigationItemAggregateArgs>): Prisma.PrismaPromise<GetNavigationItemAggregateType<T>>

    /**
     * Group by NavigationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavigationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavigationItemGroupByArgs['orderBy'] }
        : { orderBy?: NavigationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavigationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavigationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavigationItem model
   */
  readonly fields: NavigationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavigationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavigationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends NavigationItem$translationsArgs<ExtArgs> = {}>(args?: Subset<T, NavigationItem$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menu<T extends NavigationMenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NavigationMenuDefaultArgs<ExtArgs>>): Prisma__NavigationMenuClient<$Result.GetResult<Prisma.$NavigationMenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends NavigationItem$parentArgs<ExtArgs> = {}>(args?: Subset<T, NavigationItem$parentArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends NavigationItem$childrenArgs<ExtArgs> = {}>(args?: Subset<T, NavigationItem$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NavigationItem model
   */
  interface NavigationItemFieldRefs {
    readonly id: FieldRef<"NavigationItem", 'String'>
    readonly menuId: FieldRef<"NavigationItem", 'String'>
    readonly parentId: FieldRef<"NavigationItem", 'String'>
    readonly order: FieldRef<"NavigationItem", 'Int'>
    readonly isActive: FieldRef<"NavigationItem", 'Boolean'>
    readonly isExternal: FieldRef<"NavigationItem", 'Boolean'>
    readonly target: FieldRef<"NavigationItem", 'String'>
    readonly iconType: FieldRef<"NavigationItem", 'String'>
    readonly iconName: FieldRef<"NavigationItem", 'String'>
    readonly iconUrl: FieldRef<"NavigationItem", 'String'>
    readonly backgroundColor: FieldRef<"NavigationItem", 'String'>
    readonly textColor: FieldRef<"NavigationItem", 'String'>
    readonly hoverColor: FieldRef<"NavigationItem", 'String'>
    readonly activeColor: FieldRef<"NavigationItem", 'String'>
    readonly fontFamily: FieldRef<"NavigationItem", 'String'>
    readonly fontSize: FieldRef<"NavigationItem", 'String'>
    readonly fontWeight: FieldRef<"NavigationItem", 'String'>
    readonly createdAt: FieldRef<"NavigationItem", 'DateTime'>
    readonly updatedAt: FieldRef<"NavigationItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NavigationItem findUnique
   */
  export type NavigationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItem to fetch.
     */
    where: NavigationItemWhereUniqueInput
  }

  /**
   * NavigationItem findUniqueOrThrow
   */
  export type NavigationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItem to fetch.
     */
    where: NavigationItemWhereUniqueInput
  }

  /**
   * NavigationItem findFirst
   */
  export type NavigationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItem to fetch.
     */
    where?: NavigationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItems to fetch.
     */
    orderBy?: NavigationItemOrderByWithRelationInput | NavigationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigationItems.
     */
    cursor?: NavigationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigationItems.
     */
    distinct?: NavigationItemScalarFieldEnum | NavigationItemScalarFieldEnum[]
  }

  /**
   * NavigationItem findFirstOrThrow
   */
  export type NavigationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItem to fetch.
     */
    where?: NavigationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItems to fetch.
     */
    orderBy?: NavigationItemOrderByWithRelationInput | NavigationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigationItems.
     */
    cursor?: NavigationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigationItems.
     */
    distinct?: NavigationItemScalarFieldEnum | NavigationItemScalarFieldEnum[]
  }

  /**
   * NavigationItem findMany
   */
  export type NavigationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItems to fetch.
     */
    where?: NavigationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItems to fetch.
     */
    orderBy?: NavigationItemOrderByWithRelationInput | NavigationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavigationItems.
     */
    cursor?: NavigationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItems.
     */
    skip?: number
    distinct?: NavigationItemScalarFieldEnum | NavigationItemScalarFieldEnum[]
  }

  /**
   * NavigationItem create
   */
  export type NavigationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a NavigationItem.
     */
    data: XOR<NavigationItemCreateInput, NavigationItemUncheckedCreateInput>
  }

  /**
   * NavigationItem createMany
   */
  export type NavigationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavigationItems.
     */
    data: NavigationItemCreateManyInput | NavigationItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NavigationItem update
   */
  export type NavigationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a NavigationItem.
     */
    data: XOR<NavigationItemUpdateInput, NavigationItemUncheckedUpdateInput>
    /**
     * Choose, which NavigationItem to update.
     */
    where: NavigationItemWhereUniqueInput
  }

  /**
   * NavigationItem updateMany
   */
  export type NavigationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavigationItems.
     */
    data: XOR<NavigationItemUpdateManyMutationInput, NavigationItemUncheckedUpdateManyInput>
    /**
     * Filter which NavigationItems to update
     */
    where?: NavigationItemWhereInput
    /**
     * Limit how many NavigationItems to update.
     */
    limit?: number
  }

  /**
   * NavigationItem upsert
   */
  export type NavigationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the NavigationItem to update in case it exists.
     */
    where: NavigationItemWhereUniqueInput
    /**
     * In case the NavigationItem found by the `where` argument doesn't exist, create a new NavigationItem with this data.
     */
    create: XOR<NavigationItemCreateInput, NavigationItemUncheckedCreateInput>
    /**
     * In case the NavigationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavigationItemUpdateInput, NavigationItemUncheckedUpdateInput>
  }

  /**
   * NavigationItem delete
   */
  export type NavigationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    /**
     * Filter which NavigationItem to delete.
     */
    where: NavigationItemWhereUniqueInput
  }

  /**
   * NavigationItem deleteMany
   */
  export type NavigationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigationItems to delete
     */
    where?: NavigationItemWhereInput
    /**
     * Limit how many NavigationItems to delete.
     */
    limit?: number
  }

  /**
   * NavigationItem.translations
   */
  export type NavigationItem$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    where?: NavigationItemTranslationWhereInput
    orderBy?: NavigationItemTranslationOrderByWithRelationInput | NavigationItemTranslationOrderByWithRelationInput[]
    cursor?: NavigationItemTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NavigationItemTranslationScalarFieldEnum | NavigationItemTranslationScalarFieldEnum[]
  }

  /**
   * NavigationItem.parent
   */
  export type NavigationItem$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    where?: NavigationItemWhereInput
  }

  /**
   * NavigationItem.children
   */
  export type NavigationItem$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
    where?: NavigationItemWhereInput
    orderBy?: NavigationItemOrderByWithRelationInput | NavigationItemOrderByWithRelationInput[]
    cursor?: NavigationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NavigationItemScalarFieldEnum | NavigationItemScalarFieldEnum[]
  }

  /**
   * NavigationItem without action
   */
  export type NavigationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItem
     */
    select?: NavigationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItem
     */
    omit?: NavigationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemInclude<ExtArgs> | null
  }


  /**
   * Model NavigationItemTranslation
   */

  export type AggregateNavigationItemTranslation = {
    _count: NavigationItemTranslationCountAggregateOutputType | null
    _min: NavigationItemTranslationMinAggregateOutputType | null
    _max: NavigationItemTranslationMaxAggregateOutputType | null
  }

  export type NavigationItemTranslationMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    language: string | null
    title: string | null
    url: string | null
  }

  export type NavigationItemTranslationMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    language: string | null
    title: string | null
    url: string | null
  }

  export type NavigationItemTranslationCountAggregateOutputType = {
    id: number
    itemId: number
    language: number
    title: number
    url: number
    _all: number
  }


  export type NavigationItemTranslationMinAggregateInputType = {
    id?: true
    itemId?: true
    language?: true
    title?: true
    url?: true
  }

  export type NavigationItemTranslationMaxAggregateInputType = {
    id?: true
    itemId?: true
    language?: true
    title?: true
    url?: true
  }

  export type NavigationItemTranslationCountAggregateInputType = {
    id?: true
    itemId?: true
    language?: true
    title?: true
    url?: true
    _all?: true
  }

  export type NavigationItemTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigationItemTranslation to aggregate.
     */
    where?: NavigationItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItemTranslations to fetch.
     */
    orderBy?: NavigationItemTranslationOrderByWithRelationInput | NavigationItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NavigationItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NavigationItemTranslations
    **/
    _count?: true | NavigationItemTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NavigationItemTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NavigationItemTranslationMaxAggregateInputType
  }

  export type GetNavigationItemTranslationAggregateType<T extends NavigationItemTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateNavigationItemTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNavigationItemTranslation[P]>
      : GetScalarType<T[P], AggregateNavigationItemTranslation[P]>
  }




  export type NavigationItemTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NavigationItemTranslationWhereInput
    orderBy?: NavigationItemTranslationOrderByWithAggregationInput | NavigationItemTranslationOrderByWithAggregationInput[]
    by: NavigationItemTranslationScalarFieldEnum[] | NavigationItemTranslationScalarFieldEnum
    having?: NavigationItemTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NavigationItemTranslationCountAggregateInputType | true
    _min?: NavigationItemTranslationMinAggregateInputType
    _max?: NavigationItemTranslationMaxAggregateInputType
  }

  export type NavigationItemTranslationGroupByOutputType = {
    id: string
    itemId: string
    language: string
    title: string
    url: string
    _count: NavigationItemTranslationCountAggregateOutputType | null
    _min: NavigationItemTranslationMinAggregateOutputType | null
    _max: NavigationItemTranslationMaxAggregateOutputType | null
  }

  type GetNavigationItemTranslationGroupByPayload<T extends NavigationItemTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NavigationItemTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NavigationItemTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NavigationItemTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], NavigationItemTranslationGroupByOutputType[P]>
        }
      >
    >


  export type NavigationItemTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    language?: boolean
    title?: boolean
    url?: boolean
    item?: boolean | NavigationItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["navigationItemTranslation"]>



  export type NavigationItemTranslationSelectScalar = {
    id?: boolean
    itemId?: boolean
    language?: boolean
    title?: boolean
    url?: boolean
  }

  export type NavigationItemTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "language" | "title" | "url", ExtArgs["result"]["navigationItemTranslation"]>
  export type NavigationItemTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | NavigationItemDefaultArgs<ExtArgs>
  }

  export type $NavigationItemTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NavigationItemTranslation"
    objects: {
      item: Prisma.$NavigationItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      language: string
      title: string
      url: string
    }, ExtArgs["result"]["navigationItemTranslation"]>
    composites: {}
  }

  type NavigationItemTranslationGetPayload<S extends boolean | null | undefined | NavigationItemTranslationDefaultArgs> = $Result.GetResult<Prisma.$NavigationItemTranslationPayload, S>

  type NavigationItemTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NavigationItemTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NavigationItemTranslationCountAggregateInputType | true
    }

  export interface NavigationItemTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NavigationItemTranslation'], meta: { name: 'NavigationItemTranslation' } }
    /**
     * Find zero or one NavigationItemTranslation that matches the filter.
     * @param {NavigationItemTranslationFindUniqueArgs} args - Arguments to find a NavigationItemTranslation
     * @example
     * // Get one NavigationItemTranslation
     * const navigationItemTranslation = await prisma.navigationItemTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NavigationItemTranslationFindUniqueArgs>(args: SelectSubset<T, NavigationItemTranslationFindUniqueArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NavigationItemTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NavigationItemTranslationFindUniqueOrThrowArgs} args - Arguments to find a NavigationItemTranslation
     * @example
     * // Get one NavigationItemTranslation
     * const navigationItemTranslation = await prisma.navigationItemTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NavigationItemTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, NavigationItemTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NavigationItemTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationFindFirstArgs} args - Arguments to find a NavigationItemTranslation
     * @example
     * // Get one NavigationItemTranslation
     * const navigationItemTranslation = await prisma.navigationItemTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NavigationItemTranslationFindFirstArgs>(args?: SelectSubset<T, NavigationItemTranslationFindFirstArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NavigationItemTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationFindFirstOrThrowArgs} args - Arguments to find a NavigationItemTranslation
     * @example
     * // Get one NavigationItemTranslation
     * const navigationItemTranslation = await prisma.navigationItemTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NavigationItemTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, NavigationItemTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NavigationItemTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NavigationItemTranslations
     * const navigationItemTranslations = await prisma.navigationItemTranslation.findMany()
     * 
     * // Get first 10 NavigationItemTranslations
     * const navigationItemTranslations = await prisma.navigationItemTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const navigationItemTranslationWithIdOnly = await prisma.navigationItemTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NavigationItemTranslationFindManyArgs>(args?: SelectSubset<T, NavigationItemTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NavigationItemTranslation.
     * @param {NavigationItemTranslationCreateArgs} args - Arguments to create a NavigationItemTranslation.
     * @example
     * // Create one NavigationItemTranslation
     * const NavigationItemTranslation = await prisma.navigationItemTranslation.create({
     *   data: {
     *     // ... data to create a NavigationItemTranslation
     *   }
     * })
     * 
     */
    create<T extends NavigationItemTranslationCreateArgs>(args: SelectSubset<T, NavigationItemTranslationCreateArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NavigationItemTranslations.
     * @param {NavigationItemTranslationCreateManyArgs} args - Arguments to create many NavigationItemTranslations.
     * @example
     * // Create many NavigationItemTranslations
     * const navigationItemTranslation = await prisma.navigationItemTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NavigationItemTranslationCreateManyArgs>(args?: SelectSubset<T, NavigationItemTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NavigationItemTranslation.
     * @param {NavigationItemTranslationDeleteArgs} args - Arguments to delete one NavigationItemTranslation.
     * @example
     * // Delete one NavigationItemTranslation
     * const NavigationItemTranslation = await prisma.navigationItemTranslation.delete({
     *   where: {
     *     // ... filter to delete one NavigationItemTranslation
     *   }
     * })
     * 
     */
    delete<T extends NavigationItemTranslationDeleteArgs>(args: SelectSubset<T, NavigationItemTranslationDeleteArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NavigationItemTranslation.
     * @param {NavigationItemTranslationUpdateArgs} args - Arguments to update one NavigationItemTranslation.
     * @example
     * // Update one NavigationItemTranslation
     * const navigationItemTranslation = await prisma.navigationItemTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NavigationItemTranslationUpdateArgs>(args: SelectSubset<T, NavigationItemTranslationUpdateArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NavigationItemTranslations.
     * @param {NavigationItemTranslationDeleteManyArgs} args - Arguments to filter NavigationItemTranslations to delete.
     * @example
     * // Delete a few NavigationItemTranslations
     * const { count } = await prisma.navigationItemTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NavigationItemTranslationDeleteManyArgs>(args?: SelectSubset<T, NavigationItemTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NavigationItemTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NavigationItemTranslations
     * const navigationItemTranslation = await prisma.navigationItemTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NavigationItemTranslationUpdateManyArgs>(args: SelectSubset<T, NavigationItemTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NavigationItemTranslation.
     * @param {NavigationItemTranslationUpsertArgs} args - Arguments to update or create a NavigationItemTranslation.
     * @example
     * // Update or create a NavigationItemTranslation
     * const navigationItemTranslation = await prisma.navigationItemTranslation.upsert({
     *   create: {
     *     // ... data to create a NavigationItemTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NavigationItemTranslation we want to update
     *   }
     * })
     */
    upsert<T extends NavigationItemTranslationUpsertArgs>(args: SelectSubset<T, NavigationItemTranslationUpsertArgs<ExtArgs>>): Prisma__NavigationItemTranslationClient<$Result.GetResult<Prisma.$NavigationItemTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NavigationItemTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationCountArgs} args - Arguments to filter NavigationItemTranslations to count.
     * @example
     * // Count the number of NavigationItemTranslations
     * const count = await prisma.navigationItemTranslation.count({
     *   where: {
     *     // ... the filter for the NavigationItemTranslations we want to count
     *   }
     * })
    **/
    count<T extends NavigationItemTranslationCountArgs>(
      args?: Subset<T, NavigationItemTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NavigationItemTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NavigationItemTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NavigationItemTranslationAggregateArgs>(args: Subset<T, NavigationItemTranslationAggregateArgs>): Prisma.PrismaPromise<GetNavigationItemTranslationAggregateType<T>>

    /**
     * Group by NavigationItemTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NavigationItemTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NavigationItemTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NavigationItemTranslationGroupByArgs['orderBy'] }
        : { orderBy?: NavigationItemTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NavigationItemTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNavigationItemTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NavigationItemTranslation model
   */
  readonly fields: NavigationItemTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NavigationItemTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NavigationItemTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends NavigationItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NavigationItemDefaultArgs<ExtArgs>>): Prisma__NavigationItemClient<$Result.GetResult<Prisma.$NavigationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NavigationItemTranslation model
   */
  interface NavigationItemTranslationFieldRefs {
    readonly id: FieldRef<"NavigationItemTranslation", 'String'>
    readonly itemId: FieldRef<"NavigationItemTranslation", 'String'>
    readonly language: FieldRef<"NavigationItemTranslation", 'String'>
    readonly title: FieldRef<"NavigationItemTranslation", 'String'>
    readonly url: FieldRef<"NavigationItemTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NavigationItemTranslation findUnique
   */
  export type NavigationItemTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItemTranslation to fetch.
     */
    where: NavigationItemTranslationWhereUniqueInput
  }

  /**
   * NavigationItemTranslation findUniqueOrThrow
   */
  export type NavigationItemTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItemTranslation to fetch.
     */
    where: NavigationItemTranslationWhereUniqueInput
  }

  /**
   * NavigationItemTranslation findFirst
   */
  export type NavigationItemTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItemTranslation to fetch.
     */
    where?: NavigationItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItemTranslations to fetch.
     */
    orderBy?: NavigationItemTranslationOrderByWithRelationInput | NavigationItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigationItemTranslations.
     */
    cursor?: NavigationItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigationItemTranslations.
     */
    distinct?: NavigationItemTranslationScalarFieldEnum | NavigationItemTranslationScalarFieldEnum[]
  }

  /**
   * NavigationItemTranslation findFirstOrThrow
   */
  export type NavigationItemTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItemTranslation to fetch.
     */
    where?: NavigationItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItemTranslations to fetch.
     */
    orderBy?: NavigationItemTranslationOrderByWithRelationInput | NavigationItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NavigationItemTranslations.
     */
    cursor?: NavigationItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItemTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NavigationItemTranslations.
     */
    distinct?: NavigationItemTranslationScalarFieldEnum | NavigationItemTranslationScalarFieldEnum[]
  }

  /**
   * NavigationItemTranslation findMany
   */
  export type NavigationItemTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * Filter, which NavigationItemTranslations to fetch.
     */
    where?: NavigationItemTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NavigationItemTranslations to fetch.
     */
    orderBy?: NavigationItemTranslationOrderByWithRelationInput | NavigationItemTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NavigationItemTranslations.
     */
    cursor?: NavigationItemTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NavigationItemTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NavigationItemTranslations.
     */
    skip?: number
    distinct?: NavigationItemTranslationScalarFieldEnum | NavigationItemTranslationScalarFieldEnum[]
  }

  /**
   * NavigationItemTranslation create
   */
  export type NavigationItemTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a NavigationItemTranslation.
     */
    data: XOR<NavigationItemTranslationCreateInput, NavigationItemTranslationUncheckedCreateInput>
  }

  /**
   * NavigationItemTranslation createMany
   */
  export type NavigationItemTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NavigationItemTranslations.
     */
    data: NavigationItemTranslationCreateManyInput | NavigationItemTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NavigationItemTranslation update
   */
  export type NavigationItemTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a NavigationItemTranslation.
     */
    data: XOR<NavigationItemTranslationUpdateInput, NavigationItemTranslationUncheckedUpdateInput>
    /**
     * Choose, which NavigationItemTranslation to update.
     */
    where: NavigationItemTranslationWhereUniqueInput
  }

  /**
   * NavigationItemTranslation updateMany
   */
  export type NavigationItemTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NavigationItemTranslations.
     */
    data: XOR<NavigationItemTranslationUpdateManyMutationInput, NavigationItemTranslationUncheckedUpdateManyInput>
    /**
     * Filter which NavigationItemTranslations to update
     */
    where?: NavigationItemTranslationWhereInput
    /**
     * Limit how many NavigationItemTranslations to update.
     */
    limit?: number
  }

  /**
   * NavigationItemTranslation upsert
   */
  export type NavigationItemTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the NavigationItemTranslation to update in case it exists.
     */
    where: NavigationItemTranslationWhereUniqueInput
    /**
     * In case the NavigationItemTranslation found by the `where` argument doesn't exist, create a new NavigationItemTranslation with this data.
     */
    create: XOR<NavigationItemTranslationCreateInput, NavigationItemTranslationUncheckedCreateInput>
    /**
     * In case the NavigationItemTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NavigationItemTranslationUpdateInput, NavigationItemTranslationUncheckedUpdateInput>
  }

  /**
   * NavigationItemTranslation delete
   */
  export type NavigationItemTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
    /**
     * Filter which NavigationItemTranslation to delete.
     */
    where: NavigationItemTranslationWhereUniqueInput
  }

  /**
   * NavigationItemTranslation deleteMany
   */
  export type NavigationItemTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NavigationItemTranslations to delete
     */
    where?: NavigationItemTranslationWhereInput
    /**
     * Limit how many NavigationItemTranslations to delete.
     */
    limit?: number
  }

  /**
   * NavigationItemTranslation without action
   */
  export type NavigationItemTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NavigationItemTranslation
     */
    select?: NavigationItemTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NavigationItemTranslation
     */
    omit?: NavigationItemTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NavigationItemTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    displayType: string | null
    imageUrl: string | null
    backgroundColor: string | null
    overlayColor: string | null
    ctaText: string | null
    ctaUrl: string | null
    isActive: boolean | null
    customHtml: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    displayType: string | null
    imageUrl: string | null
    backgroundColor: string | null
    overlayColor: string | null
    ctaText: string | null
    ctaUrl: string | null
    isActive: boolean | null
    customHtml: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    title: number
    subtitle: number
    description: number
    displayType: number
    imageUrl: number
    backgroundColor: number
    overlayColor: number
    ctaText: number
    ctaUrl: number
    isActive: number
    customHtml: number
    createdBy: number
    updatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    title?: true
    subtitle?: true
    description?: true
    displayType?: true
    imageUrl?: true
    backgroundColor?: true
    overlayColor?: true
    ctaText?: true
    ctaUrl?: true
    isActive?: true
    customHtml?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    title?: true
    subtitle?: true
    description?: true
    displayType?: true
    imageUrl?: true
    backgroundColor?: true
    overlayColor?: true
    ctaText?: true
    ctaUrl?: true
    isActive?: true
    customHtml?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    title?: true
    subtitle?: true
    description?: true
    displayType?: true
    imageUrl?: true
    backgroundColor?: true
    overlayColor?: true
    ctaText?: true
    ctaUrl?: true
    isActive?: true
    customHtml?: true
    createdBy?: true
    updatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    slug: string
    name: string
    title: string | null
    subtitle: string | null
    description: string | null
    displayType: string
    imageUrl: string | null
    backgroundColor: string | null
    overlayColor: string | null
    ctaText: string | null
    ctaUrl: string | null
    isActive: boolean
    customHtml: string | null
    createdBy: string | null
    updatedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    displayType?: boolean
    imageUrl?: boolean
    backgroundColor?: boolean
    overlayColor?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    isActive?: boolean
    customHtml?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | Banner$translationsArgs<ExtArgs>
    placements?: boolean | Banner$placementsArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banner"]>



  export type BannerSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    displayType?: boolean
    imageUrl?: boolean
    backgroundColor?: boolean
    overlayColor?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    isActive?: boolean
    customHtml?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "title" | "subtitle" | "description" | "displayType" | "imageUrl" | "backgroundColor" | "overlayColor" | "ctaText" | "ctaUrl" | "isActive" | "customHtml" | "createdBy" | "updatedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["banner"]>
  export type BannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | Banner$translationsArgs<ExtArgs>
    placements?: boolean | Banner$placementsArgs<ExtArgs>
    _count?: boolean | BannerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {
      translations: Prisma.$BannerTranslationPayload<ExtArgs>[]
      placements: Prisma.$BannerPlacementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      title: string | null
      subtitle: string | null
      description: string | null
      displayType: string
      imageUrl: string | null
      backgroundColor: string | null
      overlayColor: string | null
      ctaText: string | null
      ctaUrl: string | null
      isActive: boolean
      customHtml: string | null
      createdBy: string | null
      updatedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends Banner$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Banner$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    placements<T extends Banner$placementsArgs<ExtArgs> = {}>(args?: Subset<T, Banner$placementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly slug: FieldRef<"Banner", 'String'>
    readonly name: FieldRef<"Banner", 'String'>
    readonly title: FieldRef<"Banner", 'String'>
    readonly subtitle: FieldRef<"Banner", 'String'>
    readonly description: FieldRef<"Banner", 'String'>
    readonly displayType: FieldRef<"Banner", 'String'>
    readonly imageUrl: FieldRef<"Banner", 'String'>
    readonly backgroundColor: FieldRef<"Banner", 'String'>
    readonly overlayColor: FieldRef<"Banner", 'String'>
    readonly ctaText: FieldRef<"Banner", 'String'>
    readonly ctaUrl: FieldRef<"Banner", 'String'>
    readonly isActive: FieldRef<"Banner", 'Boolean'>
    readonly customHtml: FieldRef<"Banner", 'String'>
    readonly createdBy: FieldRef<"Banner", 'String'>
    readonly updatedBy: FieldRef<"Banner", 'String'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner.translations
   */
  export type Banner$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    where?: BannerTranslationWhereInput
    orderBy?: BannerTranslationOrderByWithRelationInput | BannerTranslationOrderByWithRelationInput[]
    cursor?: BannerTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerTranslationScalarFieldEnum | BannerTranslationScalarFieldEnum[]
  }

  /**
   * Banner.placements
   */
  export type Banner$placementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    where?: BannerPlacementWhereInput
    orderBy?: BannerPlacementOrderByWithRelationInput | BannerPlacementOrderByWithRelationInput[]
    cursor?: BannerPlacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BannerPlacementScalarFieldEnum | BannerPlacementScalarFieldEnum[]
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerInclude<ExtArgs> | null
  }


  /**
   * Model BannerTranslation
   */

  export type AggregateBannerTranslation = {
    _count: BannerTranslationCountAggregateOutputType | null
    _min: BannerTranslationMinAggregateOutputType | null
    _max: BannerTranslationMaxAggregateOutputType | null
  }

  export type BannerTranslationMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    language: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    ctaUrl: string | null
    imageUrl: string | null
  }

  export type BannerTranslationMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    language: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    ctaUrl: string | null
    imageUrl: string | null
  }

  export type BannerTranslationCountAggregateOutputType = {
    id: number
    bannerId: number
    language: number
    title: number
    subtitle: number
    description: number
    ctaText: number
    ctaUrl: number
    imageUrl: number
    _all: number
  }


  export type BannerTranslationMinAggregateInputType = {
    id?: true
    bannerId?: true
    language?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    ctaUrl?: true
    imageUrl?: true
  }

  export type BannerTranslationMaxAggregateInputType = {
    id?: true
    bannerId?: true
    language?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    ctaUrl?: true
    imageUrl?: true
  }

  export type BannerTranslationCountAggregateInputType = {
    id?: true
    bannerId?: true
    language?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    ctaUrl?: true
    imageUrl?: true
    _all?: true
  }

  export type BannerTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerTranslation to aggregate.
     */
    where?: BannerTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerTranslations to fetch.
     */
    orderBy?: BannerTranslationOrderByWithRelationInput | BannerTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerTranslations
    **/
    _count?: true | BannerTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerTranslationMaxAggregateInputType
  }

  export type GetBannerTranslationAggregateType<T extends BannerTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerTranslation[P]>
      : GetScalarType<T[P], AggregateBannerTranslation[P]>
  }




  export type BannerTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerTranslationWhereInput
    orderBy?: BannerTranslationOrderByWithAggregationInput | BannerTranslationOrderByWithAggregationInput[]
    by: BannerTranslationScalarFieldEnum[] | BannerTranslationScalarFieldEnum
    having?: BannerTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerTranslationCountAggregateInputType | true
    _min?: BannerTranslationMinAggregateInputType
    _max?: BannerTranslationMaxAggregateInputType
  }

  export type BannerTranslationGroupByOutputType = {
    id: string
    bannerId: string
    language: string
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    ctaUrl: string | null
    imageUrl: string | null
    _count: BannerTranslationCountAggregateOutputType | null
    _min: BannerTranslationMinAggregateOutputType | null
    _max: BannerTranslationMaxAggregateOutputType | null
  }

  type GetBannerTranslationGroupByPayload<T extends BannerTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], BannerTranslationGroupByOutputType[P]>
        }
      >
    >


  export type BannerTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    language?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    imageUrl?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerTranslation"]>



  export type BannerTranslationSelectScalar = {
    id?: boolean
    bannerId?: boolean
    language?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    imageUrl?: boolean
  }

  export type BannerTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "language" | "title" | "subtitle" | "description" | "ctaText" | "ctaUrl" | "imageUrl", ExtArgs["result"]["bannerTranslation"]>
  export type BannerTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
  }

  export type $BannerTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerTranslation"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      language: string
      title: string | null
      subtitle: string | null
      description: string | null
      ctaText: string | null
      ctaUrl: string | null
      imageUrl: string | null
    }, ExtArgs["result"]["bannerTranslation"]>
    composites: {}
  }

  type BannerTranslationGetPayload<S extends boolean | null | undefined | BannerTranslationDefaultArgs> = $Result.GetResult<Prisma.$BannerTranslationPayload, S>

  type BannerTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerTranslationCountAggregateInputType | true
    }

  export interface BannerTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerTranslation'], meta: { name: 'BannerTranslation' } }
    /**
     * Find zero or one BannerTranslation that matches the filter.
     * @param {BannerTranslationFindUniqueArgs} args - Arguments to find a BannerTranslation
     * @example
     * // Get one BannerTranslation
     * const bannerTranslation = await prisma.bannerTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerTranslationFindUniqueArgs>(args: SelectSubset<T, BannerTranslationFindUniqueArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerTranslationFindUniqueOrThrowArgs} args - Arguments to find a BannerTranslation
     * @example
     * // Get one BannerTranslation
     * const bannerTranslation = await prisma.bannerTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationFindFirstArgs} args - Arguments to find a BannerTranslation
     * @example
     * // Get one BannerTranslation
     * const bannerTranslation = await prisma.bannerTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerTranslationFindFirstArgs>(args?: SelectSubset<T, BannerTranslationFindFirstArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationFindFirstOrThrowArgs} args - Arguments to find a BannerTranslation
     * @example
     * // Get one BannerTranslation
     * const bannerTranslation = await prisma.bannerTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerTranslations
     * const bannerTranslations = await prisma.bannerTranslation.findMany()
     * 
     * // Get first 10 BannerTranslations
     * const bannerTranslations = await prisma.bannerTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerTranslationWithIdOnly = await prisma.bannerTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerTranslationFindManyArgs>(args?: SelectSubset<T, BannerTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerTranslation.
     * @param {BannerTranslationCreateArgs} args - Arguments to create a BannerTranslation.
     * @example
     * // Create one BannerTranslation
     * const BannerTranslation = await prisma.bannerTranslation.create({
     *   data: {
     *     // ... data to create a BannerTranslation
     *   }
     * })
     * 
     */
    create<T extends BannerTranslationCreateArgs>(args: SelectSubset<T, BannerTranslationCreateArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerTranslations.
     * @param {BannerTranslationCreateManyArgs} args - Arguments to create many BannerTranslations.
     * @example
     * // Create many BannerTranslations
     * const bannerTranslation = await prisma.bannerTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerTranslationCreateManyArgs>(args?: SelectSubset<T, BannerTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BannerTranslation.
     * @param {BannerTranslationDeleteArgs} args - Arguments to delete one BannerTranslation.
     * @example
     * // Delete one BannerTranslation
     * const BannerTranslation = await prisma.bannerTranslation.delete({
     *   where: {
     *     // ... filter to delete one BannerTranslation
     *   }
     * })
     * 
     */
    delete<T extends BannerTranslationDeleteArgs>(args: SelectSubset<T, BannerTranslationDeleteArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerTranslation.
     * @param {BannerTranslationUpdateArgs} args - Arguments to update one BannerTranslation.
     * @example
     * // Update one BannerTranslation
     * const bannerTranslation = await prisma.bannerTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerTranslationUpdateArgs>(args: SelectSubset<T, BannerTranslationUpdateArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerTranslations.
     * @param {BannerTranslationDeleteManyArgs} args - Arguments to filter BannerTranslations to delete.
     * @example
     * // Delete a few BannerTranslations
     * const { count } = await prisma.bannerTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerTranslationDeleteManyArgs>(args?: SelectSubset<T, BannerTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerTranslations
     * const bannerTranslation = await prisma.bannerTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerTranslationUpdateManyArgs>(args: SelectSubset<T, BannerTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BannerTranslation.
     * @param {BannerTranslationUpsertArgs} args - Arguments to update or create a BannerTranslation.
     * @example
     * // Update or create a BannerTranslation
     * const bannerTranslation = await prisma.bannerTranslation.upsert({
     *   create: {
     *     // ... data to create a BannerTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerTranslation we want to update
     *   }
     * })
     */
    upsert<T extends BannerTranslationUpsertArgs>(args: SelectSubset<T, BannerTranslationUpsertArgs<ExtArgs>>): Prisma__BannerTranslationClient<$Result.GetResult<Prisma.$BannerTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationCountArgs} args - Arguments to filter BannerTranslations to count.
     * @example
     * // Count the number of BannerTranslations
     * const count = await prisma.bannerTranslation.count({
     *   where: {
     *     // ... the filter for the BannerTranslations we want to count
     *   }
     * })
    **/
    count<T extends BannerTranslationCountArgs>(
      args?: Subset<T, BannerTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerTranslationAggregateArgs>(args: Subset<T, BannerTranslationAggregateArgs>): Prisma.PrismaPromise<GetBannerTranslationAggregateType<T>>

    /**
     * Group by BannerTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerTranslationGroupByArgs['orderBy'] }
        : { orderBy?: BannerTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerTranslation model
   */
  readonly fields: BannerTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerTranslation model
   */
  interface BannerTranslationFieldRefs {
    readonly id: FieldRef<"BannerTranslation", 'String'>
    readonly bannerId: FieldRef<"BannerTranslation", 'String'>
    readonly language: FieldRef<"BannerTranslation", 'String'>
    readonly title: FieldRef<"BannerTranslation", 'String'>
    readonly subtitle: FieldRef<"BannerTranslation", 'String'>
    readonly description: FieldRef<"BannerTranslation", 'String'>
    readonly ctaText: FieldRef<"BannerTranslation", 'String'>
    readonly ctaUrl: FieldRef<"BannerTranslation", 'String'>
    readonly imageUrl: FieldRef<"BannerTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BannerTranslation findUnique
   */
  export type BannerTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BannerTranslation to fetch.
     */
    where: BannerTranslationWhereUniqueInput
  }

  /**
   * BannerTranslation findUniqueOrThrow
   */
  export type BannerTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BannerTranslation to fetch.
     */
    where: BannerTranslationWhereUniqueInput
  }

  /**
   * BannerTranslation findFirst
   */
  export type BannerTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BannerTranslation to fetch.
     */
    where?: BannerTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerTranslations to fetch.
     */
    orderBy?: BannerTranslationOrderByWithRelationInput | BannerTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerTranslations.
     */
    cursor?: BannerTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerTranslations.
     */
    distinct?: BannerTranslationScalarFieldEnum | BannerTranslationScalarFieldEnum[]
  }

  /**
   * BannerTranslation findFirstOrThrow
   */
  export type BannerTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BannerTranslation to fetch.
     */
    where?: BannerTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerTranslations to fetch.
     */
    orderBy?: BannerTranslationOrderByWithRelationInput | BannerTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerTranslations.
     */
    cursor?: BannerTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerTranslations.
     */
    distinct?: BannerTranslationScalarFieldEnum | BannerTranslationScalarFieldEnum[]
  }

  /**
   * BannerTranslation findMany
   */
  export type BannerTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * Filter, which BannerTranslations to fetch.
     */
    where?: BannerTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerTranslations to fetch.
     */
    orderBy?: BannerTranslationOrderByWithRelationInput | BannerTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerTranslations.
     */
    cursor?: BannerTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerTranslations.
     */
    skip?: number
    distinct?: BannerTranslationScalarFieldEnum | BannerTranslationScalarFieldEnum[]
  }

  /**
   * BannerTranslation create
   */
  export type BannerTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerTranslation.
     */
    data: XOR<BannerTranslationCreateInput, BannerTranslationUncheckedCreateInput>
  }

  /**
   * BannerTranslation createMany
   */
  export type BannerTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerTranslations.
     */
    data: BannerTranslationCreateManyInput | BannerTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerTranslation update
   */
  export type BannerTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerTranslation.
     */
    data: XOR<BannerTranslationUpdateInput, BannerTranslationUncheckedUpdateInput>
    /**
     * Choose, which BannerTranslation to update.
     */
    where: BannerTranslationWhereUniqueInput
  }

  /**
   * BannerTranslation updateMany
   */
  export type BannerTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerTranslations.
     */
    data: XOR<BannerTranslationUpdateManyMutationInput, BannerTranslationUncheckedUpdateManyInput>
    /**
     * Filter which BannerTranslations to update
     */
    where?: BannerTranslationWhereInput
    /**
     * Limit how many BannerTranslations to update.
     */
    limit?: number
  }

  /**
   * BannerTranslation upsert
   */
  export type BannerTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerTranslation to update in case it exists.
     */
    where: BannerTranslationWhereUniqueInput
    /**
     * In case the BannerTranslation found by the `where` argument doesn't exist, create a new BannerTranslation with this data.
     */
    create: XOR<BannerTranslationCreateInput, BannerTranslationUncheckedCreateInput>
    /**
     * In case the BannerTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerTranslationUpdateInput, BannerTranslationUncheckedUpdateInput>
  }

  /**
   * BannerTranslation delete
   */
  export type BannerTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
    /**
     * Filter which BannerTranslation to delete.
     */
    where: BannerTranslationWhereUniqueInput
  }

  /**
   * BannerTranslation deleteMany
   */
  export type BannerTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerTranslations to delete
     */
    where?: BannerTranslationWhereInput
    /**
     * Limit how many BannerTranslations to delete.
     */
    limit?: number
  }

  /**
   * BannerTranslation without action
   */
  export type BannerTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerTranslation
     */
    select?: BannerTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerTranslation
     */
    omit?: BannerTranslationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerTranslationInclude<ExtArgs> | null
  }


  /**
   * Model BannerPlacement
   */

  export type AggregateBannerPlacement = {
    _count: BannerPlacementCountAggregateOutputType | null
    _avg: BannerPlacementAvgAggregateOutputType | null
    _sum: BannerPlacementSumAggregateOutputType | null
    _min: BannerPlacementMinAggregateOutputType | null
    _max: BannerPlacementMaxAggregateOutputType | null
  }

  export type BannerPlacementAvgAggregateOutputType = {
    position: number | null
  }

  export type BannerPlacementSumAggregateOutputType = {
    position: number | null
  }

  export type BannerPlacementMinAggregateOutputType = {
    id: string | null
    bannerId: string | null
    location: string | null
    position: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
  }

  export type BannerPlacementMaxAggregateOutputType = {
    id: string | null
    bannerId: string | null
    location: string | null
    position: number | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
  }

  export type BannerPlacementCountAggregateOutputType = {
    id: number
    bannerId: number
    location: number
    position: number
    isActive: number
    startDate: number
    endDate: number
    _all: number
  }


  export type BannerPlacementAvgAggregateInputType = {
    position?: true
  }

  export type BannerPlacementSumAggregateInputType = {
    position?: true
  }

  export type BannerPlacementMinAggregateInputType = {
    id?: true
    bannerId?: true
    location?: true
    position?: true
    isActive?: true
    startDate?: true
    endDate?: true
  }

  export type BannerPlacementMaxAggregateInputType = {
    id?: true
    bannerId?: true
    location?: true
    position?: true
    isActive?: true
    startDate?: true
    endDate?: true
  }

  export type BannerPlacementCountAggregateInputType = {
    id?: true
    bannerId?: true
    location?: true
    position?: true
    isActive?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type BannerPlacementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerPlacement to aggregate.
     */
    where?: BannerPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerPlacements to fetch.
     */
    orderBy?: BannerPlacementOrderByWithRelationInput | BannerPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerPlacements
    **/
    _count?: true | BannerPlacementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerPlacementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerPlacementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerPlacementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerPlacementMaxAggregateInputType
  }

  export type GetBannerPlacementAggregateType<T extends BannerPlacementAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerPlacement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerPlacement[P]>
      : GetScalarType<T[P], AggregateBannerPlacement[P]>
  }




  export type BannerPlacementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerPlacementWhereInput
    orderBy?: BannerPlacementOrderByWithAggregationInput | BannerPlacementOrderByWithAggregationInput[]
    by: BannerPlacementScalarFieldEnum[] | BannerPlacementScalarFieldEnum
    having?: BannerPlacementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerPlacementCountAggregateInputType | true
    _avg?: BannerPlacementAvgAggregateInputType
    _sum?: BannerPlacementSumAggregateInputType
    _min?: BannerPlacementMinAggregateInputType
    _max?: BannerPlacementMaxAggregateInputType
  }

  export type BannerPlacementGroupByOutputType = {
    id: string
    bannerId: string
    location: string
    position: number
    isActive: boolean
    startDate: Date | null
    endDate: Date | null
    _count: BannerPlacementCountAggregateOutputType | null
    _avg: BannerPlacementAvgAggregateOutputType | null
    _sum: BannerPlacementSumAggregateOutputType | null
    _min: BannerPlacementMinAggregateOutputType | null
    _max: BannerPlacementMaxAggregateOutputType | null
  }

  type GetBannerPlacementGroupByPayload<T extends BannerPlacementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerPlacementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerPlacementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerPlacementGroupByOutputType[P]>
            : GetScalarType<T[P], BannerPlacementGroupByOutputType[P]>
        }
      >
    >


  export type BannerPlacementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bannerId?: boolean
    location?: boolean
    position?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    banner?: boolean | BannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bannerPlacement"]>



  export type BannerPlacementSelectScalar = {
    id?: boolean
    bannerId?: boolean
    location?: boolean
    position?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type BannerPlacementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bannerId" | "location" | "position" | "isActive" | "startDate" | "endDate", ExtArgs["result"]["bannerPlacement"]>
  export type BannerPlacementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    banner?: boolean | BannerDefaultArgs<ExtArgs>
  }

  export type $BannerPlacementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BannerPlacement"
    objects: {
      banner: Prisma.$BannerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bannerId: string
      location: string
      position: number
      isActive: boolean
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["bannerPlacement"]>
    composites: {}
  }

  type BannerPlacementGetPayload<S extends boolean | null | undefined | BannerPlacementDefaultArgs> = $Result.GetResult<Prisma.$BannerPlacementPayload, S>

  type BannerPlacementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerPlacementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerPlacementCountAggregateInputType | true
    }

  export interface BannerPlacementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BannerPlacement'], meta: { name: 'BannerPlacement' } }
    /**
     * Find zero or one BannerPlacement that matches the filter.
     * @param {BannerPlacementFindUniqueArgs} args - Arguments to find a BannerPlacement
     * @example
     * // Get one BannerPlacement
     * const bannerPlacement = await prisma.bannerPlacement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerPlacementFindUniqueArgs>(args: SelectSubset<T, BannerPlacementFindUniqueArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BannerPlacement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerPlacementFindUniqueOrThrowArgs} args - Arguments to find a BannerPlacement
     * @example
     * // Get one BannerPlacement
     * const bannerPlacement = await prisma.bannerPlacement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerPlacementFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerPlacementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerPlacement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementFindFirstArgs} args - Arguments to find a BannerPlacement
     * @example
     * // Get one BannerPlacement
     * const bannerPlacement = await prisma.bannerPlacement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerPlacementFindFirstArgs>(args?: SelectSubset<T, BannerPlacementFindFirstArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BannerPlacement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementFindFirstOrThrowArgs} args - Arguments to find a BannerPlacement
     * @example
     * // Get one BannerPlacement
     * const bannerPlacement = await prisma.bannerPlacement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerPlacementFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerPlacementFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BannerPlacements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerPlacements
     * const bannerPlacements = await prisma.bannerPlacement.findMany()
     * 
     * // Get first 10 BannerPlacements
     * const bannerPlacements = await prisma.bannerPlacement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerPlacementWithIdOnly = await prisma.bannerPlacement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerPlacementFindManyArgs>(args?: SelectSubset<T, BannerPlacementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BannerPlacement.
     * @param {BannerPlacementCreateArgs} args - Arguments to create a BannerPlacement.
     * @example
     * // Create one BannerPlacement
     * const BannerPlacement = await prisma.bannerPlacement.create({
     *   data: {
     *     // ... data to create a BannerPlacement
     *   }
     * })
     * 
     */
    create<T extends BannerPlacementCreateArgs>(args: SelectSubset<T, BannerPlacementCreateArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BannerPlacements.
     * @param {BannerPlacementCreateManyArgs} args - Arguments to create many BannerPlacements.
     * @example
     * // Create many BannerPlacements
     * const bannerPlacement = await prisma.bannerPlacement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerPlacementCreateManyArgs>(args?: SelectSubset<T, BannerPlacementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BannerPlacement.
     * @param {BannerPlacementDeleteArgs} args - Arguments to delete one BannerPlacement.
     * @example
     * // Delete one BannerPlacement
     * const BannerPlacement = await prisma.bannerPlacement.delete({
     *   where: {
     *     // ... filter to delete one BannerPlacement
     *   }
     * })
     * 
     */
    delete<T extends BannerPlacementDeleteArgs>(args: SelectSubset<T, BannerPlacementDeleteArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BannerPlacement.
     * @param {BannerPlacementUpdateArgs} args - Arguments to update one BannerPlacement.
     * @example
     * // Update one BannerPlacement
     * const bannerPlacement = await prisma.bannerPlacement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerPlacementUpdateArgs>(args: SelectSubset<T, BannerPlacementUpdateArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BannerPlacements.
     * @param {BannerPlacementDeleteManyArgs} args - Arguments to filter BannerPlacements to delete.
     * @example
     * // Delete a few BannerPlacements
     * const { count } = await prisma.bannerPlacement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerPlacementDeleteManyArgs>(args?: SelectSubset<T, BannerPlacementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerPlacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerPlacements
     * const bannerPlacement = await prisma.bannerPlacement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerPlacementUpdateManyArgs>(args: SelectSubset<T, BannerPlacementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BannerPlacement.
     * @param {BannerPlacementUpsertArgs} args - Arguments to update or create a BannerPlacement.
     * @example
     * // Update or create a BannerPlacement
     * const bannerPlacement = await prisma.bannerPlacement.upsert({
     *   create: {
     *     // ... data to create a BannerPlacement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerPlacement we want to update
     *   }
     * })
     */
    upsert<T extends BannerPlacementUpsertArgs>(args: SelectSubset<T, BannerPlacementUpsertArgs<ExtArgs>>): Prisma__BannerPlacementClient<$Result.GetResult<Prisma.$BannerPlacementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BannerPlacements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementCountArgs} args - Arguments to filter BannerPlacements to count.
     * @example
     * // Count the number of BannerPlacements
     * const count = await prisma.bannerPlacement.count({
     *   where: {
     *     // ... the filter for the BannerPlacements we want to count
     *   }
     * })
    **/
    count<T extends BannerPlacementCountArgs>(
      args?: Subset<T, BannerPlacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerPlacementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerPlacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerPlacementAggregateArgs>(args: Subset<T, BannerPlacementAggregateArgs>): Prisma.PrismaPromise<GetBannerPlacementAggregateType<T>>

    /**
     * Group by BannerPlacement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerPlacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerPlacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerPlacementGroupByArgs['orderBy'] }
        : { orderBy?: BannerPlacementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerPlacementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerPlacementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BannerPlacement model
   */
  readonly fields: BannerPlacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerPlacement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerPlacementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    banner<T extends BannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BannerDefaultArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BannerPlacement model
   */
  interface BannerPlacementFieldRefs {
    readonly id: FieldRef<"BannerPlacement", 'String'>
    readonly bannerId: FieldRef<"BannerPlacement", 'String'>
    readonly location: FieldRef<"BannerPlacement", 'String'>
    readonly position: FieldRef<"BannerPlacement", 'Int'>
    readonly isActive: FieldRef<"BannerPlacement", 'Boolean'>
    readonly startDate: FieldRef<"BannerPlacement", 'DateTime'>
    readonly endDate: FieldRef<"BannerPlacement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BannerPlacement findUnique
   */
  export type BannerPlacementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * Filter, which BannerPlacement to fetch.
     */
    where: BannerPlacementWhereUniqueInput
  }

  /**
   * BannerPlacement findUniqueOrThrow
   */
  export type BannerPlacementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * Filter, which BannerPlacement to fetch.
     */
    where: BannerPlacementWhereUniqueInput
  }

  /**
   * BannerPlacement findFirst
   */
  export type BannerPlacementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * Filter, which BannerPlacement to fetch.
     */
    where?: BannerPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerPlacements to fetch.
     */
    orderBy?: BannerPlacementOrderByWithRelationInput | BannerPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerPlacements.
     */
    cursor?: BannerPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerPlacements.
     */
    distinct?: BannerPlacementScalarFieldEnum | BannerPlacementScalarFieldEnum[]
  }

  /**
   * BannerPlacement findFirstOrThrow
   */
  export type BannerPlacementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * Filter, which BannerPlacement to fetch.
     */
    where?: BannerPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerPlacements to fetch.
     */
    orderBy?: BannerPlacementOrderByWithRelationInput | BannerPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerPlacements.
     */
    cursor?: BannerPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerPlacements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerPlacements.
     */
    distinct?: BannerPlacementScalarFieldEnum | BannerPlacementScalarFieldEnum[]
  }

  /**
   * BannerPlacement findMany
   */
  export type BannerPlacementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * Filter, which BannerPlacements to fetch.
     */
    where?: BannerPlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerPlacements to fetch.
     */
    orderBy?: BannerPlacementOrderByWithRelationInput | BannerPlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerPlacements.
     */
    cursor?: BannerPlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerPlacements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerPlacements.
     */
    skip?: number
    distinct?: BannerPlacementScalarFieldEnum | BannerPlacementScalarFieldEnum[]
  }

  /**
   * BannerPlacement create
   */
  export type BannerPlacementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * The data needed to create a BannerPlacement.
     */
    data: XOR<BannerPlacementCreateInput, BannerPlacementUncheckedCreateInput>
  }

  /**
   * BannerPlacement createMany
   */
  export type BannerPlacementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BannerPlacements.
     */
    data: BannerPlacementCreateManyInput | BannerPlacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BannerPlacement update
   */
  export type BannerPlacementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * The data needed to update a BannerPlacement.
     */
    data: XOR<BannerPlacementUpdateInput, BannerPlacementUncheckedUpdateInput>
    /**
     * Choose, which BannerPlacement to update.
     */
    where: BannerPlacementWhereUniqueInput
  }

  /**
   * BannerPlacement updateMany
   */
  export type BannerPlacementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BannerPlacements.
     */
    data: XOR<BannerPlacementUpdateManyMutationInput, BannerPlacementUncheckedUpdateManyInput>
    /**
     * Filter which BannerPlacements to update
     */
    where?: BannerPlacementWhereInput
    /**
     * Limit how many BannerPlacements to update.
     */
    limit?: number
  }

  /**
   * BannerPlacement upsert
   */
  export type BannerPlacementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * The filter to search for the BannerPlacement to update in case it exists.
     */
    where: BannerPlacementWhereUniqueInput
    /**
     * In case the BannerPlacement found by the `where` argument doesn't exist, create a new BannerPlacement with this data.
     */
    create: XOR<BannerPlacementCreateInput, BannerPlacementUncheckedCreateInput>
    /**
     * In case the BannerPlacement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerPlacementUpdateInput, BannerPlacementUncheckedUpdateInput>
  }

  /**
   * BannerPlacement delete
   */
  export type BannerPlacementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
    /**
     * Filter which BannerPlacement to delete.
     */
    where: BannerPlacementWhereUniqueInput
  }

  /**
   * BannerPlacement deleteMany
   */
  export type BannerPlacementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BannerPlacements to delete
     */
    where?: BannerPlacementWhereInput
    /**
     * Limit how many BannerPlacements to delete.
     */
    limit?: number
  }

  /**
   * BannerPlacement without action
   */
  export type BannerPlacementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannerPlacement
     */
    select?: BannerPlacementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BannerPlacement
     */
    omit?: BannerPlacementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BannerPlacementInclude<ExtArgs> | null
  }


  /**
   * Model TopbarSettings
   */

  export type AggregateTopbarSettings = {
    _count: TopbarSettingsCountAggregateOutputType | null
    _min: TopbarSettingsMinAggregateOutputType | null
    _max: TopbarSettingsMaxAggregateOutputType | null
  }

  export type TopbarSettingsMinAggregateOutputType = {
    id: string | null
    isEnabled: boolean | null
    phone: string | null
    email: string | null
    announcement: string | null
    showLanguage: boolean | null
    showSocial: boolean | null
    socialLinks: string | null
    backgroundColor: string | null
    textColor: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TopbarSettingsMaxAggregateOutputType = {
    id: string | null
    isEnabled: boolean | null
    phone: string | null
    email: string | null
    announcement: string | null
    showLanguage: boolean | null
    showSocial: boolean | null
    socialLinks: string | null
    backgroundColor: string | null
    textColor: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type TopbarSettingsCountAggregateOutputType = {
    id: number
    isEnabled: number
    phone: number
    email: number
    announcement: number
    showLanguage: number
    showSocial: number
    socialLinks: number
    backgroundColor: number
    textColor: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type TopbarSettingsMinAggregateInputType = {
    id?: true
    isEnabled?: true
    phone?: true
    email?: true
    announcement?: true
    showLanguage?: true
    showSocial?: true
    socialLinks?: true
    backgroundColor?: true
    textColor?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TopbarSettingsMaxAggregateInputType = {
    id?: true
    isEnabled?: true
    phone?: true
    email?: true
    announcement?: true
    showLanguage?: true
    showSocial?: true
    socialLinks?: true
    backgroundColor?: true
    textColor?: true
    updatedAt?: true
    createdAt?: true
  }

  export type TopbarSettingsCountAggregateInputType = {
    id?: true
    isEnabled?: true
    phone?: true
    email?: true
    announcement?: true
    showLanguage?: true
    showSocial?: true
    socialLinks?: true
    backgroundColor?: true
    textColor?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TopbarSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopbarSettings to aggregate.
     */
    where?: TopbarSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopbarSettings to fetch.
     */
    orderBy?: TopbarSettingsOrderByWithRelationInput | TopbarSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopbarSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopbarSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopbarSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopbarSettings
    **/
    _count?: true | TopbarSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopbarSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopbarSettingsMaxAggregateInputType
  }

  export type GetTopbarSettingsAggregateType<T extends TopbarSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTopbarSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopbarSettings[P]>
      : GetScalarType<T[P], AggregateTopbarSettings[P]>
  }




  export type TopbarSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopbarSettingsWhereInput
    orderBy?: TopbarSettingsOrderByWithAggregationInput | TopbarSettingsOrderByWithAggregationInput[]
    by: TopbarSettingsScalarFieldEnum[] | TopbarSettingsScalarFieldEnum
    having?: TopbarSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopbarSettingsCountAggregateInputType | true
    _min?: TopbarSettingsMinAggregateInputType
    _max?: TopbarSettingsMaxAggregateInputType
  }

  export type TopbarSettingsGroupByOutputType = {
    id: string
    isEnabled: boolean
    phone: string
    email: string
    announcement: string | null
    showLanguage: boolean
    showSocial: boolean
    socialLinks: string | null
    backgroundColor: string
    textColor: string
    updatedAt: Date
    createdAt: Date
    _count: TopbarSettingsCountAggregateOutputType | null
    _min: TopbarSettingsMinAggregateOutputType | null
    _max: TopbarSettingsMaxAggregateOutputType | null
  }

  type GetTopbarSettingsGroupByPayload<T extends TopbarSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopbarSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopbarSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopbarSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TopbarSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TopbarSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isEnabled?: boolean
    phone?: boolean
    email?: boolean
    announcement?: boolean
    showLanguage?: boolean
    showSocial?: boolean
    socialLinks?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["topbarSettings"]>



  export type TopbarSettingsSelectScalar = {
    id?: boolean
    isEnabled?: boolean
    phone?: boolean
    email?: boolean
    announcement?: boolean
    showLanguage?: boolean
    showSocial?: boolean
    socialLinks?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type TopbarSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isEnabled" | "phone" | "email" | "announcement" | "showLanguage" | "showSocial" | "socialLinks" | "backgroundColor" | "textColor" | "updatedAt" | "createdAt", ExtArgs["result"]["topbarSettings"]>

  export type $TopbarSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopbarSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isEnabled: boolean
      phone: string
      email: string
      announcement: string | null
      showLanguage: boolean
      showSocial: boolean
      socialLinks: string | null
      backgroundColor: string
      textColor: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["topbarSettings"]>
    composites: {}
  }

  type TopbarSettingsGetPayload<S extends boolean | null | undefined | TopbarSettingsDefaultArgs> = $Result.GetResult<Prisma.$TopbarSettingsPayload, S>

  type TopbarSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopbarSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopbarSettingsCountAggregateInputType | true
    }

  export interface TopbarSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopbarSettings'], meta: { name: 'TopbarSettings' } }
    /**
     * Find zero or one TopbarSettings that matches the filter.
     * @param {TopbarSettingsFindUniqueArgs} args - Arguments to find a TopbarSettings
     * @example
     * // Get one TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopbarSettingsFindUniqueArgs>(args: SelectSubset<T, TopbarSettingsFindUniqueArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TopbarSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopbarSettingsFindUniqueOrThrowArgs} args - Arguments to find a TopbarSettings
     * @example
     * // Get one TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopbarSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TopbarSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopbarSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsFindFirstArgs} args - Arguments to find a TopbarSettings
     * @example
     * // Get one TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopbarSettingsFindFirstArgs>(args?: SelectSubset<T, TopbarSettingsFindFirstArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopbarSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsFindFirstOrThrowArgs} args - Arguments to find a TopbarSettings
     * @example
     * // Get one TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopbarSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TopbarSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TopbarSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.findMany()
     * 
     * // Get first 10 TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topbarSettingsWithIdOnly = await prisma.topbarSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopbarSettingsFindManyArgs>(args?: SelectSubset<T, TopbarSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TopbarSettings.
     * @param {TopbarSettingsCreateArgs} args - Arguments to create a TopbarSettings.
     * @example
     * // Create one TopbarSettings
     * const TopbarSettings = await prisma.topbarSettings.create({
     *   data: {
     *     // ... data to create a TopbarSettings
     *   }
     * })
     * 
     */
    create<T extends TopbarSettingsCreateArgs>(args: SelectSubset<T, TopbarSettingsCreateArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TopbarSettings.
     * @param {TopbarSettingsCreateManyArgs} args - Arguments to create many TopbarSettings.
     * @example
     * // Create many TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopbarSettingsCreateManyArgs>(args?: SelectSubset<T, TopbarSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TopbarSettings.
     * @param {TopbarSettingsDeleteArgs} args - Arguments to delete one TopbarSettings.
     * @example
     * // Delete one TopbarSettings
     * const TopbarSettings = await prisma.topbarSettings.delete({
     *   where: {
     *     // ... filter to delete one TopbarSettings
     *   }
     * })
     * 
     */
    delete<T extends TopbarSettingsDeleteArgs>(args: SelectSubset<T, TopbarSettingsDeleteArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TopbarSettings.
     * @param {TopbarSettingsUpdateArgs} args - Arguments to update one TopbarSettings.
     * @example
     * // Update one TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopbarSettingsUpdateArgs>(args: SelectSubset<T, TopbarSettingsUpdateArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TopbarSettings.
     * @param {TopbarSettingsDeleteManyArgs} args - Arguments to filter TopbarSettings to delete.
     * @example
     * // Delete a few TopbarSettings
     * const { count } = await prisma.topbarSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopbarSettingsDeleteManyArgs>(args?: SelectSubset<T, TopbarSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopbarSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopbarSettingsUpdateManyArgs>(args: SelectSubset<T, TopbarSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TopbarSettings.
     * @param {TopbarSettingsUpsertArgs} args - Arguments to update or create a TopbarSettings.
     * @example
     * // Update or create a TopbarSettings
     * const topbarSettings = await prisma.topbarSettings.upsert({
     *   create: {
     *     // ... data to create a TopbarSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopbarSettings we want to update
     *   }
     * })
     */
    upsert<T extends TopbarSettingsUpsertArgs>(args: SelectSubset<T, TopbarSettingsUpsertArgs<ExtArgs>>): Prisma__TopbarSettingsClient<$Result.GetResult<Prisma.$TopbarSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TopbarSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsCountArgs} args - Arguments to filter TopbarSettings to count.
     * @example
     * // Count the number of TopbarSettings
     * const count = await prisma.topbarSettings.count({
     *   where: {
     *     // ... the filter for the TopbarSettings we want to count
     *   }
     * })
    **/
    count<T extends TopbarSettingsCountArgs>(
      args?: Subset<T, TopbarSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopbarSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopbarSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopbarSettingsAggregateArgs>(args: Subset<T, TopbarSettingsAggregateArgs>): Prisma.PrismaPromise<GetTopbarSettingsAggregateType<T>>

    /**
     * Group by TopbarSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopbarSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopbarSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopbarSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TopbarSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopbarSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopbarSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopbarSettings model
   */
  readonly fields: TopbarSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopbarSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopbarSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopbarSettings model
   */
  interface TopbarSettingsFieldRefs {
    readonly id: FieldRef<"TopbarSettings", 'String'>
    readonly isEnabled: FieldRef<"TopbarSettings", 'Boolean'>
    readonly phone: FieldRef<"TopbarSettings", 'String'>
    readonly email: FieldRef<"TopbarSettings", 'String'>
    readonly announcement: FieldRef<"TopbarSettings", 'String'>
    readonly showLanguage: FieldRef<"TopbarSettings", 'Boolean'>
    readonly showSocial: FieldRef<"TopbarSettings", 'Boolean'>
    readonly socialLinks: FieldRef<"TopbarSettings", 'String'>
    readonly backgroundColor: FieldRef<"TopbarSettings", 'String'>
    readonly textColor: FieldRef<"TopbarSettings", 'String'>
    readonly updatedAt: FieldRef<"TopbarSettings", 'DateTime'>
    readonly createdAt: FieldRef<"TopbarSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TopbarSettings findUnique
   */
  export type TopbarSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TopbarSettings to fetch.
     */
    where: TopbarSettingsWhereUniqueInput
  }

  /**
   * TopbarSettings findUniqueOrThrow
   */
  export type TopbarSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TopbarSettings to fetch.
     */
    where: TopbarSettingsWhereUniqueInput
  }

  /**
   * TopbarSettings findFirst
   */
  export type TopbarSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TopbarSettings to fetch.
     */
    where?: TopbarSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopbarSettings to fetch.
     */
    orderBy?: TopbarSettingsOrderByWithRelationInput | TopbarSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopbarSettings.
     */
    cursor?: TopbarSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopbarSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopbarSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopbarSettings.
     */
    distinct?: TopbarSettingsScalarFieldEnum | TopbarSettingsScalarFieldEnum[]
  }

  /**
   * TopbarSettings findFirstOrThrow
   */
  export type TopbarSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TopbarSettings to fetch.
     */
    where?: TopbarSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopbarSettings to fetch.
     */
    orderBy?: TopbarSettingsOrderByWithRelationInput | TopbarSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopbarSettings.
     */
    cursor?: TopbarSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopbarSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopbarSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopbarSettings.
     */
    distinct?: TopbarSettingsScalarFieldEnum | TopbarSettingsScalarFieldEnum[]
  }

  /**
   * TopbarSettings findMany
   */
  export type TopbarSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * Filter, which TopbarSettings to fetch.
     */
    where?: TopbarSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopbarSettings to fetch.
     */
    orderBy?: TopbarSettingsOrderByWithRelationInput | TopbarSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopbarSettings.
     */
    cursor?: TopbarSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopbarSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopbarSettings.
     */
    skip?: number
    distinct?: TopbarSettingsScalarFieldEnum | TopbarSettingsScalarFieldEnum[]
  }

  /**
   * TopbarSettings create
   */
  export type TopbarSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a TopbarSettings.
     */
    data: XOR<TopbarSettingsCreateInput, TopbarSettingsUncheckedCreateInput>
  }

  /**
   * TopbarSettings createMany
   */
  export type TopbarSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopbarSettings.
     */
    data: TopbarSettingsCreateManyInput | TopbarSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopbarSettings update
   */
  export type TopbarSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a TopbarSettings.
     */
    data: XOR<TopbarSettingsUpdateInput, TopbarSettingsUncheckedUpdateInput>
    /**
     * Choose, which TopbarSettings to update.
     */
    where: TopbarSettingsWhereUniqueInput
  }

  /**
   * TopbarSettings updateMany
   */
  export type TopbarSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopbarSettings.
     */
    data: XOR<TopbarSettingsUpdateManyMutationInput, TopbarSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TopbarSettings to update
     */
    where?: TopbarSettingsWhereInput
    /**
     * Limit how many TopbarSettings to update.
     */
    limit?: number
  }

  /**
   * TopbarSettings upsert
   */
  export type TopbarSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the TopbarSettings to update in case it exists.
     */
    where: TopbarSettingsWhereUniqueInput
    /**
     * In case the TopbarSettings found by the `where` argument doesn't exist, create a new TopbarSettings with this data.
     */
    create: XOR<TopbarSettingsCreateInput, TopbarSettingsUncheckedCreateInput>
    /**
     * In case the TopbarSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopbarSettingsUpdateInput, TopbarSettingsUncheckedUpdateInput>
  }

  /**
   * TopbarSettings delete
   */
  export type TopbarSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
    /**
     * Filter which TopbarSettings to delete.
     */
    where: TopbarSettingsWhereUniqueInput
  }

  /**
   * TopbarSettings deleteMany
   */
  export type TopbarSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopbarSettings to delete
     */
    where?: TopbarSettingsWhereInput
    /**
     * Limit how many TopbarSettings to delete.
     */
    limit?: number
  }

  /**
   * TopbarSettings without action
   */
  export type TopbarSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopbarSettings
     */
    select?: TopbarSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopbarSettings
     */
    omit?: TopbarSettingsOmit<ExtArgs> | null
  }


  /**
   * Model MobileMenuSettings
   */

  export type AggregateMobileMenuSettings = {
    _count: MobileMenuSettingsCountAggregateOutputType | null
    _min: MobileMenuSettingsMinAggregateOutputType | null
    _max: MobileMenuSettingsMaxAggregateOutputType | null
  }

  export type MobileMenuSettingsMinAggregateOutputType = {
    id: string | null
    menuType: string | null
    position: string | null
    animation: string | null
    backgroundColor: string | null
    textColor: string | null
    iconColor: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MobileMenuSettingsMaxAggregateOutputType = {
    id: string | null
    menuType: string | null
    position: string | null
    animation: string | null
    backgroundColor: string | null
    textColor: string | null
    iconColor: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MobileMenuSettingsCountAggregateOutputType = {
    id: number
    menuType: number
    position: number
    animation: number
    backgroundColor: number
    textColor: number
    iconColor: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type MobileMenuSettingsMinAggregateInputType = {
    id?: true
    menuType?: true
    position?: true
    animation?: true
    backgroundColor?: true
    textColor?: true
    iconColor?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MobileMenuSettingsMaxAggregateInputType = {
    id?: true
    menuType?: true
    position?: true
    animation?: true
    backgroundColor?: true
    textColor?: true
    iconColor?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MobileMenuSettingsCountAggregateInputType = {
    id?: true
    menuType?: true
    position?: true
    animation?: true
    backgroundColor?: true
    textColor?: true
    iconColor?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MobileMenuSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileMenuSettings to aggregate.
     */
    where?: MobileMenuSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileMenuSettings to fetch.
     */
    orderBy?: MobileMenuSettingsOrderByWithRelationInput | MobileMenuSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobileMenuSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileMenuSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileMenuSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobileMenuSettings
    **/
    _count?: true | MobileMenuSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobileMenuSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobileMenuSettingsMaxAggregateInputType
  }

  export type GetMobileMenuSettingsAggregateType<T extends MobileMenuSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateMobileMenuSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobileMenuSettings[P]>
      : GetScalarType<T[P], AggregateMobileMenuSettings[P]>
  }




  export type MobileMenuSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobileMenuSettingsWhereInput
    orderBy?: MobileMenuSettingsOrderByWithAggregationInput | MobileMenuSettingsOrderByWithAggregationInput[]
    by: MobileMenuSettingsScalarFieldEnum[] | MobileMenuSettingsScalarFieldEnum
    having?: MobileMenuSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobileMenuSettingsCountAggregateInputType | true
    _min?: MobileMenuSettingsMinAggregateInputType
    _max?: MobileMenuSettingsMaxAggregateInputType
  }

  export type MobileMenuSettingsGroupByOutputType = {
    id: string
    menuType: string
    position: string
    animation: string
    backgroundColor: string
    textColor: string
    iconColor: string
    updatedAt: Date
    createdAt: Date
    _count: MobileMenuSettingsCountAggregateOutputType | null
    _min: MobileMenuSettingsMinAggregateOutputType | null
    _max: MobileMenuSettingsMaxAggregateOutputType | null
  }

  type GetMobileMenuSettingsGroupByPayload<T extends MobileMenuSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobileMenuSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobileMenuSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobileMenuSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], MobileMenuSettingsGroupByOutputType[P]>
        }
      >
    >


  export type MobileMenuSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuType?: boolean
    position?: boolean
    animation?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    iconColor?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mobileMenuSettings"]>



  export type MobileMenuSettingsSelectScalar = {
    id?: boolean
    menuType?: boolean
    position?: boolean
    animation?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    iconColor?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type MobileMenuSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuType" | "position" | "animation" | "backgroundColor" | "textColor" | "iconColor" | "updatedAt" | "createdAt", ExtArgs["result"]["mobileMenuSettings"]>

  export type $MobileMenuSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobileMenuSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      menuType: string
      position: string
      animation: string
      backgroundColor: string
      textColor: string
      iconColor: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["mobileMenuSettings"]>
    composites: {}
  }

  type MobileMenuSettingsGetPayload<S extends boolean | null | undefined | MobileMenuSettingsDefaultArgs> = $Result.GetResult<Prisma.$MobileMenuSettingsPayload, S>

  type MobileMenuSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MobileMenuSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MobileMenuSettingsCountAggregateInputType | true
    }

  export interface MobileMenuSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobileMenuSettings'], meta: { name: 'MobileMenuSettings' } }
    /**
     * Find zero or one MobileMenuSettings that matches the filter.
     * @param {MobileMenuSettingsFindUniqueArgs} args - Arguments to find a MobileMenuSettings
     * @example
     * // Get one MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MobileMenuSettingsFindUniqueArgs>(args: SelectSubset<T, MobileMenuSettingsFindUniqueArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MobileMenuSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MobileMenuSettingsFindUniqueOrThrowArgs} args - Arguments to find a MobileMenuSettings
     * @example
     * // Get one MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MobileMenuSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, MobileMenuSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MobileMenuSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsFindFirstArgs} args - Arguments to find a MobileMenuSettings
     * @example
     * // Get one MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MobileMenuSettingsFindFirstArgs>(args?: SelectSubset<T, MobileMenuSettingsFindFirstArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MobileMenuSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsFindFirstOrThrowArgs} args - Arguments to find a MobileMenuSettings
     * @example
     * // Get one MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MobileMenuSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, MobileMenuSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MobileMenuSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.findMany()
     * 
     * // Get first 10 MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mobileMenuSettingsWithIdOnly = await prisma.mobileMenuSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MobileMenuSettingsFindManyArgs>(args?: SelectSubset<T, MobileMenuSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MobileMenuSettings.
     * @param {MobileMenuSettingsCreateArgs} args - Arguments to create a MobileMenuSettings.
     * @example
     * // Create one MobileMenuSettings
     * const MobileMenuSettings = await prisma.mobileMenuSettings.create({
     *   data: {
     *     // ... data to create a MobileMenuSettings
     *   }
     * })
     * 
     */
    create<T extends MobileMenuSettingsCreateArgs>(args: SelectSubset<T, MobileMenuSettingsCreateArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MobileMenuSettings.
     * @param {MobileMenuSettingsCreateManyArgs} args - Arguments to create many MobileMenuSettings.
     * @example
     * // Create many MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MobileMenuSettingsCreateManyArgs>(args?: SelectSubset<T, MobileMenuSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MobileMenuSettings.
     * @param {MobileMenuSettingsDeleteArgs} args - Arguments to delete one MobileMenuSettings.
     * @example
     * // Delete one MobileMenuSettings
     * const MobileMenuSettings = await prisma.mobileMenuSettings.delete({
     *   where: {
     *     // ... filter to delete one MobileMenuSettings
     *   }
     * })
     * 
     */
    delete<T extends MobileMenuSettingsDeleteArgs>(args: SelectSubset<T, MobileMenuSettingsDeleteArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MobileMenuSettings.
     * @param {MobileMenuSettingsUpdateArgs} args - Arguments to update one MobileMenuSettings.
     * @example
     * // Update one MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MobileMenuSettingsUpdateArgs>(args: SelectSubset<T, MobileMenuSettingsUpdateArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MobileMenuSettings.
     * @param {MobileMenuSettingsDeleteManyArgs} args - Arguments to filter MobileMenuSettings to delete.
     * @example
     * // Delete a few MobileMenuSettings
     * const { count } = await prisma.mobileMenuSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MobileMenuSettingsDeleteManyArgs>(args?: SelectSubset<T, MobileMenuSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobileMenuSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MobileMenuSettingsUpdateManyArgs>(args: SelectSubset<T, MobileMenuSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobileMenuSettings.
     * @param {MobileMenuSettingsUpsertArgs} args - Arguments to update or create a MobileMenuSettings.
     * @example
     * // Update or create a MobileMenuSettings
     * const mobileMenuSettings = await prisma.mobileMenuSettings.upsert({
     *   create: {
     *     // ... data to create a MobileMenuSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobileMenuSettings we want to update
     *   }
     * })
     */
    upsert<T extends MobileMenuSettingsUpsertArgs>(args: SelectSubset<T, MobileMenuSettingsUpsertArgs<ExtArgs>>): Prisma__MobileMenuSettingsClient<$Result.GetResult<Prisma.$MobileMenuSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MobileMenuSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsCountArgs} args - Arguments to filter MobileMenuSettings to count.
     * @example
     * // Count the number of MobileMenuSettings
     * const count = await prisma.mobileMenuSettings.count({
     *   where: {
     *     // ... the filter for the MobileMenuSettings we want to count
     *   }
     * })
    **/
    count<T extends MobileMenuSettingsCountArgs>(
      args?: Subset<T, MobileMenuSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobileMenuSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobileMenuSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobileMenuSettingsAggregateArgs>(args: Subset<T, MobileMenuSettingsAggregateArgs>): Prisma.PrismaPromise<GetMobileMenuSettingsAggregateType<T>>

    /**
     * Group by MobileMenuSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileMenuSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobileMenuSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobileMenuSettingsGroupByArgs['orderBy'] }
        : { orderBy?: MobileMenuSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobileMenuSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobileMenuSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobileMenuSettings model
   */
  readonly fields: MobileMenuSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobileMenuSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobileMenuSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MobileMenuSettings model
   */
  interface MobileMenuSettingsFieldRefs {
    readonly id: FieldRef<"MobileMenuSettings", 'String'>
    readonly menuType: FieldRef<"MobileMenuSettings", 'String'>
    readonly position: FieldRef<"MobileMenuSettings", 'String'>
    readonly animation: FieldRef<"MobileMenuSettings", 'String'>
    readonly backgroundColor: FieldRef<"MobileMenuSettings", 'String'>
    readonly textColor: FieldRef<"MobileMenuSettings", 'String'>
    readonly iconColor: FieldRef<"MobileMenuSettings", 'String'>
    readonly updatedAt: FieldRef<"MobileMenuSettings", 'DateTime'>
    readonly createdAt: FieldRef<"MobileMenuSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MobileMenuSettings findUnique
   */
  export type MobileMenuSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * Filter, which MobileMenuSettings to fetch.
     */
    where: MobileMenuSettingsWhereUniqueInput
  }

  /**
   * MobileMenuSettings findUniqueOrThrow
   */
  export type MobileMenuSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * Filter, which MobileMenuSettings to fetch.
     */
    where: MobileMenuSettingsWhereUniqueInput
  }

  /**
   * MobileMenuSettings findFirst
   */
  export type MobileMenuSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * Filter, which MobileMenuSettings to fetch.
     */
    where?: MobileMenuSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileMenuSettings to fetch.
     */
    orderBy?: MobileMenuSettingsOrderByWithRelationInput | MobileMenuSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileMenuSettings.
     */
    cursor?: MobileMenuSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileMenuSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileMenuSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileMenuSettings.
     */
    distinct?: MobileMenuSettingsScalarFieldEnum | MobileMenuSettingsScalarFieldEnum[]
  }

  /**
   * MobileMenuSettings findFirstOrThrow
   */
  export type MobileMenuSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * Filter, which MobileMenuSettings to fetch.
     */
    where?: MobileMenuSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileMenuSettings to fetch.
     */
    orderBy?: MobileMenuSettingsOrderByWithRelationInput | MobileMenuSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileMenuSettings.
     */
    cursor?: MobileMenuSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileMenuSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileMenuSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileMenuSettings.
     */
    distinct?: MobileMenuSettingsScalarFieldEnum | MobileMenuSettingsScalarFieldEnum[]
  }

  /**
   * MobileMenuSettings findMany
   */
  export type MobileMenuSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * Filter, which MobileMenuSettings to fetch.
     */
    where?: MobileMenuSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileMenuSettings to fetch.
     */
    orderBy?: MobileMenuSettingsOrderByWithRelationInput | MobileMenuSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobileMenuSettings.
     */
    cursor?: MobileMenuSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileMenuSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileMenuSettings.
     */
    skip?: number
    distinct?: MobileMenuSettingsScalarFieldEnum | MobileMenuSettingsScalarFieldEnum[]
  }

  /**
   * MobileMenuSettings create
   */
  export type MobileMenuSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a MobileMenuSettings.
     */
    data: XOR<MobileMenuSettingsCreateInput, MobileMenuSettingsUncheckedCreateInput>
  }

  /**
   * MobileMenuSettings createMany
   */
  export type MobileMenuSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobileMenuSettings.
     */
    data: MobileMenuSettingsCreateManyInput | MobileMenuSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MobileMenuSettings update
   */
  export type MobileMenuSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a MobileMenuSettings.
     */
    data: XOR<MobileMenuSettingsUpdateInput, MobileMenuSettingsUncheckedUpdateInput>
    /**
     * Choose, which MobileMenuSettings to update.
     */
    where: MobileMenuSettingsWhereUniqueInput
  }

  /**
   * MobileMenuSettings updateMany
   */
  export type MobileMenuSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobileMenuSettings.
     */
    data: XOR<MobileMenuSettingsUpdateManyMutationInput, MobileMenuSettingsUncheckedUpdateManyInput>
    /**
     * Filter which MobileMenuSettings to update
     */
    where?: MobileMenuSettingsWhereInput
    /**
     * Limit how many MobileMenuSettings to update.
     */
    limit?: number
  }

  /**
   * MobileMenuSettings upsert
   */
  export type MobileMenuSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the MobileMenuSettings to update in case it exists.
     */
    where: MobileMenuSettingsWhereUniqueInput
    /**
     * In case the MobileMenuSettings found by the `where` argument doesn't exist, create a new MobileMenuSettings with this data.
     */
    create: XOR<MobileMenuSettingsCreateInput, MobileMenuSettingsUncheckedCreateInput>
    /**
     * In case the MobileMenuSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobileMenuSettingsUpdateInput, MobileMenuSettingsUncheckedUpdateInput>
  }

  /**
   * MobileMenuSettings delete
   */
  export type MobileMenuSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
    /**
     * Filter which MobileMenuSettings to delete.
     */
    where: MobileMenuSettingsWhereUniqueInput
  }

  /**
   * MobileMenuSettings deleteMany
   */
  export type MobileMenuSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileMenuSettings to delete
     */
    where?: MobileMenuSettingsWhereInput
    /**
     * Limit how many MobileMenuSettings to delete.
     */
    limit?: number
  }

  /**
   * MobileMenuSettings without action
   */
  export type MobileMenuSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileMenuSettings
     */
    select?: MobileMenuSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileMenuSettings
     */
    omit?: MobileMenuSettingsOmit<ExtArgs> | null
  }


  /**
   * Model LanguageSettings
   */

  export type AggregateLanguageSettings = {
    _count: LanguageSettingsCountAggregateOutputType | null
    _min: LanguageSettingsMinAggregateOutputType | null
    _max: LanguageSettingsMaxAggregateOutputType | null
  }

  export type LanguageSettingsMinAggregateOutputType = {
    id: string | null
    defaultLanguage: string | null
    supportedLanguages: string | null
    showLanguageSwitcher: boolean | null
    languageSwitcherPosition: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LanguageSettingsMaxAggregateOutputType = {
    id: string | null
    defaultLanguage: string | null
    supportedLanguages: string | null
    showLanguageSwitcher: boolean | null
    languageSwitcherPosition: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LanguageSettingsCountAggregateOutputType = {
    id: number
    defaultLanguage: number
    supportedLanguages: number
    showLanguageSwitcher: number
    languageSwitcherPosition: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type LanguageSettingsMinAggregateInputType = {
    id?: true
    defaultLanguage?: true
    supportedLanguages?: true
    showLanguageSwitcher?: true
    languageSwitcherPosition?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LanguageSettingsMaxAggregateInputType = {
    id?: true
    defaultLanguage?: true
    supportedLanguages?: true
    showLanguageSwitcher?: true
    languageSwitcherPosition?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LanguageSettingsCountAggregateInputType = {
    id?: true
    defaultLanguage?: true
    supportedLanguages?: true
    showLanguageSwitcher?: true
    languageSwitcherPosition?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LanguageSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageSettings to aggregate.
     */
    where?: LanguageSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSettings to fetch.
     */
    orderBy?: LanguageSettingsOrderByWithRelationInput | LanguageSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LanguageSettings
    **/
    _count?: true | LanguageSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageSettingsMaxAggregateInputType
  }

  export type GetLanguageSettingsAggregateType<T extends LanguageSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguageSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguageSettings[P]>
      : GetScalarType<T[P], AggregateLanguageSettings[P]>
  }




  export type LanguageSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageSettingsWhereInput
    orderBy?: LanguageSettingsOrderByWithAggregationInput | LanguageSettingsOrderByWithAggregationInput[]
    by: LanguageSettingsScalarFieldEnum[] | LanguageSettingsScalarFieldEnum
    having?: LanguageSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageSettingsCountAggregateInputType | true
    _min?: LanguageSettingsMinAggregateInputType
    _max?: LanguageSettingsMaxAggregateInputType
  }

  export type LanguageSettingsGroupByOutputType = {
    id: string
    defaultLanguage: string
    supportedLanguages: string | null
    showLanguageSwitcher: boolean
    languageSwitcherPosition: string
    updatedAt: Date
    createdAt: Date
    _count: LanguageSettingsCountAggregateOutputType | null
    _min: LanguageSettingsMinAggregateOutputType | null
    _max: LanguageSettingsMaxAggregateOutputType | null
  }

  type GetLanguageSettingsGroupByPayload<T extends LanguageSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageSettingsGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultLanguage?: boolean
    supportedLanguages?: boolean
    showLanguageSwitcher?: boolean
    languageSwitcherPosition?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["languageSettings"]>



  export type LanguageSettingsSelectScalar = {
    id?: boolean
    defaultLanguage?: boolean
    supportedLanguages?: boolean
    showLanguageSwitcher?: boolean
    languageSwitcherPosition?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type LanguageSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "defaultLanguage" | "supportedLanguages" | "showLanguageSwitcher" | "languageSwitcherPosition" | "updatedAt" | "createdAt", ExtArgs["result"]["languageSettings"]>

  export type $LanguageSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LanguageSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defaultLanguage: string
      supportedLanguages: string | null
      showLanguageSwitcher: boolean
      languageSwitcherPosition: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["languageSettings"]>
    composites: {}
  }

  type LanguageSettingsGetPayload<S extends boolean | null | undefined | LanguageSettingsDefaultArgs> = $Result.GetResult<Prisma.$LanguageSettingsPayload, S>

  type LanguageSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageSettingsCountAggregateInputType | true
    }

  export interface LanguageSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LanguageSettings'], meta: { name: 'LanguageSettings' } }
    /**
     * Find zero or one LanguageSettings that matches the filter.
     * @param {LanguageSettingsFindUniqueArgs} args - Arguments to find a LanguageSettings
     * @example
     * // Get one LanguageSettings
     * const languageSettings = await prisma.languageSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageSettingsFindUniqueArgs>(args: SelectSubset<T, LanguageSettingsFindUniqueArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LanguageSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageSettingsFindUniqueOrThrowArgs} args - Arguments to find a LanguageSettings
     * @example
     * // Get one LanguageSettings
     * const languageSettings = await prisma.languageSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsFindFirstArgs} args - Arguments to find a LanguageSettings
     * @example
     * // Get one LanguageSettings
     * const languageSettings = await prisma.languageSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageSettingsFindFirstArgs>(args?: SelectSubset<T, LanguageSettingsFindFirstArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LanguageSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsFindFirstOrThrowArgs} args - Arguments to find a LanguageSettings
     * @example
     * // Get one LanguageSettings
     * const languageSettings = await prisma.languageSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LanguageSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LanguageSettings
     * const languageSettings = await prisma.languageSettings.findMany()
     * 
     * // Get first 10 LanguageSettings
     * const languageSettings = await prisma.languageSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageSettingsWithIdOnly = await prisma.languageSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageSettingsFindManyArgs>(args?: SelectSubset<T, LanguageSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LanguageSettings.
     * @param {LanguageSettingsCreateArgs} args - Arguments to create a LanguageSettings.
     * @example
     * // Create one LanguageSettings
     * const LanguageSettings = await prisma.languageSettings.create({
     *   data: {
     *     // ... data to create a LanguageSettings
     *   }
     * })
     * 
     */
    create<T extends LanguageSettingsCreateArgs>(args: SelectSubset<T, LanguageSettingsCreateArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LanguageSettings.
     * @param {LanguageSettingsCreateManyArgs} args - Arguments to create many LanguageSettings.
     * @example
     * // Create many LanguageSettings
     * const languageSettings = await prisma.languageSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageSettingsCreateManyArgs>(args?: SelectSubset<T, LanguageSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LanguageSettings.
     * @param {LanguageSettingsDeleteArgs} args - Arguments to delete one LanguageSettings.
     * @example
     * // Delete one LanguageSettings
     * const LanguageSettings = await prisma.languageSettings.delete({
     *   where: {
     *     // ... filter to delete one LanguageSettings
     *   }
     * })
     * 
     */
    delete<T extends LanguageSettingsDeleteArgs>(args: SelectSubset<T, LanguageSettingsDeleteArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LanguageSettings.
     * @param {LanguageSettingsUpdateArgs} args - Arguments to update one LanguageSettings.
     * @example
     * // Update one LanguageSettings
     * const languageSettings = await prisma.languageSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageSettingsUpdateArgs>(args: SelectSubset<T, LanguageSettingsUpdateArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LanguageSettings.
     * @param {LanguageSettingsDeleteManyArgs} args - Arguments to filter LanguageSettings to delete.
     * @example
     * // Delete a few LanguageSettings
     * const { count } = await prisma.languageSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageSettingsDeleteManyArgs>(args?: SelectSubset<T, LanguageSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LanguageSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LanguageSettings
     * const languageSettings = await prisma.languageSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageSettingsUpdateManyArgs>(args: SelectSubset<T, LanguageSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LanguageSettings.
     * @param {LanguageSettingsUpsertArgs} args - Arguments to update or create a LanguageSettings.
     * @example
     * // Update or create a LanguageSettings
     * const languageSettings = await prisma.languageSettings.upsert({
     *   create: {
     *     // ... data to create a LanguageSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LanguageSettings we want to update
     *   }
     * })
     */
    upsert<T extends LanguageSettingsUpsertArgs>(args: SelectSubset<T, LanguageSettingsUpsertArgs<ExtArgs>>): Prisma__LanguageSettingsClient<$Result.GetResult<Prisma.$LanguageSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LanguageSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsCountArgs} args - Arguments to filter LanguageSettings to count.
     * @example
     * // Count the number of LanguageSettings
     * const count = await prisma.languageSettings.count({
     *   where: {
     *     // ... the filter for the LanguageSettings we want to count
     *   }
     * })
    **/
    count<T extends LanguageSettingsCountArgs>(
      args?: Subset<T, LanguageSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LanguageSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageSettingsAggregateArgs>(args: Subset<T, LanguageSettingsAggregateArgs>): Prisma.PrismaPromise<GetLanguageSettingsAggregateType<T>>

    /**
     * Group by LanguageSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageSettingsGroupByArgs['orderBy'] }
        : { orderBy?: LanguageSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LanguageSettings model
   */
  readonly fields: LanguageSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LanguageSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LanguageSettings model
   */
  interface LanguageSettingsFieldRefs {
    readonly id: FieldRef<"LanguageSettings", 'String'>
    readonly defaultLanguage: FieldRef<"LanguageSettings", 'String'>
    readonly supportedLanguages: FieldRef<"LanguageSettings", 'String'>
    readonly showLanguageSwitcher: FieldRef<"LanguageSettings", 'Boolean'>
    readonly languageSwitcherPosition: FieldRef<"LanguageSettings", 'String'>
    readonly updatedAt: FieldRef<"LanguageSettings", 'DateTime'>
    readonly createdAt: FieldRef<"LanguageSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LanguageSettings findUnique
   */
  export type LanguageSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LanguageSettings to fetch.
     */
    where: LanguageSettingsWhereUniqueInput
  }

  /**
   * LanguageSettings findUniqueOrThrow
   */
  export type LanguageSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LanguageSettings to fetch.
     */
    where: LanguageSettingsWhereUniqueInput
  }

  /**
   * LanguageSettings findFirst
   */
  export type LanguageSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LanguageSettings to fetch.
     */
    where?: LanguageSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSettings to fetch.
     */
    orderBy?: LanguageSettingsOrderByWithRelationInput | LanguageSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageSettings.
     */
    cursor?: LanguageSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageSettings.
     */
    distinct?: LanguageSettingsScalarFieldEnum | LanguageSettingsScalarFieldEnum[]
  }

  /**
   * LanguageSettings findFirstOrThrow
   */
  export type LanguageSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LanguageSettings to fetch.
     */
    where?: LanguageSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSettings to fetch.
     */
    orderBy?: LanguageSettingsOrderByWithRelationInput | LanguageSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LanguageSettings.
     */
    cursor?: LanguageSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LanguageSettings.
     */
    distinct?: LanguageSettingsScalarFieldEnum | LanguageSettingsScalarFieldEnum[]
  }

  /**
   * LanguageSettings findMany
   */
  export type LanguageSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LanguageSettings to fetch.
     */
    where?: LanguageSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LanguageSettings to fetch.
     */
    orderBy?: LanguageSettingsOrderByWithRelationInput | LanguageSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LanguageSettings.
     */
    cursor?: LanguageSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LanguageSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LanguageSettings.
     */
    skip?: number
    distinct?: LanguageSettingsScalarFieldEnum | LanguageSettingsScalarFieldEnum[]
  }

  /**
   * LanguageSettings create
   */
  export type LanguageSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a LanguageSettings.
     */
    data: XOR<LanguageSettingsCreateInput, LanguageSettingsUncheckedCreateInput>
  }

  /**
   * LanguageSettings createMany
   */
  export type LanguageSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LanguageSettings.
     */
    data: LanguageSettingsCreateManyInput | LanguageSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LanguageSettings update
   */
  export type LanguageSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a LanguageSettings.
     */
    data: XOR<LanguageSettingsUpdateInput, LanguageSettingsUncheckedUpdateInput>
    /**
     * Choose, which LanguageSettings to update.
     */
    where: LanguageSettingsWhereUniqueInput
  }

  /**
   * LanguageSettings updateMany
   */
  export type LanguageSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LanguageSettings.
     */
    data: XOR<LanguageSettingsUpdateManyMutationInput, LanguageSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LanguageSettings to update
     */
    where?: LanguageSettingsWhereInput
    /**
     * Limit how many LanguageSettings to update.
     */
    limit?: number
  }

  /**
   * LanguageSettings upsert
   */
  export type LanguageSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the LanguageSettings to update in case it exists.
     */
    where: LanguageSettingsWhereUniqueInput
    /**
     * In case the LanguageSettings found by the `where` argument doesn't exist, create a new LanguageSettings with this data.
     */
    create: XOR<LanguageSettingsCreateInput, LanguageSettingsUncheckedCreateInput>
    /**
     * In case the LanguageSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageSettingsUpdateInput, LanguageSettingsUncheckedUpdateInput>
  }

  /**
   * LanguageSettings delete
   */
  export type LanguageSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
    /**
     * Filter which LanguageSettings to delete.
     */
    where: LanguageSettingsWhereUniqueInput
  }

  /**
   * LanguageSettings deleteMany
   */
  export type LanguageSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LanguageSettings to delete
     */
    where?: LanguageSettingsWhereInput
    /**
     * Limit how many LanguageSettings to delete.
     */
    limit?: number
  }

  /**
   * LanguageSettings without action
   */
  export type LanguageSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageSettings
     */
    select?: LanguageSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LanguageSettings
     */
    omit?: LanguageSettingsOmit<ExtArgs> | null
  }


  /**
   * Model CustomIcon
   */

  export type AggregateCustomIcon = {
    _count: CustomIconCountAggregateOutputType | null
    _min: CustomIconMinAggregateOutputType | null
    _max: CustomIconMaxAggregateOutputType | null
  }

  export type CustomIconMinAggregateOutputType = {
    id: string | null
    name: string | null
    svgContent: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomIconMaxAggregateOutputType = {
    id: string | null
    name: string | null
    svgContent: string | null
    category: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomIconCountAggregateOutputType = {
    id: number
    name: number
    svgContent: number
    category: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomIconMinAggregateInputType = {
    id?: true
    name?: true
    svgContent?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomIconMaxAggregateInputType = {
    id?: true
    name?: true
    svgContent?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomIconCountAggregateInputType = {
    id?: true
    name?: true
    svgContent?: true
    category?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomIconAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomIcon to aggregate.
     */
    where?: CustomIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomIcons to fetch.
     */
    orderBy?: CustomIconOrderByWithRelationInput | CustomIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomIcons
    **/
    _count?: true | CustomIconCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomIconMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomIconMaxAggregateInputType
  }

  export type GetCustomIconAggregateType<T extends CustomIconAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomIcon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomIcon[P]>
      : GetScalarType<T[P], AggregateCustomIcon[P]>
  }




  export type CustomIconGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomIconWhereInput
    orderBy?: CustomIconOrderByWithAggregationInput | CustomIconOrderByWithAggregationInput[]
    by: CustomIconScalarFieldEnum[] | CustomIconScalarFieldEnum
    having?: CustomIconScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomIconCountAggregateInputType | true
    _min?: CustomIconMinAggregateInputType
    _max?: CustomIconMaxAggregateInputType
  }

  export type CustomIconGroupByOutputType = {
    id: string
    name: string
    svgContent: string
    category: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomIconCountAggregateOutputType | null
    _min: CustomIconMinAggregateOutputType | null
    _max: CustomIconMaxAggregateOutputType | null
  }

  type GetCustomIconGroupByPayload<T extends CustomIconGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomIconGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomIconGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomIconGroupByOutputType[P]>
            : GetScalarType<T[P], CustomIconGroupByOutputType[P]>
        }
      >
    >


  export type CustomIconSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    svgContent?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customIcon"]>



  export type CustomIconSelectScalar = {
    id?: boolean
    name?: boolean
    svgContent?: boolean
    category?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomIconOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "svgContent" | "category" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customIcon"]>

  export type $CustomIconPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomIcon"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      svgContent: string
      category: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customIcon"]>
    composites: {}
  }

  type CustomIconGetPayload<S extends boolean | null | undefined | CustomIconDefaultArgs> = $Result.GetResult<Prisma.$CustomIconPayload, S>

  type CustomIconCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomIconFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomIconCountAggregateInputType | true
    }

  export interface CustomIconDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomIcon'], meta: { name: 'CustomIcon' } }
    /**
     * Find zero or one CustomIcon that matches the filter.
     * @param {CustomIconFindUniqueArgs} args - Arguments to find a CustomIcon
     * @example
     * // Get one CustomIcon
     * const customIcon = await prisma.customIcon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomIconFindUniqueArgs>(args: SelectSubset<T, CustomIconFindUniqueArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomIcon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomIconFindUniqueOrThrowArgs} args - Arguments to find a CustomIcon
     * @example
     * // Get one CustomIcon
     * const customIcon = await prisma.customIcon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomIconFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomIconFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomIcon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconFindFirstArgs} args - Arguments to find a CustomIcon
     * @example
     * // Get one CustomIcon
     * const customIcon = await prisma.customIcon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomIconFindFirstArgs>(args?: SelectSubset<T, CustomIconFindFirstArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomIcon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconFindFirstOrThrowArgs} args - Arguments to find a CustomIcon
     * @example
     * // Get one CustomIcon
     * const customIcon = await prisma.customIcon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomIconFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomIconFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomIcons
     * const customIcons = await prisma.customIcon.findMany()
     * 
     * // Get first 10 CustomIcons
     * const customIcons = await prisma.customIcon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customIconWithIdOnly = await prisma.customIcon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomIconFindManyArgs>(args?: SelectSubset<T, CustomIconFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomIcon.
     * @param {CustomIconCreateArgs} args - Arguments to create a CustomIcon.
     * @example
     * // Create one CustomIcon
     * const CustomIcon = await prisma.customIcon.create({
     *   data: {
     *     // ... data to create a CustomIcon
     *   }
     * })
     * 
     */
    create<T extends CustomIconCreateArgs>(args: SelectSubset<T, CustomIconCreateArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomIcons.
     * @param {CustomIconCreateManyArgs} args - Arguments to create many CustomIcons.
     * @example
     * // Create many CustomIcons
     * const customIcon = await prisma.customIcon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomIconCreateManyArgs>(args?: SelectSubset<T, CustomIconCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomIcon.
     * @param {CustomIconDeleteArgs} args - Arguments to delete one CustomIcon.
     * @example
     * // Delete one CustomIcon
     * const CustomIcon = await prisma.customIcon.delete({
     *   where: {
     *     // ... filter to delete one CustomIcon
     *   }
     * })
     * 
     */
    delete<T extends CustomIconDeleteArgs>(args: SelectSubset<T, CustomIconDeleteArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomIcon.
     * @param {CustomIconUpdateArgs} args - Arguments to update one CustomIcon.
     * @example
     * // Update one CustomIcon
     * const customIcon = await prisma.customIcon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomIconUpdateArgs>(args: SelectSubset<T, CustomIconUpdateArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomIcons.
     * @param {CustomIconDeleteManyArgs} args - Arguments to filter CustomIcons to delete.
     * @example
     * // Delete a few CustomIcons
     * const { count } = await prisma.customIcon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomIconDeleteManyArgs>(args?: SelectSubset<T, CustomIconDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomIcons
     * const customIcon = await prisma.customIcon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomIconUpdateManyArgs>(args: SelectSubset<T, CustomIconUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomIcon.
     * @param {CustomIconUpsertArgs} args - Arguments to update or create a CustomIcon.
     * @example
     * // Update or create a CustomIcon
     * const customIcon = await prisma.customIcon.upsert({
     *   create: {
     *     // ... data to create a CustomIcon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomIcon we want to update
     *   }
     * })
     */
    upsert<T extends CustomIconUpsertArgs>(args: SelectSubset<T, CustomIconUpsertArgs<ExtArgs>>): Prisma__CustomIconClient<$Result.GetResult<Prisma.$CustomIconPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconCountArgs} args - Arguments to filter CustomIcons to count.
     * @example
     * // Count the number of CustomIcons
     * const count = await prisma.customIcon.count({
     *   where: {
     *     // ... the filter for the CustomIcons we want to count
     *   }
     * })
    **/
    count<T extends CustomIconCountArgs>(
      args?: Subset<T, CustomIconCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomIconCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomIcon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomIconAggregateArgs>(args: Subset<T, CustomIconAggregateArgs>): Prisma.PrismaPromise<GetCustomIconAggregateType<T>>

    /**
     * Group by CustomIcon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomIconGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomIconGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomIconGroupByArgs['orderBy'] }
        : { orderBy?: CustomIconGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomIconGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomIconGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomIcon model
   */
  readonly fields: CustomIconFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomIcon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomIconClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomIcon model
   */
  interface CustomIconFieldRefs {
    readonly id: FieldRef<"CustomIcon", 'String'>
    readonly name: FieldRef<"CustomIcon", 'String'>
    readonly svgContent: FieldRef<"CustomIcon", 'String'>
    readonly category: FieldRef<"CustomIcon", 'String'>
    readonly isActive: FieldRef<"CustomIcon", 'Boolean'>
    readonly createdAt: FieldRef<"CustomIcon", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomIcon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomIcon findUnique
   */
  export type CustomIconFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * Filter, which CustomIcon to fetch.
     */
    where: CustomIconWhereUniqueInput
  }

  /**
   * CustomIcon findUniqueOrThrow
   */
  export type CustomIconFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * Filter, which CustomIcon to fetch.
     */
    where: CustomIconWhereUniqueInput
  }

  /**
   * CustomIcon findFirst
   */
  export type CustomIconFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * Filter, which CustomIcon to fetch.
     */
    where?: CustomIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomIcons to fetch.
     */
    orderBy?: CustomIconOrderByWithRelationInput | CustomIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomIcons.
     */
    cursor?: CustomIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomIcons.
     */
    distinct?: CustomIconScalarFieldEnum | CustomIconScalarFieldEnum[]
  }

  /**
   * CustomIcon findFirstOrThrow
   */
  export type CustomIconFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * Filter, which CustomIcon to fetch.
     */
    where?: CustomIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomIcons to fetch.
     */
    orderBy?: CustomIconOrderByWithRelationInput | CustomIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomIcons.
     */
    cursor?: CustomIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomIcons.
     */
    distinct?: CustomIconScalarFieldEnum | CustomIconScalarFieldEnum[]
  }

  /**
   * CustomIcon findMany
   */
  export type CustomIconFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * Filter, which CustomIcons to fetch.
     */
    where?: CustomIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomIcons to fetch.
     */
    orderBy?: CustomIconOrderByWithRelationInput | CustomIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomIcons.
     */
    cursor?: CustomIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomIcons.
     */
    skip?: number
    distinct?: CustomIconScalarFieldEnum | CustomIconScalarFieldEnum[]
  }

  /**
   * CustomIcon create
   */
  export type CustomIconCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * The data needed to create a CustomIcon.
     */
    data: XOR<CustomIconCreateInput, CustomIconUncheckedCreateInput>
  }

  /**
   * CustomIcon createMany
   */
  export type CustomIconCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomIcons.
     */
    data: CustomIconCreateManyInput | CustomIconCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomIcon update
   */
  export type CustomIconUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * The data needed to update a CustomIcon.
     */
    data: XOR<CustomIconUpdateInput, CustomIconUncheckedUpdateInput>
    /**
     * Choose, which CustomIcon to update.
     */
    where: CustomIconWhereUniqueInput
  }

  /**
   * CustomIcon updateMany
   */
  export type CustomIconUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomIcons.
     */
    data: XOR<CustomIconUpdateManyMutationInput, CustomIconUncheckedUpdateManyInput>
    /**
     * Filter which CustomIcons to update
     */
    where?: CustomIconWhereInput
    /**
     * Limit how many CustomIcons to update.
     */
    limit?: number
  }

  /**
   * CustomIcon upsert
   */
  export type CustomIconUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * The filter to search for the CustomIcon to update in case it exists.
     */
    where: CustomIconWhereUniqueInput
    /**
     * In case the CustomIcon found by the `where` argument doesn't exist, create a new CustomIcon with this data.
     */
    create: XOR<CustomIconCreateInput, CustomIconUncheckedCreateInput>
    /**
     * In case the CustomIcon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomIconUpdateInput, CustomIconUncheckedUpdateInput>
  }

  /**
   * CustomIcon delete
   */
  export type CustomIconDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
    /**
     * Filter which CustomIcon to delete.
     */
    where: CustomIconWhereUniqueInput
  }

  /**
   * CustomIcon deleteMany
   */
  export type CustomIconDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomIcons to delete
     */
    where?: CustomIconWhereInput
    /**
     * Limit how many CustomIcons to delete.
     */
    limit?: number
  }

  /**
   * CustomIcon without action
   */
  export type CustomIconDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomIcon
     */
    select?: CustomIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomIcon
     */
    omit?: CustomIconOmit<ExtArgs> | null
  }


  /**
   * Model PackageTranslation
   */

  export type AggregatePackageTranslation = {
    _count: PackageTranslationCountAggregateOutputType | null
    _min: PackageTranslationMinAggregateOutputType | null
    _max: PackageTranslationMaxAggregateOutputType | null
  }

  export type PackageTranslationMinAggregateOutputType = {
    id: string | null
    packageId: string | null
    language: string | null
    title: string | null
    description: string | null
    longDescription: string | null
    destinations: string | null
    includes: string | null
    excludes: string | null
    highlights: string | null
    itinerary: string | null
    faqs: string | null
    groupSize: string | null
    difficulty: string | null
    bestFor: string | null
    departure: string | null
    return: string | null
    location: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageTranslationMaxAggregateOutputType = {
    id: string | null
    packageId: string | null
    language: string | null
    title: string | null
    description: string | null
    longDescription: string | null
    destinations: string | null
    includes: string | null
    excludes: string | null
    highlights: string | null
    itinerary: string | null
    faqs: string | null
    groupSize: string | null
    difficulty: string | null
    bestFor: string | null
    departure: string | null
    return: string | null
    location: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackageTranslationCountAggregateOutputType = {
    id: number
    packageId: number
    language: number
    title: number
    description: number
    longDescription: number
    destinations: number
    includes: number
    excludes: number
    highlights: number
    itinerary: number
    faqs: number
    groupSize: number
    difficulty: number
    bestFor: number
    departure: number
    return: number
    location: number
    isAutoTranslated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackageTranslationMinAggregateInputType = {
    id?: true
    packageId?: true
    language?: true
    title?: true
    description?: true
    longDescription?: true
    destinations?: true
    includes?: true
    excludes?: true
    highlights?: true
    itinerary?: true
    faqs?: true
    groupSize?: true
    difficulty?: true
    bestFor?: true
    departure?: true
    return?: true
    location?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageTranslationMaxAggregateInputType = {
    id?: true
    packageId?: true
    language?: true
    title?: true
    description?: true
    longDescription?: true
    destinations?: true
    includes?: true
    excludes?: true
    highlights?: true
    itinerary?: true
    faqs?: true
    groupSize?: true
    difficulty?: true
    bestFor?: true
    departure?: true
    return?: true
    location?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackageTranslationCountAggregateInputType = {
    id?: true
    packageId?: true
    language?: true
    title?: true
    description?: true
    longDescription?: true
    destinations?: true
    includes?: true
    excludes?: true
    highlights?: true
    itinerary?: true
    faqs?: true
    groupSize?: true
    difficulty?: true
    bestFor?: true
    departure?: true
    return?: true
    location?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackageTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageTranslation to aggregate.
     */
    where?: PackageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageTranslations to fetch.
     */
    orderBy?: PackageTranslationOrderByWithRelationInput | PackageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackageTranslations
    **/
    _count?: true | PackageTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageTranslationMaxAggregateInputType
  }

  export type GetPackageTranslationAggregateType<T extends PackageTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregatePackageTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackageTranslation[P]>
      : GetScalarType<T[P], AggregatePackageTranslation[P]>
  }




  export type PackageTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageTranslationWhereInput
    orderBy?: PackageTranslationOrderByWithAggregationInput | PackageTranslationOrderByWithAggregationInput[]
    by: PackageTranslationScalarFieldEnum[] | PackageTranslationScalarFieldEnum
    having?: PackageTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageTranslationCountAggregateInputType | true
    _min?: PackageTranslationMinAggregateInputType
    _max?: PackageTranslationMaxAggregateInputType
  }

  export type PackageTranslationGroupByOutputType = {
    id: string
    packageId: string
    language: string
    title: string | null
    description: string | null
    longDescription: string | null
    destinations: string | null
    includes: string | null
    excludes: string | null
    highlights: string | null
    itinerary: string | null
    faqs: string | null
    groupSize: string | null
    difficulty: string | null
    bestFor: string | null
    departure: string | null
    return: string | null
    location: string | null
    isAutoTranslated: boolean
    createdAt: Date
    updatedAt: Date
    _count: PackageTranslationCountAggregateOutputType | null
    _min: PackageTranslationMinAggregateOutputType | null
    _max: PackageTranslationMaxAggregateOutputType | null
  }

  type GetPackageTranslationGroupByPayload<T extends PackageTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], PackageTranslationGroupByOutputType[P]>
        }
      >
    >


  export type PackageTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packageId?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    longDescription?: boolean
    destinations?: boolean
    includes?: boolean
    excludes?: boolean
    highlights?: boolean
    itinerary?: boolean
    faqs?: boolean
    groupSize?: boolean
    difficulty?: boolean
    bestFor?: boolean
    departure?: boolean
    return?: boolean
    location?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["packageTranslation"]>



  export type PackageTranslationSelectScalar = {
    id?: boolean
    packageId?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    longDescription?: boolean
    destinations?: boolean
    includes?: boolean
    excludes?: boolean
    highlights?: boolean
    itinerary?: boolean
    faqs?: boolean
    groupSize?: boolean
    difficulty?: boolean
    bestFor?: boolean
    departure?: boolean
    return?: boolean
    location?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackageTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "packageId" | "language" | "title" | "description" | "longDescription" | "destinations" | "includes" | "excludes" | "highlights" | "itinerary" | "faqs" | "groupSize" | "difficulty" | "bestFor" | "departure" | "return" | "location" | "isAutoTranslated" | "createdAt" | "updatedAt", ExtArgs["result"]["packageTranslation"]>

  export type $PackageTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackageTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      packageId: string
      language: string
      title: string | null
      description: string | null
      longDescription: string | null
      destinations: string | null
      includes: string | null
      excludes: string | null
      highlights: string | null
      itinerary: string | null
      faqs: string | null
      groupSize: string | null
      difficulty: string | null
      bestFor: string | null
      departure: string | null
      return: string | null
      location: string | null
      isAutoTranslated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packageTranslation"]>
    composites: {}
  }

  type PackageTranslationGetPayload<S extends boolean | null | undefined | PackageTranslationDefaultArgs> = $Result.GetResult<Prisma.$PackageTranslationPayload, S>

  type PackageTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageTranslationCountAggregateInputType | true
    }

  export interface PackageTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackageTranslation'], meta: { name: 'PackageTranslation' } }
    /**
     * Find zero or one PackageTranslation that matches the filter.
     * @param {PackageTranslationFindUniqueArgs} args - Arguments to find a PackageTranslation
     * @example
     * // Get one PackageTranslation
     * const packageTranslation = await prisma.packageTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageTranslationFindUniqueArgs>(args: SelectSubset<T, PackageTranslationFindUniqueArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackageTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageTranslationFindUniqueOrThrowArgs} args - Arguments to find a PackageTranslation
     * @example
     * // Get one PackageTranslation
     * const packageTranslation = await prisma.packageTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationFindFirstArgs} args - Arguments to find a PackageTranslation
     * @example
     * // Get one PackageTranslation
     * const packageTranslation = await prisma.packageTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageTranslationFindFirstArgs>(args?: SelectSubset<T, PackageTranslationFindFirstArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackageTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationFindFirstOrThrowArgs} args - Arguments to find a PackageTranslation
     * @example
     * // Get one PackageTranslation
     * const packageTranslation = await prisma.packageTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackageTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackageTranslations
     * const packageTranslations = await prisma.packageTranslation.findMany()
     * 
     * // Get first 10 PackageTranslations
     * const packageTranslations = await prisma.packageTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageTranslationWithIdOnly = await prisma.packageTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageTranslationFindManyArgs>(args?: SelectSubset<T, PackageTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackageTranslation.
     * @param {PackageTranslationCreateArgs} args - Arguments to create a PackageTranslation.
     * @example
     * // Create one PackageTranslation
     * const PackageTranslation = await prisma.packageTranslation.create({
     *   data: {
     *     // ... data to create a PackageTranslation
     *   }
     * })
     * 
     */
    create<T extends PackageTranslationCreateArgs>(args: SelectSubset<T, PackageTranslationCreateArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackageTranslations.
     * @param {PackageTranslationCreateManyArgs} args - Arguments to create many PackageTranslations.
     * @example
     * // Create many PackageTranslations
     * const packageTranslation = await prisma.packageTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageTranslationCreateManyArgs>(args?: SelectSubset<T, PackageTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PackageTranslation.
     * @param {PackageTranslationDeleteArgs} args - Arguments to delete one PackageTranslation.
     * @example
     * // Delete one PackageTranslation
     * const PackageTranslation = await prisma.packageTranslation.delete({
     *   where: {
     *     // ... filter to delete one PackageTranslation
     *   }
     * })
     * 
     */
    delete<T extends PackageTranslationDeleteArgs>(args: SelectSubset<T, PackageTranslationDeleteArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackageTranslation.
     * @param {PackageTranslationUpdateArgs} args - Arguments to update one PackageTranslation.
     * @example
     * // Update one PackageTranslation
     * const packageTranslation = await prisma.packageTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageTranslationUpdateArgs>(args: SelectSubset<T, PackageTranslationUpdateArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackageTranslations.
     * @param {PackageTranslationDeleteManyArgs} args - Arguments to filter PackageTranslations to delete.
     * @example
     * // Delete a few PackageTranslations
     * const { count } = await prisma.packageTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageTranslationDeleteManyArgs>(args?: SelectSubset<T, PackageTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackageTranslations
     * const packageTranslation = await prisma.packageTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageTranslationUpdateManyArgs>(args: SelectSubset<T, PackageTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackageTranslation.
     * @param {PackageTranslationUpsertArgs} args - Arguments to update or create a PackageTranslation.
     * @example
     * // Update or create a PackageTranslation
     * const packageTranslation = await prisma.packageTranslation.upsert({
     *   create: {
     *     // ... data to create a PackageTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackageTranslation we want to update
     *   }
     * })
     */
    upsert<T extends PackageTranslationUpsertArgs>(args: SelectSubset<T, PackageTranslationUpsertArgs<ExtArgs>>): Prisma__PackageTranslationClient<$Result.GetResult<Prisma.$PackageTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationCountArgs} args - Arguments to filter PackageTranslations to count.
     * @example
     * // Count the number of PackageTranslations
     * const count = await prisma.packageTranslation.count({
     *   where: {
     *     // ... the filter for the PackageTranslations we want to count
     *   }
     * })
    **/
    count<T extends PackageTranslationCountArgs>(
      args?: Subset<T, PackageTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageTranslationAggregateArgs>(args: Subset<T, PackageTranslationAggregateArgs>): Prisma.PrismaPromise<GetPackageTranslationAggregateType<T>>

    /**
     * Group by PackageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageTranslationGroupByArgs['orderBy'] }
        : { orderBy?: PackageTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackageTranslation model
   */
  readonly fields: PackageTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackageTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackageTranslation model
   */
  interface PackageTranslationFieldRefs {
    readonly id: FieldRef<"PackageTranslation", 'String'>
    readonly packageId: FieldRef<"PackageTranslation", 'String'>
    readonly language: FieldRef<"PackageTranslation", 'String'>
    readonly title: FieldRef<"PackageTranslation", 'String'>
    readonly description: FieldRef<"PackageTranslation", 'String'>
    readonly longDescription: FieldRef<"PackageTranslation", 'String'>
    readonly destinations: FieldRef<"PackageTranslation", 'String'>
    readonly includes: FieldRef<"PackageTranslation", 'String'>
    readonly excludes: FieldRef<"PackageTranslation", 'String'>
    readonly highlights: FieldRef<"PackageTranslation", 'String'>
    readonly itinerary: FieldRef<"PackageTranslation", 'String'>
    readonly faqs: FieldRef<"PackageTranslation", 'String'>
    readonly groupSize: FieldRef<"PackageTranslation", 'String'>
    readonly difficulty: FieldRef<"PackageTranslation", 'String'>
    readonly bestFor: FieldRef<"PackageTranslation", 'String'>
    readonly departure: FieldRef<"PackageTranslation", 'String'>
    readonly return: FieldRef<"PackageTranslation", 'String'>
    readonly location: FieldRef<"PackageTranslation", 'String'>
    readonly isAutoTranslated: FieldRef<"PackageTranslation", 'Boolean'>
    readonly createdAt: FieldRef<"PackageTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"PackageTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackageTranslation findUnique
   */
  export type PackageTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * Filter, which PackageTranslation to fetch.
     */
    where: PackageTranslationWhereUniqueInput
  }

  /**
   * PackageTranslation findUniqueOrThrow
   */
  export type PackageTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * Filter, which PackageTranslation to fetch.
     */
    where: PackageTranslationWhereUniqueInput
  }

  /**
   * PackageTranslation findFirst
   */
  export type PackageTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * Filter, which PackageTranslation to fetch.
     */
    where?: PackageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageTranslations to fetch.
     */
    orderBy?: PackageTranslationOrderByWithRelationInput | PackageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageTranslations.
     */
    cursor?: PackageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageTranslations.
     */
    distinct?: PackageTranslationScalarFieldEnum | PackageTranslationScalarFieldEnum[]
  }

  /**
   * PackageTranslation findFirstOrThrow
   */
  export type PackageTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * Filter, which PackageTranslation to fetch.
     */
    where?: PackageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageTranslations to fetch.
     */
    orderBy?: PackageTranslationOrderByWithRelationInput | PackageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackageTranslations.
     */
    cursor?: PackageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackageTranslations.
     */
    distinct?: PackageTranslationScalarFieldEnum | PackageTranslationScalarFieldEnum[]
  }

  /**
   * PackageTranslation findMany
   */
  export type PackageTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * Filter, which PackageTranslations to fetch.
     */
    where?: PackageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackageTranslations to fetch.
     */
    orderBy?: PackageTranslationOrderByWithRelationInput | PackageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackageTranslations.
     */
    cursor?: PackageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackageTranslations.
     */
    skip?: number
    distinct?: PackageTranslationScalarFieldEnum | PackageTranslationScalarFieldEnum[]
  }

  /**
   * PackageTranslation create
   */
  export type PackageTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a PackageTranslation.
     */
    data: XOR<PackageTranslationCreateInput, PackageTranslationUncheckedCreateInput>
  }

  /**
   * PackageTranslation createMany
   */
  export type PackageTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackageTranslations.
     */
    data: PackageTranslationCreateManyInput | PackageTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackageTranslation update
   */
  export type PackageTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a PackageTranslation.
     */
    data: XOR<PackageTranslationUpdateInput, PackageTranslationUncheckedUpdateInput>
    /**
     * Choose, which PackageTranslation to update.
     */
    where: PackageTranslationWhereUniqueInput
  }

  /**
   * PackageTranslation updateMany
   */
  export type PackageTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackageTranslations.
     */
    data: XOR<PackageTranslationUpdateManyMutationInput, PackageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PackageTranslations to update
     */
    where?: PackageTranslationWhereInput
    /**
     * Limit how many PackageTranslations to update.
     */
    limit?: number
  }

  /**
   * PackageTranslation upsert
   */
  export type PackageTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the PackageTranslation to update in case it exists.
     */
    where: PackageTranslationWhereUniqueInput
    /**
     * In case the PackageTranslation found by the `where` argument doesn't exist, create a new PackageTranslation with this data.
     */
    create: XOR<PackageTranslationCreateInput, PackageTranslationUncheckedCreateInput>
    /**
     * In case the PackageTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageTranslationUpdateInput, PackageTranslationUncheckedUpdateInput>
  }

  /**
   * PackageTranslation delete
   */
  export type PackageTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
    /**
     * Filter which PackageTranslation to delete.
     */
    where: PackageTranslationWhereUniqueInput
  }

  /**
   * PackageTranslation deleteMany
   */
  export type PackageTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackageTranslations to delete
     */
    where?: PackageTranslationWhereInput
    /**
     * Limit how many PackageTranslations to delete.
     */
    limit?: number
  }

  /**
   * PackageTranslation without action
   */
  export type PackageTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageTranslation
     */
    select?: PackageTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackageTranslation
     */
    omit?: PackageTranslationOmit<ExtArgs> | null
  }


  /**
   * Model BlogTranslation
   */

  export type AggregateBlogTranslation = {
    _count: BlogTranslationCountAggregateOutputType | null
    _min: BlogTranslationMinAggregateOutputType | null
    _max: BlogTranslationMaxAggregateOutputType | null
  }

  export type BlogTranslationMinAggregateOutputType = {
    id: string | null
    blogId: string | null
    language: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    category: string | null
    tags: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogTranslationMaxAggregateOutputType = {
    id: string | null
    blogId: string | null
    language: string | null
    title: string | null
    excerpt: string | null
    content: string | null
    category: string | null
    tags: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogTranslationCountAggregateOutputType = {
    id: number
    blogId: number
    language: number
    title: number
    excerpt: number
    content: number
    category: number
    tags: number
    isAutoTranslated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogTranslationMinAggregateInputType = {
    id?: true
    blogId?: true
    language?: true
    title?: true
    excerpt?: true
    content?: true
    category?: true
    tags?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogTranslationMaxAggregateInputType = {
    id?: true
    blogId?: true
    language?: true
    title?: true
    excerpt?: true
    content?: true
    category?: true
    tags?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogTranslationCountAggregateInputType = {
    id?: true
    blogId?: true
    language?: true
    title?: true
    excerpt?: true
    content?: true
    category?: true
    tags?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTranslation to aggregate.
     */
    where?: BlogTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTranslations to fetch.
     */
    orderBy?: BlogTranslationOrderByWithRelationInput | BlogTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogTranslations
    **/
    _count?: true | BlogTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogTranslationMaxAggregateInputType
  }

  export type GetBlogTranslationAggregateType<T extends BlogTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogTranslation[P]>
      : GetScalarType<T[P], AggregateBlogTranslation[P]>
  }




  export type BlogTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTranslationWhereInput
    orderBy?: BlogTranslationOrderByWithAggregationInput | BlogTranslationOrderByWithAggregationInput[]
    by: BlogTranslationScalarFieldEnum[] | BlogTranslationScalarFieldEnum
    having?: BlogTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogTranslationCountAggregateInputType | true
    _min?: BlogTranslationMinAggregateInputType
    _max?: BlogTranslationMaxAggregateInputType
  }

  export type BlogTranslationGroupByOutputType = {
    id: string
    blogId: string
    language: string
    title: string | null
    excerpt: string | null
    content: string | null
    category: string | null
    tags: string | null
    isAutoTranslated: boolean
    createdAt: Date
    updatedAt: Date
    _count: BlogTranslationCountAggregateOutputType | null
    _min: BlogTranslationMinAggregateOutputType | null
    _max: BlogTranslationMaxAggregateOutputType | null
  }

  type GetBlogTranslationGroupByPayload<T extends BlogTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], BlogTranslationGroupByOutputType[P]>
        }
      >
    >


  export type BlogTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blogId?: boolean
    language?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogTranslation"]>



  export type BlogTranslationSelectScalar = {
    id?: boolean
    blogId?: boolean
    language?: boolean
    title?: boolean
    excerpt?: boolean
    content?: boolean
    category?: boolean
    tags?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blogId" | "language" | "title" | "excerpt" | "content" | "category" | "tags" | "isAutoTranslated" | "createdAt" | "updatedAt", ExtArgs["result"]["blogTranslation"]>

  export type $BlogTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blogId: string
      language: string
      title: string | null
      excerpt: string | null
      content: string | null
      category: string | null
      tags: string | null
      isAutoTranslated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogTranslation"]>
    composites: {}
  }

  type BlogTranslationGetPayload<S extends boolean | null | undefined | BlogTranslationDefaultArgs> = $Result.GetResult<Prisma.$BlogTranslationPayload, S>

  type BlogTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogTranslationCountAggregateInputType | true
    }

  export interface BlogTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogTranslation'], meta: { name: 'BlogTranslation' } }
    /**
     * Find zero or one BlogTranslation that matches the filter.
     * @param {BlogTranslationFindUniqueArgs} args - Arguments to find a BlogTranslation
     * @example
     * // Get one BlogTranslation
     * const blogTranslation = await prisma.blogTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogTranslationFindUniqueArgs>(args: SelectSubset<T, BlogTranslationFindUniqueArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogTranslationFindUniqueOrThrowArgs} args - Arguments to find a BlogTranslation
     * @example
     * // Get one BlogTranslation
     * const blogTranslation = await prisma.blogTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationFindFirstArgs} args - Arguments to find a BlogTranslation
     * @example
     * // Get one BlogTranslation
     * const blogTranslation = await prisma.blogTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogTranslationFindFirstArgs>(args?: SelectSubset<T, BlogTranslationFindFirstArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationFindFirstOrThrowArgs} args - Arguments to find a BlogTranslation
     * @example
     * // Get one BlogTranslation
     * const blogTranslation = await prisma.blogTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogTranslations
     * const blogTranslations = await prisma.blogTranslation.findMany()
     * 
     * // Get first 10 BlogTranslations
     * const blogTranslations = await prisma.blogTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogTranslationWithIdOnly = await prisma.blogTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogTranslationFindManyArgs>(args?: SelectSubset<T, BlogTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogTranslation.
     * @param {BlogTranslationCreateArgs} args - Arguments to create a BlogTranslation.
     * @example
     * // Create one BlogTranslation
     * const BlogTranslation = await prisma.blogTranslation.create({
     *   data: {
     *     // ... data to create a BlogTranslation
     *   }
     * })
     * 
     */
    create<T extends BlogTranslationCreateArgs>(args: SelectSubset<T, BlogTranslationCreateArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogTranslations.
     * @param {BlogTranslationCreateManyArgs} args - Arguments to create many BlogTranslations.
     * @example
     * // Create many BlogTranslations
     * const blogTranslation = await prisma.blogTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogTranslationCreateManyArgs>(args?: SelectSubset<T, BlogTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BlogTranslation.
     * @param {BlogTranslationDeleteArgs} args - Arguments to delete one BlogTranslation.
     * @example
     * // Delete one BlogTranslation
     * const BlogTranslation = await prisma.blogTranslation.delete({
     *   where: {
     *     // ... filter to delete one BlogTranslation
     *   }
     * })
     * 
     */
    delete<T extends BlogTranslationDeleteArgs>(args: SelectSubset<T, BlogTranslationDeleteArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogTranslation.
     * @param {BlogTranslationUpdateArgs} args - Arguments to update one BlogTranslation.
     * @example
     * // Update one BlogTranslation
     * const blogTranslation = await prisma.blogTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogTranslationUpdateArgs>(args: SelectSubset<T, BlogTranslationUpdateArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogTranslations.
     * @param {BlogTranslationDeleteManyArgs} args - Arguments to filter BlogTranslations to delete.
     * @example
     * // Delete a few BlogTranslations
     * const { count } = await prisma.blogTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogTranslationDeleteManyArgs>(args?: SelectSubset<T, BlogTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogTranslations
     * const blogTranslation = await prisma.blogTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogTranslationUpdateManyArgs>(args: SelectSubset<T, BlogTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlogTranslation.
     * @param {BlogTranslationUpsertArgs} args - Arguments to update or create a BlogTranslation.
     * @example
     * // Update or create a BlogTranslation
     * const blogTranslation = await prisma.blogTranslation.upsert({
     *   create: {
     *     // ... data to create a BlogTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogTranslation we want to update
     *   }
     * })
     */
    upsert<T extends BlogTranslationUpsertArgs>(args: SelectSubset<T, BlogTranslationUpsertArgs<ExtArgs>>): Prisma__BlogTranslationClient<$Result.GetResult<Prisma.$BlogTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationCountArgs} args - Arguments to filter BlogTranslations to count.
     * @example
     * // Count the number of BlogTranslations
     * const count = await prisma.blogTranslation.count({
     *   where: {
     *     // ... the filter for the BlogTranslations we want to count
     *   }
     * })
    **/
    count<T extends BlogTranslationCountArgs>(
      args?: Subset<T, BlogTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogTranslationAggregateArgs>(args: Subset<T, BlogTranslationAggregateArgs>): Prisma.PrismaPromise<GetBlogTranslationAggregateType<T>>

    /**
     * Group by BlogTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogTranslationGroupByArgs['orderBy'] }
        : { orderBy?: BlogTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogTranslation model
   */
  readonly fields: BlogTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogTranslation model
   */
  interface BlogTranslationFieldRefs {
    readonly id: FieldRef<"BlogTranslation", 'String'>
    readonly blogId: FieldRef<"BlogTranslation", 'String'>
    readonly language: FieldRef<"BlogTranslation", 'String'>
    readonly title: FieldRef<"BlogTranslation", 'String'>
    readonly excerpt: FieldRef<"BlogTranslation", 'String'>
    readonly content: FieldRef<"BlogTranslation", 'String'>
    readonly category: FieldRef<"BlogTranslation", 'String'>
    readonly tags: FieldRef<"BlogTranslation", 'String'>
    readonly isAutoTranslated: FieldRef<"BlogTranslation", 'Boolean'>
    readonly createdAt: FieldRef<"BlogTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogTranslation findUnique
   */
  export type BlogTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * Filter, which BlogTranslation to fetch.
     */
    where: BlogTranslationWhereUniqueInput
  }

  /**
   * BlogTranslation findUniqueOrThrow
   */
  export type BlogTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * Filter, which BlogTranslation to fetch.
     */
    where: BlogTranslationWhereUniqueInput
  }

  /**
   * BlogTranslation findFirst
   */
  export type BlogTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * Filter, which BlogTranslation to fetch.
     */
    where?: BlogTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTranslations to fetch.
     */
    orderBy?: BlogTranslationOrderByWithRelationInput | BlogTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTranslations.
     */
    cursor?: BlogTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTranslations.
     */
    distinct?: BlogTranslationScalarFieldEnum | BlogTranslationScalarFieldEnum[]
  }

  /**
   * BlogTranslation findFirstOrThrow
   */
  export type BlogTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * Filter, which BlogTranslation to fetch.
     */
    where?: BlogTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTranslations to fetch.
     */
    orderBy?: BlogTranslationOrderByWithRelationInput | BlogTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTranslations.
     */
    cursor?: BlogTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTranslations.
     */
    distinct?: BlogTranslationScalarFieldEnum | BlogTranslationScalarFieldEnum[]
  }

  /**
   * BlogTranslation findMany
   */
  export type BlogTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * Filter, which BlogTranslations to fetch.
     */
    where?: BlogTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTranslations to fetch.
     */
    orderBy?: BlogTranslationOrderByWithRelationInput | BlogTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogTranslations.
     */
    cursor?: BlogTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTranslations.
     */
    skip?: number
    distinct?: BlogTranslationScalarFieldEnum | BlogTranslationScalarFieldEnum[]
  }

  /**
   * BlogTranslation create
   */
  export type BlogTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a BlogTranslation.
     */
    data: XOR<BlogTranslationCreateInput, BlogTranslationUncheckedCreateInput>
  }

  /**
   * BlogTranslation createMany
   */
  export type BlogTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogTranslations.
     */
    data: BlogTranslationCreateManyInput | BlogTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTranslation update
   */
  export type BlogTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a BlogTranslation.
     */
    data: XOR<BlogTranslationUpdateInput, BlogTranslationUncheckedUpdateInput>
    /**
     * Choose, which BlogTranslation to update.
     */
    where: BlogTranslationWhereUniqueInput
  }

  /**
   * BlogTranslation updateMany
   */
  export type BlogTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogTranslations.
     */
    data: XOR<BlogTranslationUpdateManyMutationInput, BlogTranslationUncheckedUpdateManyInput>
    /**
     * Filter which BlogTranslations to update
     */
    where?: BlogTranslationWhereInput
    /**
     * Limit how many BlogTranslations to update.
     */
    limit?: number
  }

  /**
   * BlogTranslation upsert
   */
  export type BlogTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the BlogTranslation to update in case it exists.
     */
    where: BlogTranslationWhereUniqueInput
    /**
     * In case the BlogTranslation found by the `where` argument doesn't exist, create a new BlogTranslation with this data.
     */
    create: XOR<BlogTranslationCreateInput, BlogTranslationUncheckedCreateInput>
    /**
     * In case the BlogTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogTranslationUpdateInput, BlogTranslationUncheckedUpdateInput>
  }

  /**
   * BlogTranslation delete
   */
  export type BlogTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
    /**
     * Filter which BlogTranslation to delete.
     */
    where: BlogTranslationWhereUniqueInput
  }

  /**
   * BlogTranslation deleteMany
   */
  export type BlogTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTranslations to delete
     */
    where?: BlogTranslationWhereInput
    /**
     * Limit how many BlogTranslations to delete.
     */
    limit?: number
  }

  /**
   * BlogTranslation without action
   */
  export type BlogTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTranslation
     */
    select?: BlogTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTranslation
     */
    omit?: BlogTranslationOmit<ExtArgs> | null
  }


  /**
   * Model TestimonialTranslation
   */

  export type AggregateTestimonialTranslation = {
    _count: TestimonialTranslationCountAggregateOutputType | null
    _min: TestimonialTranslationMinAggregateOutputType | null
    _max: TestimonialTranslationMaxAggregateOutputType | null
  }

  export type TestimonialTranslationMinAggregateOutputType = {
    id: string | null
    testimonialId: string | null
    language: string | null
    name: string | null
    role: string | null
    content: string | null
    packageName: string | null
    location: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialTranslationMaxAggregateOutputType = {
    id: string | null
    testimonialId: string | null
    language: string | null
    name: string | null
    role: string | null
    content: string | null
    packageName: string | null
    location: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestimonialTranslationCountAggregateOutputType = {
    id: number
    testimonialId: number
    language: number
    name: number
    role: number
    content: number
    packageName: number
    location: number
    isAutoTranslated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestimonialTranslationMinAggregateInputType = {
    id?: true
    testimonialId?: true
    language?: true
    name?: true
    role?: true
    content?: true
    packageName?: true
    location?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialTranslationMaxAggregateInputType = {
    id?: true
    testimonialId?: true
    language?: true
    name?: true
    role?: true
    content?: true
    packageName?: true
    location?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestimonialTranslationCountAggregateInputType = {
    id?: true
    testimonialId?: true
    language?: true
    name?: true
    role?: true
    content?: true
    packageName?: true
    location?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestimonialTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestimonialTranslation to aggregate.
     */
    where?: TestimonialTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialTranslations to fetch.
     */
    orderBy?: TestimonialTranslationOrderByWithRelationInput | TestimonialTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestimonialTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestimonialTranslations
    **/
    _count?: true | TestimonialTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialTranslationMaxAggregateInputType
  }

  export type GetTestimonialTranslationAggregateType<T extends TestimonialTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonialTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonialTranslation[P]>
      : GetScalarType<T[P], AggregateTestimonialTranslation[P]>
  }




  export type TestimonialTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestimonialTranslationWhereInput
    orderBy?: TestimonialTranslationOrderByWithAggregationInput | TestimonialTranslationOrderByWithAggregationInput[]
    by: TestimonialTranslationScalarFieldEnum[] | TestimonialTranslationScalarFieldEnum
    having?: TestimonialTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialTranslationCountAggregateInputType | true
    _min?: TestimonialTranslationMinAggregateInputType
    _max?: TestimonialTranslationMaxAggregateInputType
  }

  export type TestimonialTranslationGroupByOutputType = {
    id: string
    testimonialId: string
    language: string
    name: string | null
    role: string | null
    content: string | null
    packageName: string | null
    location: string | null
    isAutoTranslated: boolean
    createdAt: Date
    updatedAt: Date
    _count: TestimonialTranslationCountAggregateOutputType | null
    _min: TestimonialTranslationMinAggregateOutputType | null
    _max: TestimonialTranslationMaxAggregateOutputType | null
  }

  type GetTestimonialTranslationGroupByPayload<T extends TestimonialTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialTranslationGroupByOutputType[P]>
        }
      >
    >


  export type TestimonialTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testimonialId?: boolean
    language?: boolean
    name?: boolean
    role?: boolean
    content?: boolean
    packageName?: boolean
    location?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["testimonialTranslation"]>



  export type TestimonialTranslationSelectScalar = {
    id?: boolean
    testimonialId?: boolean
    language?: boolean
    name?: boolean
    role?: boolean
    content?: boolean
    packageName?: boolean
    location?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestimonialTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testimonialId" | "language" | "name" | "role" | "content" | "packageName" | "location" | "isAutoTranslated" | "createdAt" | "updatedAt", ExtArgs["result"]["testimonialTranslation"]>

  export type $TestimonialTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestimonialTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testimonialId: string
      language: string
      name: string | null
      role: string | null
      content: string | null
      packageName: string | null
      location: string | null
      isAutoTranslated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testimonialTranslation"]>
    composites: {}
  }

  type TestimonialTranslationGetPayload<S extends boolean | null | undefined | TestimonialTranslationDefaultArgs> = $Result.GetResult<Prisma.$TestimonialTranslationPayload, S>

  type TestimonialTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestimonialTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestimonialTranslationCountAggregateInputType | true
    }

  export interface TestimonialTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestimonialTranslation'], meta: { name: 'TestimonialTranslation' } }
    /**
     * Find zero or one TestimonialTranslation that matches the filter.
     * @param {TestimonialTranslationFindUniqueArgs} args - Arguments to find a TestimonialTranslation
     * @example
     * // Get one TestimonialTranslation
     * const testimonialTranslation = await prisma.testimonialTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestimonialTranslationFindUniqueArgs>(args: SelectSubset<T, TestimonialTranslationFindUniqueArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestimonialTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestimonialTranslationFindUniqueOrThrowArgs} args - Arguments to find a TestimonialTranslation
     * @example
     * // Get one TestimonialTranslation
     * const testimonialTranslation = await prisma.testimonialTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestimonialTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TestimonialTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestimonialTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationFindFirstArgs} args - Arguments to find a TestimonialTranslation
     * @example
     * // Get one TestimonialTranslation
     * const testimonialTranslation = await prisma.testimonialTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestimonialTranslationFindFirstArgs>(args?: SelectSubset<T, TestimonialTranslationFindFirstArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestimonialTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationFindFirstOrThrowArgs} args - Arguments to find a TestimonialTranslation
     * @example
     * // Get one TestimonialTranslation
     * const testimonialTranslation = await prisma.testimonialTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestimonialTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TestimonialTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestimonialTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestimonialTranslations
     * const testimonialTranslations = await prisma.testimonialTranslation.findMany()
     * 
     * // Get first 10 TestimonialTranslations
     * const testimonialTranslations = await prisma.testimonialTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialTranslationWithIdOnly = await prisma.testimonialTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestimonialTranslationFindManyArgs>(args?: SelectSubset<T, TestimonialTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestimonialTranslation.
     * @param {TestimonialTranslationCreateArgs} args - Arguments to create a TestimonialTranslation.
     * @example
     * // Create one TestimonialTranslation
     * const TestimonialTranslation = await prisma.testimonialTranslation.create({
     *   data: {
     *     // ... data to create a TestimonialTranslation
     *   }
     * })
     * 
     */
    create<T extends TestimonialTranslationCreateArgs>(args: SelectSubset<T, TestimonialTranslationCreateArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestimonialTranslations.
     * @param {TestimonialTranslationCreateManyArgs} args - Arguments to create many TestimonialTranslations.
     * @example
     * // Create many TestimonialTranslations
     * const testimonialTranslation = await prisma.testimonialTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestimonialTranslationCreateManyArgs>(args?: SelectSubset<T, TestimonialTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestimonialTranslation.
     * @param {TestimonialTranslationDeleteArgs} args - Arguments to delete one TestimonialTranslation.
     * @example
     * // Delete one TestimonialTranslation
     * const TestimonialTranslation = await prisma.testimonialTranslation.delete({
     *   where: {
     *     // ... filter to delete one TestimonialTranslation
     *   }
     * })
     * 
     */
    delete<T extends TestimonialTranslationDeleteArgs>(args: SelectSubset<T, TestimonialTranslationDeleteArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestimonialTranslation.
     * @param {TestimonialTranslationUpdateArgs} args - Arguments to update one TestimonialTranslation.
     * @example
     * // Update one TestimonialTranslation
     * const testimonialTranslation = await prisma.testimonialTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestimonialTranslationUpdateArgs>(args: SelectSubset<T, TestimonialTranslationUpdateArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestimonialTranslations.
     * @param {TestimonialTranslationDeleteManyArgs} args - Arguments to filter TestimonialTranslations to delete.
     * @example
     * // Delete a few TestimonialTranslations
     * const { count } = await prisma.testimonialTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestimonialTranslationDeleteManyArgs>(args?: SelectSubset<T, TestimonialTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestimonialTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestimonialTranslations
     * const testimonialTranslation = await prisma.testimonialTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestimonialTranslationUpdateManyArgs>(args: SelectSubset<T, TestimonialTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestimonialTranslation.
     * @param {TestimonialTranslationUpsertArgs} args - Arguments to update or create a TestimonialTranslation.
     * @example
     * // Update or create a TestimonialTranslation
     * const testimonialTranslation = await prisma.testimonialTranslation.upsert({
     *   create: {
     *     // ... data to create a TestimonialTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestimonialTranslation we want to update
     *   }
     * })
     */
    upsert<T extends TestimonialTranslationUpsertArgs>(args: SelectSubset<T, TestimonialTranslationUpsertArgs<ExtArgs>>): Prisma__TestimonialTranslationClient<$Result.GetResult<Prisma.$TestimonialTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestimonialTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationCountArgs} args - Arguments to filter TestimonialTranslations to count.
     * @example
     * // Count the number of TestimonialTranslations
     * const count = await prisma.testimonialTranslation.count({
     *   where: {
     *     // ... the filter for the TestimonialTranslations we want to count
     *   }
     * })
    **/
    count<T extends TestimonialTranslationCountArgs>(
      args?: Subset<T, TestimonialTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestimonialTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialTranslationAggregateArgs>(args: Subset<T, TestimonialTranslationAggregateArgs>): Prisma.PrismaPromise<GetTestimonialTranslationAggregateType<T>>

    /**
     * Group by TestimonialTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestimonialTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestimonialTranslationGroupByArgs['orderBy'] }
        : { orderBy?: TestimonialTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestimonialTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestimonialTranslation model
   */
  readonly fields: TestimonialTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestimonialTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestimonialTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestimonialTranslation model
   */
  interface TestimonialTranslationFieldRefs {
    readonly id: FieldRef<"TestimonialTranslation", 'String'>
    readonly testimonialId: FieldRef<"TestimonialTranslation", 'String'>
    readonly language: FieldRef<"TestimonialTranslation", 'String'>
    readonly name: FieldRef<"TestimonialTranslation", 'String'>
    readonly role: FieldRef<"TestimonialTranslation", 'String'>
    readonly content: FieldRef<"TestimonialTranslation", 'String'>
    readonly packageName: FieldRef<"TestimonialTranslation", 'String'>
    readonly location: FieldRef<"TestimonialTranslation", 'String'>
    readonly isAutoTranslated: FieldRef<"TestimonialTranslation", 'Boolean'>
    readonly createdAt: FieldRef<"TestimonialTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"TestimonialTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestimonialTranslation findUnique
   */
  export type TestimonialTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TestimonialTranslation to fetch.
     */
    where: TestimonialTranslationWhereUniqueInput
  }

  /**
   * TestimonialTranslation findUniqueOrThrow
   */
  export type TestimonialTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TestimonialTranslation to fetch.
     */
    where: TestimonialTranslationWhereUniqueInput
  }

  /**
   * TestimonialTranslation findFirst
   */
  export type TestimonialTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TestimonialTranslation to fetch.
     */
    where?: TestimonialTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialTranslations to fetch.
     */
    orderBy?: TestimonialTranslationOrderByWithRelationInput | TestimonialTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestimonialTranslations.
     */
    cursor?: TestimonialTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestimonialTranslations.
     */
    distinct?: TestimonialTranslationScalarFieldEnum | TestimonialTranslationScalarFieldEnum[]
  }

  /**
   * TestimonialTranslation findFirstOrThrow
   */
  export type TestimonialTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TestimonialTranslation to fetch.
     */
    where?: TestimonialTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialTranslations to fetch.
     */
    orderBy?: TestimonialTranslationOrderByWithRelationInput | TestimonialTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestimonialTranslations.
     */
    cursor?: TestimonialTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestimonialTranslations.
     */
    distinct?: TestimonialTranslationScalarFieldEnum | TestimonialTranslationScalarFieldEnum[]
  }

  /**
   * TestimonialTranslation findMany
   */
  export type TestimonialTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * Filter, which TestimonialTranslations to fetch.
     */
    where?: TestimonialTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestimonialTranslations to fetch.
     */
    orderBy?: TestimonialTranslationOrderByWithRelationInput | TestimonialTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestimonialTranslations.
     */
    cursor?: TestimonialTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestimonialTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestimonialTranslations.
     */
    skip?: number
    distinct?: TestimonialTranslationScalarFieldEnum | TestimonialTranslationScalarFieldEnum[]
  }

  /**
   * TestimonialTranslation create
   */
  export type TestimonialTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a TestimonialTranslation.
     */
    data: XOR<TestimonialTranslationCreateInput, TestimonialTranslationUncheckedCreateInput>
  }

  /**
   * TestimonialTranslation createMany
   */
  export type TestimonialTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestimonialTranslations.
     */
    data: TestimonialTranslationCreateManyInput | TestimonialTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestimonialTranslation update
   */
  export type TestimonialTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a TestimonialTranslation.
     */
    data: XOR<TestimonialTranslationUpdateInput, TestimonialTranslationUncheckedUpdateInput>
    /**
     * Choose, which TestimonialTranslation to update.
     */
    where: TestimonialTranslationWhereUniqueInput
  }

  /**
   * TestimonialTranslation updateMany
   */
  export type TestimonialTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestimonialTranslations.
     */
    data: XOR<TestimonialTranslationUpdateManyMutationInput, TestimonialTranslationUncheckedUpdateManyInput>
    /**
     * Filter which TestimonialTranslations to update
     */
    where?: TestimonialTranslationWhereInput
    /**
     * Limit how many TestimonialTranslations to update.
     */
    limit?: number
  }

  /**
   * TestimonialTranslation upsert
   */
  export type TestimonialTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the TestimonialTranslation to update in case it exists.
     */
    where: TestimonialTranslationWhereUniqueInput
    /**
     * In case the TestimonialTranslation found by the `where` argument doesn't exist, create a new TestimonialTranslation with this data.
     */
    create: XOR<TestimonialTranslationCreateInput, TestimonialTranslationUncheckedCreateInput>
    /**
     * In case the TestimonialTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestimonialTranslationUpdateInput, TestimonialTranslationUncheckedUpdateInput>
  }

  /**
   * TestimonialTranslation delete
   */
  export type TestimonialTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
    /**
     * Filter which TestimonialTranslation to delete.
     */
    where: TestimonialTranslationWhereUniqueInput
  }

  /**
   * TestimonialTranslation deleteMany
   */
  export type TestimonialTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestimonialTranslations to delete
     */
    where?: TestimonialTranslationWhereInput
    /**
     * Limit how many TestimonialTranslations to delete.
     */
    limit?: number
  }

  /**
   * TestimonialTranslation without action
   */
  export type TestimonialTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestimonialTranslation
     */
    select?: TestimonialTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestimonialTranslation
     */
    omit?: TestimonialTranslationOmit<ExtArgs> | null
  }


  /**
   * Model GalleryTranslation
   */

  export type AggregateGalleryTranslation = {
    _count: GalleryTranslationCountAggregateOutputType | null
    _min: GalleryTranslationMinAggregateOutputType | null
    _max: GalleryTranslationMaxAggregateOutputType | null
  }

  export type GalleryTranslationMinAggregateOutputType = {
    id: string | null
    galleryId: string | null
    language: string | null
    title: string | null
    description: string | null
    tags: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GalleryTranslationMaxAggregateOutputType = {
    id: string | null
    galleryId: string | null
    language: string | null
    title: string | null
    description: string | null
    tags: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GalleryTranslationCountAggregateOutputType = {
    id: number
    galleryId: number
    language: number
    title: number
    description: number
    tags: number
    isAutoTranslated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GalleryTranslationMinAggregateInputType = {
    id?: true
    galleryId?: true
    language?: true
    title?: true
    description?: true
    tags?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GalleryTranslationMaxAggregateInputType = {
    id?: true
    galleryId?: true
    language?: true
    title?: true
    description?: true
    tags?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GalleryTranslationCountAggregateInputType = {
    id?: true
    galleryId?: true
    language?: true
    title?: true
    description?: true
    tags?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GalleryTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GalleryTranslation to aggregate.
     */
    where?: GalleryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryTranslations to fetch.
     */
    orderBy?: GalleryTranslationOrderByWithRelationInput | GalleryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GalleryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GalleryTranslations
    **/
    _count?: true | GalleryTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GalleryTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GalleryTranslationMaxAggregateInputType
  }

  export type GetGalleryTranslationAggregateType<T extends GalleryTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateGalleryTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGalleryTranslation[P]>
      : GetScalarType<T[P], AggregateGalleryTranslation[P]>
  }




  export type GalleryTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GalleryTranslationWhereInput
    orderBy?: GalleryTranslationOrderByWithAggregationInput | GalleryTranslationOrderByWithAggregationInput[]
    by: GalleryTranslationScalarFieldEnum[] | GalleryTranslationScalarFieldEnum
    having?: GalleryTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GalleryTranslationCountAggregateInputType | true
    _min?: GalleryTranslationMinAggregateInputType
    _max?: GalleryTranslationMaxAggregateInputType
  }

  export type GalleryTranslationGroupByOutputType = {
    id: string
    galleryId: string
    language: string
    title: string | null
    description: string | null
    tags: string | null
    isAutoTranslated: boolean
    createdAt: Date
    updatedAt: Date
    _count: GalleryTranslationCountAggregateOutputType | null
    _min: GalleryTranslationMinAggregateOutputType | null
    _max: GalleryTranslationMaxAggregateOutputType | null
  }

  type GetGalleryTranslationGroupByPayload<T extends GalleryTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GalleryTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GalleryTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GalleryTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], GalleryTranslationGroupByOutputType[P]>
        }
      >
    >


  export type GalleryTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    galleryId?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["galleryTranslation"]>



  export type GalleryTranslationSelectScalar = {
    id?: boolean
    galleryId?: boolean
    language?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GalleryTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "galleryId" | "language" | "title" | "description" | "tags" | "isAutoTranslated" | "createdAt" | "updatedAt", ExtArgs["result"]["galleryTranslation"]>

  export type $GalleryTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GalleryTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      galleryId: string
      language: string
      title: string | null
      description: string | null
      tags: string | null
      isAutoTranslated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["galleryTranslation"]>
    composites: {}
  }

  type GalleryTranslationGetPayload<S extends boolean | null | undefined | GalleryTranslationDefaultArgs> = $Result.GetResult<Prisma.$GalleryTranslationPayload, S>

  type GalleryTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GalleryTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GalleryTranslationCountAggregateInputType | true
    }

  export interface GalleryTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GalleryTranslation'], meta: { name: 'GalleryTranslation' } }
    /**
     * Find zero or one GalleryTranslation that matches the filter.
     * @param {GalleryTranslationFindUniqueArgs} args - Arguments to find a GalleryTranslation
     * @example
     * // Get one GalleryTranslation
     * const galleryTranslation = await prisma.galleryTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GalleryTranslationFindUniqueArgs>(args: SelectSubset<T, GalleryTranslationFindUniqueArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GalleryTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GalleryTranslationFindUniqueOrThrowArgs} args - Arguments to find a GalleryTranslation
     * @example
     * // Get one GalleryTranslation
     * const galleryTranslation = await prisma.galleryTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GalleryTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, GalleryTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GalleryTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationFindFirstArgs} args - Arguments to find a GalleryTranslation
     * @example
     * // Get one GalleryTranslation
     * const galleryTranslation = await prisma.galleryTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GalleryTranslationFindFirstArgs>(args?: SelectSubset<T, GalleryTranslationFindFirstArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GalleryTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationFindFirstOrThrowArgs} args - Arguments to find a GalleryTranslation
     * @example
     * // Get one GalleryTranslation
     * const galleryTranslation = await prisma.galleryTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GalleryTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, GalleryTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GalleryTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GalleryTranslations
     * const galleryTranslations = await prisma.galleryTranslation.findMany()
     * 
     * // Get first 10 GalleryTranslations
     * const galleryTranslations = await prisma.galleryTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const galleryTranslationWithIdOnly = await prisma.galleryTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GalleryTranslationFindManyArgs>(args?: SelectSubset<T, GalleryTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GalleryTranslation.
     * @param {GalleryTranslationCreateArgs} args - Arguments to create a GalleryTranslation.
     * @example
     * // Create one GalleryTranslation
     * const GalleryTranslation = await prisma.galleryTranslation.create({
     *   data: {
     *     // ... data to create a GalleryTranslation
     *   }
     * })
     * 
     */
    create<T extends GalleryTranslationCreateArgs>(args: SelectSubset<T, GalleryTranslationCreateArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GalleryTranslations.
     * @param {GalleryTranslationCreateManyArgs} args - Arguments to create many GalleryTranslations.
     * @example
     * // Create many GalleryTranslations
     * const galleryTranslation = await prisma.galleryTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GalleryTranslationCreateManyArgs>(args?: SelectSubset<T, GalleryTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GalleryTranslation.
     * @param {GalleryTranslationDeleteArgs} args - Arguments to delete one GalleryTranslation.
     * @example
     * // Delete one GalleryTranslation
     * const GalleryTranslation = await prisma.galleryTranslation.delete({
     *   where: {
     *     // ... filter to delete one GalleryTranslation
     *   }
     * })
     * 
     */
    delete<T extends GalleryTranslationDeleteArgs>(args: SelectSubset<T, GalleryTranslationDeleteArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GalleryTranslation.
     * @param {GalleryTranslationUpdateArgs} args - Arguments to update one GalleryTranslation.
     * @example
     * // Update one GalleryTranslation
     * const galleryTranslation = await prisma.galleryTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GalleryTranslationUpdateArgs>(args: SelectSubset<T, GalleryTranslationUpdateArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GalleryTranslations.
     * @param {GalleryTranslationDeleteManyArgs} args - Arguments to filter GalleryTranslations to delete.
     * @example
     * // Delete a few GalleryTranslations
     * const { count } = await prisma.galleryTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GalleryTranslationDeleteManyArgs>(args?: SelectSubset<T, GalleryTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GalleryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GalleryTranslations
     * const galleryTranslation = await prisma.galleryTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GalleryTranslationUpdateManyArgs>(args: SelectSubset<T, GalleryTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GalleryTranslation.
     * @param {GalleryTranslationUpsertArgs} args - Arguments to update or create a GalleryTranslation.
     * @example
     * // Update or create a GalleryTranslation
     * const galleryTranslation = await prisma.galleryTranslation.upsert({
     *   create: {
     *     // ... data to create a GalleryTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GalleryTranslation we want to update
     *   }
     * })
     */
    upsert<T extends GalleryTranslationUpsertArgs>(args: SelectSubset<T, GalleryTranslationUpsertArgs<ExtArgs>>): Prisma__GalleryTranslationClient<$Result.GetResult<Prisma.$GalleryTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GalleryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationCountArgs} args - Arguments to filter GalleryTranslations to count.
     * @example
     * // Count the number of GalleryTranslations
     * const count = await prisma.galleryTranslation.count({
     *   where: {
     *     // ... the filter for the GalleryTranslations we want to count
     *   }
     * })
    **/
    count<T extends GalleryTranslationCountArgs>(
      args?: Subset<T, GalleryTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GalleryTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GalleryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GalleryTranslationAggregateArgs>(args: Subset<T, GalleryTranslationAggregateArgs>): Prisma.PrismaPromise<GetGalleryTranslationAggregateType<T>>

    /**
     * Group by GalleryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GalleryTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GalleryTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GalleryTranslationGroupByArgs['orderBy'] }
        : { orderBy?: GalleryTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GalleryTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGalleryTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GalleryTranslation model
   */
  readonly fields: GalleryTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GalleryTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GalleryTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GalleryTranslation model
   */
  interface GalleryTranslationFieldRefs {
    readonly id: FieldRef<"GalleryTranslation", 'String'>
    readonly galleryId: FieldRef<"GalleryTranslation", 'String'>
    readonly language: FieldRef<"GalleryTranslation", 'String'>
    readonly title: FieldRef<"GalleryTranslation", 'String'>
    readonly description: FieldRef<"GalleryTranslation", 'String'>
    readonly tags: FieldRef<"GalleryTranslation", 'String'>
    readonly isAutoTranslated: FieldRef<"GalleryTranslation", 'Boolean'>
    readonly createdAt: FieldRef<"GalleryTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"GalleryTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GalleryTranslation findUnique
   */
  export type GalleryTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * Filter, which GalleryTranslation to fetch.
     */
    where: GalleryTranslationWhereUniqueInput
  }

  /**
   * GalleryTranslation findUniqueOrThrow
   */
  export type GalleryTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * Filter, which GalleryTranslation to fetch.
     */
    where: GalleryTranslationWhereUniqueInput
  }

  /**
   * GalleryTranslation findFirst
   */
  export type GalleryTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * Filter, which GalleryTranslation to fetch.
     */
    where?: GalleryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryTranslations to fetch.
     */
    orderBy?: GalleryTranslationOrderByWithRelationInput | GalleryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GalleryTranslations.
     */
    cursor?: GalleryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GalleryTranslations.
     */
    distinct?: GalleryTranslationScalarFieldEnum | GalleryTranslationScalarFieldEnum[]
  }

  /**
   * GalleryTranslation findFirstOrThrow
   */
  export type GalleryTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * Filter, which GalleryTranslation to fetch.
     */
    where?: GalleryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryTranslations to fetch.
     */
    orderBy?: GalleryTranslationOrderByWithRelationInput | GalleryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GalleryTranslations.
     */
    cursor?: GalleryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GalleryTranslations.
     */
    distinct?: GalleryTranslationScalarFieldEnum | GalleryTranslationScalarFieldEnum[]
  }

  /**
   * GalleryTranslation findMany
   */
  export type GalleryTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * Filter, which GalleryTranslations to fetch.
     */
    where?: GalleryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GalleryTranslations to fetch.
     */
    orderBy?: GalleryTranslationOrderByWithRelationInput | GalleryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GalleryTranslations.
     */
    cursor?: GalleryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GalleryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GalleryTranslations.
     */
    skip?: number
    distinct?: GalleryTranslationScalarFieldEnum | GalleryTranslationScalarFieldEnum[]
  }

  /**
   * GalleryTranslation create
   */
  export type GalleryTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a GalleryTranslation.
     */
    data: XOR<GalleryTranslationCreateInput, GalleryTranslationUncheckedCreateInput>
  }

  /**
   * GalleryTranslation createMany
   */
  export type GalleryTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GalleryTranslations.
     */
    data: GalleryTranslationCreateManyInput | GalleryTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GalleryTranslation update
   */
  export type GalleryTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a GalleryTranslation.
     */
    data: XOR<GalleryTranslationUpdateInput, GalleryTranslationUncheckedUpdateInput>
    /**
     * Choose, which GalleryTranslation to update.
     */
    where: GalleryTranslationWhereUniqueInput
  }

  /**
   * GalleryTranslation updateMany
   */
  export type GalleryTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GalleryTranslations.
     */
    data: XOR<GalleryTranslationUpdateManyMutationInput, GalleryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which GalleryTranslations to update
     */
    where?: GalleryTranslationWhereInput
    /**
     * Limit how many GalleryTranslations to update.
     */
    limit?: number
  }

  /**
   * GalleryTranslation upsert
   */
  export type GalleryTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the GalleryTranslation to update in case it exists.
     */
    where: GalleryTranslationWhereUniqueInput
    /**
     * In case the GalleryTranslation found by the `where` argument doesn't exist, create a new GalleryTranslation with this data.
     */
    create: XOR<GalleryTranslationCreateInput, GalleryTranslationUncheckedCreateInput>
    /**
     * In case the GalleryTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GalleryTranslationUpdateInput, GalleryTranslationUncheckedUpdateInput>
  }

  /**
   * GalleryTranslation delete
   */
  export type GalleryTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
    /**
     * Filter which GalleryTranslation to delete.
     */
    where: GalleryTranslationWhereUniqueInput
  }

  /**
   * GalleryTranslation deleteMany
   */
  export type GalleryTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GalleryTranslations to delete
     */
    where?: GalleryTranslationWhereInput
    /**
     * Limit how many GalleryTranslations to delete.
     */
    limit?: number
  }

  /**
   * GalleryTranslation without action
   */
  export type GalleryTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GalleryTranslation
     */
    select?: GalleryTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GalleryTranslation
     */
    omit?: GalleryTranslationOmit<ExtArgs> | null
  }


  /**
   * Model SectionContentTranslation
   */

  export type AggregateSectionContentTranslation = {
    _count: SectionContentTranslationCountAggregateOutputType | null
    _min: SectionContentTranslationMinAggregateOutputType | null
    _max: SectionContentTranslationMaxAggregateOutputType | null
  }

  export type SectionContentTranslationMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    language: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    buttonText: string | null
    phone: string | null
    email: string | null
    destinations: string | null
    features: string | null
    stats: string | null
    packages: string | null
    testimonials: string | null
    posts: string | null
    items: string | null
    categories: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionContentTranslationMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    language: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    buttonText: string | null
    phone: string | null
    email: string | null
    destinations: string | null
    features: string | null
    stats: string | null
    packages: string | null
    testimonials: string | null
    posts: string | null
    items: string | null
    categories: string | null
    isAutoTranslated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SectionContentTranslationCountAggregateOutputType = {
    id: number
    sectionId: number
    language: number
    title: number
    subtitle: number
    description: number
    ctaText: number
    buttonText: number
    phone: number
    email: number
    destinations: number
    features: number
    stats: number
    packages: number
    testimonials: number
    posts: number
    items: number
    categories: number
    isAutoTranslated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SectionContentTranslationMinAggregateInputType = {
    id?: true
    sectionId?: true
    language?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    buttonText?: true
    phone?: true
    email?: true
    destinations?: true
    features?: true
    stats?: true
    packages?: true
    testimonials?: true
    posts?: true
    items?: true
    categories?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionContentTranslationMaxAggregateInputType = {
    id?: true
    sectionId?: true
    language?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    buttonText?: true
    phone?: true
    email?: true
    destinations?: true
    features?: true
    stats?: true
    packages?: true
    testimonials?: true
    posts?: true
    items?: true
    categories?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SectionContentTranslationCountAggregateInputType = {
    id?: true
    sectionId?: true
    language?: true
    title?: true
    subtitle?: true
    description?: true
    ctaText?: true
    buttonText?: true
    phone?: true
    email?: true
    destinations?: true
    features?: true
    stats?: true
    packages?: true
    testimonials?: true
    posts?: true
    items?: true
    categories?: true
    isAutoTranslated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SectionContentTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionContentTranslation to aggregate.
     */
    where?: SectionContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContentTranslations to fetch.
     */
    orderBy?: SectionContentTranslationOrderByWithRelationInput | SectionContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectionContentTranslations
    **/
    _count?: true | SectionContentTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionContentTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionContentTranslationMaxAggregateInputType
  }

  export type GetSectionContentTranslationAggregateType<T extends SectionContentTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateSectionContentTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectionContentTranslation[P]>
      : GetScalarType<T[P], AggregateSectionContentTranslation[P]>
  }




  export type SectionContentTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionContentTranslationWhereInput
    orderBy?: SectionContentTranslationOrderByWithAggregationInput | SectionContentTranslationOrderByWithAggregationInput[]
    by: SectionContentTranslationScalarFieldEnum[] | SectionContentTranslationScalarFieldEnum
    having?: SectionContentTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionContentTranslationCountAggregateInputType | true
    _min?: SectionContentTranslationMinAggregateInputType
    _max?: SectionContentTranslationMaxAggregateInputType
  }

  export type SectionContentTranslationGroupByOutputType = {
    id: string
    sectionId: string
    language: string
    title: string | null
    subtitle: string | null
    description: string | null
    ctaText: string | null
    buttonText: string | null
    phone: string | null
    email: string | null
    destinations: string | null
    features: string | null
    stats: string | null
    packages: string | null
    testimonials: string | null
    posts: string | null
    items: string | null
    categories: string | null
    isAutoTranslated: boolean
    createdAt: Date
    updatedAt: Date
    _count: SectionContentTranslationCountAggregateOutputType | null
    _min: SectionContentTranslationMinAggregateOutputType | null
    _max: SectionContentTranslationMaxAggregateOutputType | null
  }

  type GetSectionContentTranslationGroupByPayload<T extends SectionContentTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionContentTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionContentTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionContentTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], SectionContentTranslationGroupByOutputType[P]>
        }
      >
    >


  export type SectionContentTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    language?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    ctaText?: boolean
    buttonText?: boolean
    phone?: boolean
    email?: boolean
    destinations?: boolean
    features?: boolean
    stats?: boolean
    packages?: boolean
    testimonials?: boolean
    posts?: boolean
    items?: boolean
    categories?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sectionContentTranslation"]>



  export type SectionContentTranslationSelectScalar = {
    id?: boolean
    sectionId?: boolean
    language?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    ctaText?: boolean
    buttonText?: boolean
    phone?: boolean
    email?: boolean
    destinations?: boolean
    features?: boolean
    stats?: boolean
    packages?: boolean
    testimonials?: boolean
    posts?: boolean
    items?: boolean
    categories?: boolean
    isAutoTranslated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SectionContentTranslationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "language" | "title" | "subtitle" | "description" | "ctaText" | "buttonText" | "phone" | "email" | "destinations" | "features" | "stats" | "packages" | "testimonials" | "posts" | "items" | "categories" | "isAutoTranslated" | "createdAt" | "updatedAt", ExtArgs["result"]["sectionContentTranslation"]>

  export type $SectionContentTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SectionContentTranslation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      language: string
      title: string | null
      subtitle: string | null
      description: string | null
      ctaText: string | null
      buttonText: string | null
      phone: string | null
      email: string | null
      destinations: string | null
      features: string | null
      stats: string | null
      packages: string | null
      testimonials: string | null
      posts: string | null
      items: string | null
      categories: string | null
      isAutoTranslated: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sectionContentTranslation"]>
    composites: {}
  }

  type SectionContentTranslationGetPayload<S extends boolean | null | undefined | SectionContentTranslationDefaultArgs> = $Result.GetResult<Prisma.$SectionContentTranslationPayload, S>

  type SectionContentTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionContentTranslationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionContentTranslationCountAggregateInputType | true
    }

  export interface SectionContentTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectionContentTranslation'], meta: { name: 'SectionContentTranslation' } }
    /**
     * Find zero or one SectionContentTranslation that matches the filter.
     * @param {SectionContentTranslationFindUniqueArgs} args - Arguments to find a SectionContentTranslation
     * @example
     * // Get one SectionContentTranslation
     * const sectionContentTranslation = await prisma.sectionContentTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionContentTranslationFindUniqueArgs>(args: SelectSubset<T, SectionContentTranslationFindUniqueArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SectionContentTranslation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionContentTranslationFindUniqueOrThrowArgs} args - Arguments to find a SectionContentTranslation
     * @example
     * // Get one SectionContentTranslation
     * const sectionContentTranslation = await prisma.sectionContentTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionContentTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionContentTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectionContentTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationFindFirstArgs} args - Arguments to find a SectionContentTranslation
     * @example
     * // Get one SectionContentTranslation
     * const sectionContentTranslation = await prisma.sectionContentTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionContentTranslationFindFirstArgs>(args?: SelectSubset<T, SectionContentTranslationFindFirstArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SectionContentTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationFindFirstOrThrowArgs} args - Arguments to find a SectionContentTranslation
     * @example
     * // Get one SectionContentTranslation
     * const sectionContentTranslation = await prisma.sectionContentTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionContentTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionContentTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SectionContentTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectionContentTranslations
     * const sectionContentTranslations = await prisma.sectionContentTranslation.findMany()
     * 
     * // Get first 10 SectionContentTranslations
     * const sectionContentTranslations = await prisma.sectionContentTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionContentTranslationWithIdOnly = await prisma.sectionContentTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionContentTranslationFindManyArgs>(args?: SelectSubset<T, SectionContentTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SectionContentTranslation.
     * @param {SectionContentTranslationCreateArgs} args - Arguments to create a SectionContentTranslation.
     * @example
     * // Create one SectionContentTranslation
     * const SectionContentTranslation = await prisma.sectionContentTranslation.create({
     *   data: {
     *     // ... data to create a SectionContentTranslation
     *   }
     * })
     * 
     */
    create<T extends SectionContentTranslationCreateArgs>(args: SelectSubset<T, SectionContentTranslationCreateArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SectionContentTranslations.
     * @param {SectionContentTranslationCreateManyArgs} args - Arguments to create many SectionContentTranslations.
     * @example
     * // Create many SectionContentTranslations
     * const sectionContentTranslation = await prisma.sectionContentTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionContentTranslationCreateManyArgs>(args?: SelectSubset<T, SectionContentTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SectionContentTranslation.
     * @param {SectionContentTranslationDeleteArgs} args - Arguments to delete one SectionContentTranslation.
     * @example
     * // Delete one SectionContentTranslation
     * const SectionContentTranslation = await prisma.sectionContentTranslation.delete({
     *   where: {
     *     // ... filter to delete one SectionContentTranslation
     *   }
     * })
     * 
     */
    delete<T extends SectionContentTranslationDeleteArgs>(args: SelectSubset<T, SectionContentTranslationDeleteArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SectionContentTranslation.
     * @param {SectionContentTranslationUpdateArgs} args - Arguments to update one SectionContentTranslation.
     * @example
     * // Update one SectionContentTranslation
     * const sectionContentTranslation = await prisma.sectionContentTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionContentTranslationUpdateArgs>(args: SelectSubset<T, SectionContentTranslationUpdateArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SectionContentTranslations.
     * @param {SectionContentTranslationDeleteManyArgs} args - Arguments to filter SectionContentTranslations to delete.
     * @example
     * // Delete a few SectionContentTranslations
     * const { count } = await prisma.sectionContentTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionContentTranslationDeleteManyArgs>(args?: SelectSubset<T, SectionContentTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectionContentTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectionContentTranslations
     * const sectionContentTranslation = await prisma.sectionContentTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionContentTranslationUpdateManyArgs>(args: SelectSubset<T, SectionContentTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SectionContentTranslation.
     * @param {SectionContentTranslationUpsertArgs} args - Arguments to update or create a SectionContentTranslation.
     * @example
     * // Update or create a SectionContentTranslation
     * const sectionContentTranslation = await prisma.sectionContentTranslation.upsert({
     *   create: {
     *     // ... data to create a SectionContentTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectionContentTranslation we want to update
     *   }
     * })
     */
    upsert<T extends SectionContentTranslationUpsertArgs>(args: SelectSubset<T, SectionContentTranslationUpsertArgs<ExtArgs>>): Prisma__SectionContentTranslationClient<$Result.GetResult<Prisma.$SectionContentTranslationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SectionContentTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationCountArgs} args - Arguments to filter SectionContentTranslations to count.
     * @example
     * // Count the number of SectionContentTranslations
     * const count = await prisma.sectionContentTranslation.count({
     *   where: {
     *     // ... the filter for the SectionContentTranslations we want to count
     *   }
     * })
    **/
    count<T extends SectionContentTranslationCountArgs>(
      args?: Subset<T, SectionContentTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionContentTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectionContentTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionContentTranslationAggregateArgs>(args: Subset<T, SectionContentTranslationAggregateArgs>): Prisma.PrismaPromise<GetSectionContentTranslationAggregateType<T>>

    /**
     * Group by SectionContentTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionContentTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionContentTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionContentTranslationGroupByArgs['orderBy'] }
        : { orderBy?: SectionContentTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionContentTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionContentTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SectionContentTranslation model
   */
  readonly fields: SectionContentTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SectionContentTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionContentTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SectionContentTranslation model
   */
  interface SectionContentTranslationFieldRefs {
    readonly id: FieldRef<"SectionContentTranslation", 'String'>
    readonly sectionId: FieldRef<"SectionContentTranslation", 'String'>
    readonly language: FieldRef<"SectionContentTranslation", 'String'>
    readonly title: FieldRef<"SectionContentTranslation", 'String'>
    readonly subtitle: FieldRef<"SectionContentTranslation", 'String'>
    readonly description: FieldRef<"SectionContentTranslation", 'String'>
    readonly ctaText: FieldRef<"SectionContentTranslation", 'String'>
    readonly buttonText: FieldRef<"SectionContentTranslation", 'String'>
    readonly phone: FieldRef<"SectionContentTranslation", 'String'>
    readonly email: FieldRef<"SectionContentTranslation", 'String'>
    readonly destinations: FieldRef<"SectionContentTranslation", 'String'>
    readonly features: FieldRef<"SectionContentTranslation", 'String'>
    readonly stats: FieldRef<"SectionContentTranslation", 'String'>
    readonly packages: FieldRef<"SectionContentTranslation", 'String'>
    readonly testimonials: FieldRef<"SectionContentTranslation", 'String'>
    readonly posts: FieldRef<"SectionContentTranslation", 'String'>
    readonly items: FieldRef<"SectionContentTranslation", 'String'>
    readonly categories: FieldRef<"SectionContentTranslation", 'String'>
    readonly isAutoTranslated: FieldRef<"SectionContentTranslation", 'Boolean'>
    readonly createdAt: FieldRef<"SectionContentTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"SectionContentTranslation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SectionContentTranslation findUnique
   */
  export type SectionContentTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which SectionContentTranslation to fetch.
     */
    where: SectionContentTranslationWhereUniqueInput
  }

  /**
   * SectionContentTranslation findUniqueOrThrow
   */
  export type SectionContentTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which SectionContentTranslation to fetch.
     */
    where: SectionContentTranslationWhereUniqueInput
  }

  /**
   * SectionContentTranslation findFirst
   */
  export type SectionContentTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which SectionContentTranslation to fetch.
     */
    where?: SectionContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContentTranslations to fetch.
     */
    orderBy?: SectionContentTranslationOrderByWithRelationInput | SectionContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionContentTranslations.
     */
    cursor?: SectionContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionContentTranslations.
     */
    distinct?: SectionContentTranslationScalarFieldEnum | SectionContentTranslationScalarFieldEnum[]
  }

  /**
   * SectionContentTranslation findFirstOrThrow
   */
  export type SectionContentTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which SectionContentTranslation to fetch.
     */
    where?: SectionContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContentTranslations to fetch.
     */
    orderBy?: SectionContentTranslationOrderByWithRelationInput | SectionContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionContentTranslations.
     */
    cursor?: SectionContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContentTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionContentTranslations.
     */
    distinct?: SectionContentTranslationScalarFieldEnum | SectionContentTranslationScalarFieldEnum[]
  }

  /**
   * SectionContentTranslation findMany
   */
  export type SectionContentTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * Filter, which SectionContentTranslations to fetch.
     */
    where?: SectionContentTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionContentTranslations to fetch.
     */
    orderBy?: SectionContentTranslationOrderByWithRelationInput | SectionContentTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectionContentTranslations.
     */
    cursor?: SectionContentTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionContentTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionContentTranslations.
     */
    skip?: number
    distinct?: SectionContentTranslationScalarFieldEnum | SectionContentTranslationScalarFieldEnum[]
  }

  /**
   * SectionContentTranslation create
   */
  export type SectionContentTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * The data needed to create a SectionContentTranslation.
     */
    data: XOR<SectionContentTranslationCreateInput, SectionContentTranslationUncheckedCreateInput>
  }

  /**
   * SectionContentTranslation createMany
   */
  export type SectionContentTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SectionContentTranslations.
     */
    data: SectionContentTranslationCreateManyInput | SectionContentTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SectionContentTranslation update
   */
  export type SectionContentTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * The data needed to update a SectionContentTranslation.
     */
    data: XOR<SectionContentTranslationUpdateInput, SectionContentTranslationUncheckedUpdateInput>
    /**
     * Choose, which SectionContentTranslation to update.
     */
    where: SectionContentTranslationWhereUniqueInput
  }

  /**
   * SectionContentTranslation updateMany
   */
  export type SectionContentTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SectionContentTranslations.
     */
    data: XOR<SectionContentTranslationUpdateManyMutationInput, SectionContentTranslationUncheckedUpdateManyInput>
    /**
     * Filter which SectionContentTranslations to update
     */
    where?: SectionContentTranslationWhereInput
    /**
     * Limit how many SectionContentTranslations to update.
     */
    limit?: number
  }

  /**
   * SectionContentTranslation upsert
   */
  export type SectionContentTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * The filter to search for the SectionContentTranslation to update in case it exists.
     */
    where: SectionContentTranslationWhereUniqueInput
    /**
     * In case the SectionContentTranslation found by the `where` argument doesn't exist, create a new SectionContentTranslation with this data.
     */
    create: XOR<SectionContentTranslationCreateInput, SectionContentTranslationUncheckedCreateInput>
    /**
     * In case the SectionContentTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionContentTranslationUpdateInput, SectionContentTranslationUncheckedUpdateInput>
  }

  /**
   * SectionContentTranslation delete
   */
  export type SectionContentTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
    /**
     * Filter which SectionContentTranslation to delete.
     */
    where: SectionContentTranslationWhereUniqueInput
  }

  /**
   * SectionContentTranslation deleteMany
   */
  export type SectionContentTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionContentTranslations to delete
     */
    where?: SectionContentTranslationWhereInput
    /**
     * Limit how many SectionContentTranslations to delete.
     */
    limit?: number
  }

  /**
   * SectionContentTranslation without action
   */
  export type SectionContentTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionContentTranslation
     */
    select?: SectionContentTranslationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SectionContentTranslation
     */
    omit?: SectionContentTranslationOmit<ExtArgs> | null
  }


  /**
   * Model ApiKeySettings
   */

  export type AggregateApiKeySettings = {
    _count: ApiKeySettingsCountAggregateOutputType | null
    _min: ApiKeySettingsMinAggregateOutputType | null
    _max: ApiKeySettingsMaxAggregateOutputType | null
  }

  export type ApiKeySettingsMinAggregateOutputType = {
    id: string | null
    keys: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeySettingsMaxAggregateOutputType = {
    id: string | null
    keys: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ApiKeySettingsCountAggregateOutputType = {
    id: number
    keys: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ApiKeySettingsMinAggregateInputType = {
    id?: true
    keys?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ApiKeySettingsMaxAggregateInputType = {
    id?: true
    keys?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ApiKeySettingsCountAggregateInputType = {
    id?: true
    keys?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeySettings to aggregate.
     */
    where?: ApiKeySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeySettings to fetch.
     */
    orderBy?: ApiKeySettingsOrderByWithRelationInput | ApiKeySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeySettings
    **/
    _count?: true | ApiKeySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeySettingsMaxAggregateInputType
  }

  export type GetApiKeySettingsAggregateType<T extends ApiKeySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKeySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKeySettings[P]>
      : GetScalarType<T[P], AggregateApiKeySettings[P]>
  }




  export type ApiKeySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeySettingsWhereInput
    orderBy?: ApiKeySettingsOrderByWithAggregationInput | ApiKeySettingsOrderByWithAggregationInput[]
    by: ApiKeySettingsScalarFieldEnum[] | ApiKeySettingsScalarFieldEnum
    having?: ApiKeySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeySettingsCountAggregateInputType | true
    _min?: ApiKeySettingsMinAggregateInputType
    _max?: ApiKeySettingsMaxAggregateInputType
  }

  export type ApiKeySettingsGroupByOutputType = {
    id: string
    keys: string | null
    updatedAt: Date
    createdAt: Date
    _count: ApiKeySettingsCountAggregateOutputType | null
    _min: ApiKeySettingsMinAggregateOutputType | null
    _max: ApiKeySettingsMaxAggregateOutputType | null
  }

  type GetApiKeySettingsGroupByPayload<T extends ApiKeySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeySettingsGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keys?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["apiKeySettings"]>



  export type ApiKeySettingsSelectScalar = {
    id?: boolean
    keys?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ApiKeySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keys" | "updatedAt" | "createdAt", ExtArgs["result"]["apiKeySettings"]>

  export type $ApiKeySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKeySettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keys: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["apiKeySettings"]>
    composites: {}
  }

  type ApiKeySettingsGetPayload<S extends boolean | null | undefined | ApiKeySettingsDefaultArgs> = $Result.GetResult<Prisma.$ApiKeySettingsPayload, S>

  type ApiKeySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeySettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeySettingsCountAggregateInputType | true
    }

  export interface ApiKeySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKeySettings'], meta: { name: 'ApiKeySettings' } }
    /**
     * Find zero or one ApiKeySettings that matches the filter.
     * @param {ApiKeySettingsFindUniqueArgs} args - Arguments to find a ApiKeySettings
     * @example
     * // Get one ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeySettingsFindUniqueArgs>(args: SelectSubset<T, ApiKeySettingsFindUniqueArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKeySettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeySettingsFindUniqueOrThrowArgs} args - Arguments to find a ApiKeySettings
     * @example
     * // Get one ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKeySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsFindFirstArgs} args - Arguments to find a ApiKeySettings
     * @example
     * // Get one ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeySettingsFindFirstArgs>(args?: SelectSubset<T, ApiKeySettingsFindFirstArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKeySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsFindFirstOrThrowArgs} args - Arguments to find a ApiKeySettings
     * @example
     * // Get one ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.findMany()
     * 
     * // Get first 10 ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeySettingsWithIdOnly = await prisma.apiKeySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeySettingsFindManyArgs>(args?: SelectSubset<T, ApiKeySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKeySettings.
     * @param {ApiKeySettingsCreateArgs} args - Arguments to create a ApiKeySettings.
     * @example
     * // Create one ApiKeySettings
     * const ApiKeySettings = await prisma.apiKeySettings.create({
     *   data: {
     *     // ... data to create a ApiKeySettings
     *   }
     * })
     * 
     */
    create<T extends ApiKeySettingsCreateArgs>(args: SelectSubset<T, ApiKeySettingsCreateArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeySettings.
     * @param {ApiKeySettingsCreateManyArgs} args - Arguments to create many ApiKeySettings.
     * @example
     * // Create many ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeySettingsCreateManyArgs>(args?: SelectSubset<T, ApiKeySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ApiKeySettings.
     * @param {ApiKeySettingsDeleteArgs} args - Arguments to delete one ApiKeySettings.
     * @example
     * // Delete one ApiKeySettings
     * const ApiKeySettings = await prisma.apiKeySettings.delete({
     *   where: {
     *     // ... filter to delete one ApiKeySettings
     *   }
     * })
     * 
     */
    delete<T extends ApiKeySettingsDeleteArgs>(args: SelectSubset<T, ApiKeySettingsDeleteArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKeySettings.
     * @param {ApiKeySettingsUpdateArgs} args - Arguments to update one ApiKeySettings.
     * @example
     * // Update one ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeySettingsUpdateArgs>(args: SelectSubset<T, ApiKeySettingsUpdateArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeySettings.
     * @param {ApiKeySettingsDeleteManyArgs} args - Arguments to filter ApiKeySettings to delete.
     * @example
     * // Delete a few ApiKeySettings
     * const { count } = await prisma.apiKeySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeySettingsDeleteManyArgs>(args?: SelectSubset<T, ApiKeySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeySettingsUpdateManyArgs>(args: SelectSubset<T, ApiKeySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKeySettings.
     * @param {ApiKeySettingsUpsertArgs} args - Arguments to update or create a ApiKeySettings.
     * @example
     * // Update or create a ApiKeySettings
     * const apiKeySettings = await prisma.apiKeySettings.upsert({
     *   create: {
     *     // ... data to create a ApiKeySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKeySettings we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeySettingsUpsertArgs>(args: SelectSubset<T, ApiKeySettingsUpsertArgs<ExtArgs>>): Prisma__ApiKeySettingsClient<$Result.GetResult<Prisma.$ApiKeySettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsCountArgs} args - Arguments to filter ApiKeySettings to count.
     * @example
     * // Count the number of ApiKeySettings
     * const count = await prisma.apiKeySettings.count({
     *   where: {
     *     // ... the filter for the ApiKeySettings we want to count
     *   }
     * })
    **/
    count<T extends ApiKeySettingsCountArgs>(
      args?: Subset<T, ApiKeySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKeySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeySettingsAggregateArgs>(args: Subset<T, ApiKeySettingsAggregateArgs>): Prisma.PrismaPromise<GetApiKeySettingsAggregateType<T>>

    /**
     * Group by ApiKeySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeySettingsGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKeySettings model
   */
  readonly fields: ApiKeySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKeySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKeySettings model
   */
  interface ApiKeySettingsFieldRefs {
    readonly id: FieldRef<"ApiKeySettings", 'String'>
    readonly keys: FieldRef<"ApiKeySettings", 'String'>
    readonly updatedAt: FieldRef<"ApiKeySettings", 'DateTime'>
    readonly createdAt: FieldRef<"ApiKeySettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKeySettings findUnique
   */
  export type ApiKeySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * Filter, which ApiKeySettings to fetch.
     */
    where: ApiKeySettingsWhereUniqueInput
  }

  /**
   * ApiKeySettings findUniqueOrThrow
   */
  export type ApiKeySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * Filter, which ApiKeySettings to fetch.
     */
    where: ApiKeySettingsWhereUniqueInput
  }

  /**
   * ApiKeySettings findFirst
   */
  export type ApiKeySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * Filter, which ApiKeySettings to fetch.
     */
    where?: ApiKeySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeySettings to fetch.
     */
    orderBy?: ApiKeySettingsOrderByWithRelationInput | ApiKeySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeySettings.
     */
    cursor?: ApiKeySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeySettings.
     */
    distinct?: ApiKeySettingsScalarFieldEnum | ApiKeySettingsScalarFieldEnum[]
  }

  /**
   * ApiKeySettings findFirstOrThrow
   */
  export type ApiKeySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * Filter, which ApiKeySettings to fetch.
     */
    where?: ApiKeySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeySettings to fetch.
     */
    orderBy?: ApiKeySettingsOrderByWithRelationInput | ApiKeySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeySettings.
     */
    cursor?: ApiKeySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeySettings.
     */
    distinct?: ApiKeySettingsScalarFieldEnum | ApiKeySettingsScalarFieldEnum[]
  }

  /**
   * ApiKeySettings findMany
   */
  export type ApiKeySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * Filter, which ApiKeySettings to fetch.
     */
    where?: ApiKeySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeySettings to fetch.
     */
    orderBy?: ApiKeySettingsOrderByWithRelationInput | ApiKeySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeySettings.
     */
    cursor?: ApiKeySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeySettings.
     */
    skip?: number
    distinct?: ApiKeySettingsScalarFieldEnum | ApiKeySettingsScalarFieldEnum[]
  }

  /**
   * ApiKeySettings create
   */
  export type ApiKeySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a ApiKeySettings.
     */
    data: XOR<ApiKeySettingsCreateInput, ApiKeySettingsUncheckedCreateInput>
  }

  /**
   * ApiKeySettings createMany
   */
  export type ApiKeySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeySettings.
     */
    data: ApiKeySettingsCreateManyInput | ApiKeySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKeySettings update
   */
  export type ApiKeySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a ApiKeySettings.
     */
    data: XOR<ApiKeySettingsUpdateInput, ApiKeySettingsUncheckedUpdateInput>
    /**
     * Choose, which ApiKeySettings to update.
     */
    where: ApiKeySettingsWhereUniqueInput
  }

  /**
   * ApiKeySettings updateMany
   */
  export type ApiKeySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeySettings.
     */
    data: XOR<ApiKeySettingsUpdateManyMutationInput, ApiKeySettingsUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeySettings to update
     */
    where?: ApiKeySettingsWhereInput
    /**
     * Limit how many ApiKeySettings to update.
     */
    limit?: number
  }

  /**
   * ApiKeySettings upsert
   */
  export type ApiKeySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the ApiKeySettings to update in case it exists.
     */
    where: ApiKeySettingsWhereUniqueInput
    /**
     * In case the ApiKeySettings found by the `where` argument doesn't exist, create a new ApiKeySettings with this data.
     */
    create: XOR<ApiKeySettingsCreateInput, ApiKeySettingsUncheckedCreateInput>
    /**
     * In case the ApiKeySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeySettingsUpdateInput, ApiKeySettingsUncheckedUpdateInput>
  }

  /**
   * ApiKeySettings delete
   */
  export type ApiKeySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
    /**
     * Filter which ApiKeySettings to delete.
     */
    where: ApiKeySettingsWhereUniqueInput
  }

  /**
   * ApiKeySettings deleteMany
   */
  export type ApiKeySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeySettings to delete
     */
    where?: ApiKeySettingsWhereInput
    /**
     * Limit how many ApiKeySettings to delete.
     */
    limit?: number
  }

  /**
   * ApiKeySettings without action
   */
  export type ApiKeySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeySettings
     */
    select?: ApiKeySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKeySettings
     */
    omit?: ApiKeySettingsOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    loginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    loginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    displayName: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    status: string | null
    avatar: string | null
    bio: string | null
    website: string | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    loginAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    displayName: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    status: string | null
    avatar: string | null
    bio: string | null
    website: string | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    loginAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    displayName: number
    firstName: number
    lastName: number
    role: number
    status: number
    avatar: number
    bio: number
    website: number
    lastLoginAt: number
    lastLoginIp: number
    loginAttempts: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    loginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    loginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    displayName?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    avatar?: true
    bio?: true
    website?: true
    lastLoginAt?: true
    lastLoginIp?: true
    loginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    displayName?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    avatar?: true
    bio?: true
    website?: true
    lastLoginAt?: true
    lastLoginIp?: true
    loginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    displayName?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    avatar?: true
    bio?: true
    website?: true
    lastLoginAt?: true
    lastLoginIp?: true
    loginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    displayName: string
    firstName: string | null
    lastName: string | null
    role: string
    status: string
    avatar: string | null
    bio: string | null
    website: string | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    loginAttempts: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    avatar?: boolean
    bio?: boolean
    website?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    displayName?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    avatar?: boolean
    bio?: boolean
    website?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "displayName" | "firstName" | "lastName" | "role" | "status" | "avatar" | "bio" | "website" | "lastLoginAt" | "lastLoginIp" | "loginAttempts" | "lockedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      displayName: string
      firstName: string | null
      lastName: string | null
      role: string
      status: string
      avatar: string | null
      bio: string | null
      website: string | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      loginAttempts: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly website: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginIp: FieldRef<"User", 'String'>
    readonly loginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SectionContentScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    ctaText: 'ctaText',
    ctaLink: 'ctaLink',
    buttonText: 'buttonText',
    image: 'image',
    logo: 'logo',
    phone: 'phone',
    email: 'email',
    backgroundVideo: 'backgroundVideo',
    destinations: 'destinations',
    features: 'features',
    stats: 'stats',
    packages: 'packages',
    testimonials: 'testimonials',
    posts: 'posts',
    items: 'items',
    categories: 'categories',
    displayCount: 'displayCount',
    featuredOnly: 'featuredOnly',
    category: 'category',
    sortBy: 'sortBy',
    layoutStyle: 'layoutStyle',
    showFilters: 'showFilters',
    enableLightbox: 'enableLightbox',
    enableAutoSlide: 'enableAutoSlide',
    autoSlideInterval: 'autoSlideInterval',
    transitionEffect: 'transitionEffect',
    animationSpeed: 'animationSpeed',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type SectionContentScalarFieldEnum = (typeof SectionContentScalarFieldEnum)[keyof typeof SectionContentScalarFieldEnum]


  export const DestinationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    category: 'category',
    rating: 'rating',
    visitors: 'visitors',
    duration: 'duration',
    price: 'price',
    description: 'description',
    highlights: 'highlights',
    image: 'image',
    featured: 'featured',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type DestinationScalarFieldEnum = (typeof DestinationScalarFieldEnum)[keyof typeof DestinationScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    duration: 'duration',
    price: 'price',
    originalPrice: 'originalPrice',
    discount: 'discount',
    rating: 'rating',
    reviewCount: 'reviewCount',
    category: 'category',
    description: 'description',
    longDescription: 'longDescription',
    destinations: 'destinations',
    includes: 'includes',
    excludes: 'excludes',
    highlights: 'highlights',
    itinerary: 'itinerary',
    gallery: 'gallery',
    faqs: 'faqs',
    groupSize: 'groupSize',
    difficulty: 'difficulty',
    bestFor: 'bestFor',
    image: 'image',
    departure: 'departure',
    return: 'return',
    totalPeople: 'totalPeople',
    location: 'location',
    mapEmbedUrl: 'mapEmbedUrl',
    featured: 'featured',
    available: 'available',
    status: 'status',
    localizedUrls: 'localizedUrls',
    urlPathEn: 'urlPathEn',
    urlPathDe: 'urlPathDe',
    urlPathNl: 'urlPathNl',
    urlPathZh: 'urlPathZh',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    author: 'author',
    publishDate: 'publishDate',
    readTime: 'readTime',
    category: 'category',
    tags: 'tags',
    image: 'image',
    featured: 'featured',
    status: 'status',
    localizedUrls: 'localizedUrls',
    urlPathEn: 'urlPathEn',
    urlPathDe: 'urlPathDe',
    urlPathNl: 'urlPathNl',
    urlPathZh: 'urlPathZh',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    content: 'content',
    rating: 'rating',
    image: 'image',
    packageName: 'packageName',
    location: 'location',
    status: 'status',
    featured: 'featured',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const GalleryItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    category: 'category',
    image: 'image',
    description: 'description',
    tags: 'tags',
    likes: 'likes',
    views: 'views',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type GalleryItemScalarFieldEnum = (typeof GalleryItemScalarFieldEnum)[keyof typeof GalleryItemScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    whatsappNumber: 'whatsappNumber',
    whatsappGreeting: 'whatsappGreeting',
    providerName: 'providerName',
    memberSince: 'memberSince',
    providerPhone: 'providerPhone',
    providerEmail: 'providerEmail',
    brandName: 'brandName',
    siteLogo: 'siteLogo',
    siteTagline: 'siteTagline',
    favicon: 'favicon',
    siteName: 'siteName',
    siteDescription: 'siteDescription',
    defaultOgImage: 'defaultOgImage',
    siteUrl: 'siteUrl',
    googleSiteVerification: 'googleSiteVerification',
    bingSiteVerification: 'bingSiteVerification',
    activeTemplate: 'activeTemplate',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const LocalizedUrlSettingsScalarFieldEnum: {
    id: 'id',
    contentType: 'contentType',
    urlPathId: 'urlPathId',
    urlPathEn: 'urlPathEn',
    urlPathDe: 'urlPathDe',
    urlPathNl: 'urlPathNl',
    urlPathZh: 'urlPathZh',
    autoGenerate: 'autoGenerate',
    customPattern: 'customPattern',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type LocalizedUrlSettingsScalarFieldEnum = (typeof LocalizedUrlSettingsScalarFieldEnum)[keyof typeof LocalizedUrlSettingsScalarFieldEnum]


  export const SeoDataScalarFieldEnum: {
    id: 'id',
    pageType: 'pageType',
    pageSlug: 'pageSlug',
    title: 'title',
    description: 'description',
    keywords: 'keywords',
    canonicalUrl: 'canonicalUrl',
    ogImage: 'ogImage',
    ogType: 'ogType',
    noIndex: 'noIndex',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type SeoDataScalarFieldEnum = (typeof SeoDataScalarFieldEnum)[keyof typeof SeoDataScalarFieldEnum]


  export const SitemapLogScalarFieldEnum: {
    id: 'id',
    totalPages: 'totalPages',
    lastGenerated: 'lastGenerated',
    googlePinged: 'googlePinged',
    bingPinged: 'bingPinged',
    createdAt: 'createdAt'
  };

  export type SitemapLogScalarFieldEnum = (typeof SitemapLogScalarFieldEnum)[keyof typeof SitemapLogScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    packageName: 'packageName',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerPhone: 'customerPhone',
    checkInDate: 'checkInDate',
    checkOutDate: 'checkOutDate',
    adults: 'adults',
    children: 'children',
    infants: 'infants',
    totalPrice: 'totalPrice',
    status: 'status',
    paymentStatus: 'paymentStatus',
    specialRequests: 'specialRequests',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const NavigationMenuScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NavigationMenuScalarFieldEnum = (typeof NavigationMenuScalarFieldEnum)[keyof typeof NavigationMenuScalarFieldEnum]


  export const NavigationItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    parentId: 'parentId',
    order: 'order',
    isActive: 'isActive',
    isExternal: 'isExternal',
    target: 'target',
    iconType: 'iconType',
    iconName: 'iconName',
    iconUrl: 'iconUrl',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    hoverColor: 'hoverColor',
    activeColor: 'activeColor',
    fontFamily: 'fontFamily',
    fontSize: 'fontSize',
    fontWeight: 'fontWeight',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NavigationItemScalarFieldEnum = (typeof NavigationItemScalarFieldEnum)[keyof typeof NavigationItemScalarFieldEnum]


  export const NavigationItemTranslationScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    language: 'language',
    title: 'title',
    url: 'url'
  };

  export type NavigationItemTranslationScalarFieldEnum = (typeof NavigationItemTranslationScalarFieldEnum)[keyof typeof NavigationItemTranslationScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    displayType: 'displayType',
    imageUrl: 'imageUrl',
    backgroundColor: 'backgroundColor',
    overlayColor: 'overlayColor',
    ctaText: 'ctaText',
    ctaUrl: 'ctaUrl',
    isActive: 'isActive',
    customHtml: 'customHtml',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const BannerTranslationScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    language: 'language',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    ctaText: 'ctaText',
    ctaUrl: 'ctaUrl',
    imageUrl: 'imageUrl'
  };

  export type BannerTranslationScalarFieldEnum = (typeof BannerTranslationScalarFieldEnum)[keyof typeof BannerTranslationScalarFieldEnum]


  export const BannerPlacementScalarFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    location: 'location',
    position: 'position',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type BannerPlacementScalarFieldEnum = (typeof BannerPlacementScalarFieldEnum)[keyof typeof BannerPlacementScalarFieldEnum]


  export const TopbarSettingsScalarFieldEnum: {
    id: 'id',
    isEnabled: 'isEnabled',
    phone: 'phone',
    email: 'email',
    announcement: 'announcement',
    showLanguage: 'showLanguage',
    showSocial: 'showSocial',
    socialLinks: 'socialLinks',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type TopbarSettingsScalarFieldEnum = (typeof TopbarSettingsScalarFieldEnum)[keyof typeof TopbarSettingsScalarFieldEnum]


  export const MobileMenuSettingsScalarFieldEnum: {
    id: 'id',
    menuType: 'menuType',
    position: 'position',
    animation: 'animation',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    iconColor: 'iconColor',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type MobileMenuSettingsScalarFieldEnum = (typeof MobileMenuSettingsScalarFieldEnum)[keyof typeof MobileMenuSettingsScalarFieldEnum]


  export const LanguageSettingsScalarFieldEnum: {
    id: 'id',
    defaultLanguage: 'defaultLanguage',
    supportedLanguages: 'supportedLanguages',
    showLanguageSwitcher: 'showLanguageSwitcher',
    languageSwitcherPosition: 'languageSwitcherPosition',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type LanguageSettingsScalarFieldEnum = (typeof LanguageSettingsScalarFieldEnum)[keyof typeof LanguageSettingsScalarFieldEnum]


  export const CustomIconScalarFieldEnum: {
    id: 'id',
    name: 'name',
    svgContent: 'svgContent',
    category: 'category',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomIconScalarFieldEnum = (typeof CustomIconScalarFieldEnum)[keyof typeof CustomIconScalarFieldEnum]


  export const PackageTranslationScalarFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    language: 'language',
    title: 'title',
    description: 'description',
    longDescription: 'longDescription',
    destinations: 'destinations',
    includes: 'includes',
    excludes: 'excludes',
    highlights: 'highlights',
    itinerary: 'itinerary',
    faqs: 'faqs',
    groupSize: 'groupSize',
    difficulty: 'difficulty',
    bestFor: 'bestFor',
    departure: 'departure',
    return: 'return',
    location: 'location',
    isAutoTranslated: 'isAutoTranslated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackageTranslationScalarFieldEnum = (typeof PackageTranslationScalarFieldEnum)[keyof typeof PackageTranslationScalarFieldEnum]


  export const BlogTranslationScalarFieldEnum: {
    id: 'id',
    blogId: 'blogId',
    language: 'language',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    category: 'category',
    tags: 'tags',
    isAutoTranslated: 'isAutoTranslated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogTranslationScalarFieldEnum = (typeof BlogTranslationScalarFieldEnum)[keyof typeof BlogTranslationScalarFieldEnum]


  export const TestimonialTranslationScalarFieldEnum: {
    id: 'id',
    testimonialId: 'testimonialId',
    language: 'language',
    name: 'name',
    role: 'role',
    content: 'content',
    packageName: 'packageName',
    location: 'location',
    isAutoTranslated: 'isAutoTranslated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestimonialTranslationScalarFieldEnum = (typeof TestimonialTranslationScalarFieldEnum)[keyof typeof TestimonialTranslationScalarFieldEnum]


  export const GalleryTranslationScalarFieldEnum: {
    id: 'id',
    galleryId: 'galleryId',
    language: 'language',
    title: 'title',
    description: 'description',
    tags: 'tags',
    isAutoTranslated: 'isAutoTranslated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GalleryTranslationScalarFieldEnum = (typeof GalleryTranslationScalarFieldEnum)[keyof typeof GalleryTranslationScalarFieldEnum]


  export const SectionContentTranslationScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    language: 'language',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    ctaText: 'ctaText',
    buttonText: 'buttonText',
    phone: 'phone',
    email: 'email',
    destinations: 'destinations',
    features: 'features',
    stats: 'stats',
    packages: 'packages',
    testimonials: 'testimonials',
    posts: 'posts',
    items: 'items',
    categories: 'categories',
    isAutoTranslated: 'isAutoTranslated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SectionContentTranslationScalarFieldEnum = (typeof SectionContentTranslationScalarFieldEnum)[keyof typeof SectionContentTranslationScalarFieldEnum]


  export const ApiKeySettingsScalarFieldEnum: {
    id: 'id',
    keys: 'keys',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ApiKeySettingsScalarFieldEnum = (typeof ApiKeySettingsScalarFieldEnum)[keyof typeof ApiKeySettingsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    displayName: 'displayName',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    avatar: 'avatar',
    bio: 'bio',
    website: 'website',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    loginAttempts: 'loginAttempts',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const SectionContentOrderByRelevanceFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    ctaText: 'ctaText',
    ctaLink: 'ctaLink',
    buttonText: 'buttonText',
    image: 'image',
    logo: 'logo',
    phone: 'phone',
    email: 'email',
    backgroundVideo: 'backgroundVideo',
    destinations: 'destinations',
    features: 'features',
    stats: 'stats',
    packages: 'packages',
    testimonials: 'testimonials',
    posts: 'posts',
    items: 'items',
    categories: 'categories',
    category: 'category',
    sortBy: 'sortBy',
    layoutStyle: 'layoutStyle',
    transitionEffect: 'transitionEffect',
    animationSpeed: 'animationSpeed'
  };

  export type SectionContentOrderByRelevanceFieldEnum = (typeof SectionContentOrderByRelevanceFieldEnum)[keyof typeof SectionContentOrderByRelevanceFieldEnum]


  export const DestinationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    category: 'category',
    visitors: 'visitors',
    duration: 'duration',
    price: 'price',
    description: 'description',
    highlights: 'highlights',
    image: 'image'
  };

  export type DestinationOrderByRelevanceFieldEnum = (typeof DestinationOrderByRelevanceFieldEnum)[keyof typeof DestinationOrderByRelevanceFieldEnum]


  export const PackageOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    duration: 'duration',
    discount: 'discount',
    category: 'category',
    description: 'description',
    longDescription: 'longDescription',
    destinations: 'destinations',
    includes: 'includes',
    excludes: 'excludes',
    highlights: 'highlights',
    itinerary: 'itinerary',
    gallery: 'gallery',
    faqs: 'faqs',
    groupSize: 'groupSize',
    difficulty: 'difficulty',
    bestFor: 'bestFor',
    image: 'image',
    departure: 'departure',
    return: 'return',
    location: 'location',
    mapEmbedUrl: 'mapEmbedUrl',
    status: 'status',
    localizedUrls: 'localizedUrls',
    urlPathEn: 'urlPathEn',
    urlPathDe: 'urlPathDe',
    urlPathNl: 'urlPathNl',
    urlPathZh: 'urlPathZh'
  };

  export type PackageOrderByRelevanceFieldEnum = (typeof PackageOrderByRelevanceFieldEnum)[keyof typeof PackageOrderByRelevanceFieldEnum]


  export const BlogOrderByRelevanceFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    author: 'author',
    readTime: 'readTime',
    category: 'category',
    tags: 'tags',
    image: 'image',
    status: 'status',
    localizedUrls: 'localizedUrls',
    urlPathEn: 'urlPathEn',
    urlPathDe: 'urlPathDe',
    urlPathNl: 'urlPathNl',
    urlPathZh: 'urlPathZh'
  };

  export type BlogOrderByRelevanceFieldEnum = (typeof BlogOrderByRelevanceFieldEnum)[keyof typeof BlogOrderByRelevanceFieldEnum]


  export const TestimonialOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    content: 'content',
    image: 'image',
    packageName: 'packageName',
    location: 'location',
    status: 'status'
  };

  export type TestimonialOrderByRelevanceFieldEnum = (typeof TestimonialOrderByRelevanceFieldEnum)[keyof typeof TestimonialOrderByRelevanceFieldEnum]


  export const GalleryItemOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    category: 'category',
    image: 'image',
    description: 'description',
    tags: 'tags'
  };

  export type GalleryItemOrderByRelevanceFieldEnum = (typeof GalleryItemOrderByRelevanceFieldEnum)[keyof typeof GalleryItemOrderByRelevanceFieldEnum]


  export const SettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    whatsappNumber: 'whatsappNumber',
    whatsappGreeting: 'whatsappGreeting',
    providerName: 'providerName',
    memberSince: 'memberSince',
    providerPhone: 'providerPhone',
    providerEmail: 'providerEmail',
    brandName: 'brandName',
    siteLogo: 'siteLogo',
    siteTagline: 'siteTagline',
    favicon: 'favicon',
    siteName: 'siteName',
    siteDescription: 'siteDescription',
    defaultOgImage: 'defaultOgImage',
    siteUrl: 'siteUrl',
    googleSiteVerification: 'googleSiteVerification',
    bingSiteVerification: 'bingSiteVerification',
    activeTemplate: 'activeTemplate'
  };

  export type SettingsOrderByRelevanceFieldEnum = (typeof SettingsOrderByRelevanceFieldEnum)[keyof typeof SettingsOrderByRelevanceFieldEnum]


  export const LocalizedUrlSettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    contentType: 'contentType',
    urlPathId: 'urlPathId',
    urlPathEn: 'urlPathEn',
    urlPathDe: 'urlPathDe',
    urlPathNl: 'urlPathNl',
    urlPathZh: 'urlPathZh',
    customPattern: 'customPattern'
  };

  export type LocalizedUrlSettingsOrderByRelevanceFieldEnum = (typeof LocalizedUrlSettingsOrderByRelevanceFieldEnum)[keyof typeof LocalizedUrlSettingsOrderByRelevanceFieldEnum]


  export const SeoDataOrderByRelevanceFieldEnum: {
    id: 'id',
    pageType: 'pageType',
    pageSlug: 'pageSlug',
    title: 'title',
    description: 'description',
    keywords: 'keywords',
    canonicalUrl: 'canonicalUrl',
    ogImage: 'ogImage',
    ogType: 'ogType'
  };

  export type SeoDataOrderByRelevanceFieldEnum = (typeof SeoDataOrderByRelevanceFieldEnum)[keyof typeof SeoDataOrderByRelevanceFieldEnum]


  export const SitemapLogOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type SitemapLogOrderByRelevanceFieldEnum = (typeof SitemapLogOrderByRelevanceFieldEnum)[keyof typeof SitemapLogOrderByRelevanceFieldEnum]


  export const BookingOrderByRelevanceFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    packageName: 'packageName',
    customerName: 'customerName',
    customerEmail: 'customerEmail',
    customerPhone: 'customerPhone',
    status: 'status',
    paymentStatus: 'paymentStatus',
    specialRequests: 'specialRequests'
  };

  export type BookingOrderByRelevanceFieldEnum = (typeof BookingOrderByRelevanceFieldEnum)[keyof typeof BookingOrderByRelevanceFieldEnum]


  export const NavigationMenuOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location'
  };

  export type NavigationMenuOrderByRelevanceFieldEnum = (typeof NavigationMenuOrderByRelevanceFieldEnum)[keyof typeof NavigationMenuOrderByRelevanceFieldEnum]


  export const NavigationItemOrderByRelevanceFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    parentId: 'parentId',
    target: 'target',
    iconType: 'iconType',
    iconName: 'iconName',
    iconUrl: 'iconUrl',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    hoverColor: 'hoverColor',
    activeColor: 'activeColor',
    fontFamily: 'fontFamily',
    fontSize: 'fontSize',
    fontWeight: 'fontWeight'
  };

  export type NavigationItemOrderByRelevanceFieldEnum = (typeof NavigationItemOrderByRelevanceFieldEnum)[keyof typeof NavigationItemOrderByRelevanceFieldEnum]


  export const NavigationItemTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    language: 'language',
    title: 'title',
    url: 'url'
  };

  export type NavigationItemTranslationOrderByRelevanceFieldEnum = (typeof NavigationItemTranslationOrderByRelevanceFieldEnum)[keyof typeof NavigationItemTranslationOrderByRelevanceFieldEnum]


  export const BannerOrderByRelevanceFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    displayType: 'displayType',
    imageUrl: 'imageUrl',
    backgroundColor: 'backgroundColor',
    overlayColor: 'overlayColor',
    ctaText: 'ctaText',
    ctaUrl: 'ctaUrl',
    customHtml: 'customHtml',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type BannerOrderByRelevanceFieldEnum = (typeof BannerOrderByRelevanceFieldEnum)[keyof typeof BannerOrderByRelevanceFieldEnum]


  export const BannerTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    language: 'language',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    ctaText: 'ctaText',
    ctaUrl: 'ctaUrl',
    imageUrl: 'imageUrl'
  };

  export type BannerTranslationOrderByRelevanceFieldEnum = (typeof BannerTranslationOrderByRelevanceFieldEnum)[keyof typeof BannerTranslationOrderByRelevanceFieldEnum]


  export const BannerPlacementOrderByRelevanceFieldEnum: {
    id: 'id',
    bannerId: 'bannerId',
    location: 'location'
  };

  export type BannerPlacementOrderByRelevanceFieldEnum = (typeof BannerPlacementOrderByRelevanceFieldEnum)[keyof typeof BannerPlacementOrderByRelevanceFieldEnum]


  export const TopbarSettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    phone: 'phone',
    email: 'email',
    announcement: 'announcement',
    socialLinks: 'socialLinks',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor'
  };

  export type TopbarSettingsOrderByRelevanceFieldEnum = (typeof TopbarSettingsOrderByRelevanceFieldEnum)[keyof typeof TopbarSettingsOrderByRelevanceFieldEnum]


  export const MobileMenuSettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    menuType: 'menuType',
    position: 'position',
    animation: 'animation',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    iconColor: 'iconColor'
  };

  export type MobileMenuSettingsOrderByRelevanceFieldEnum = (typeof MobileMenuSettingsOrderByRelevanceFieldEnum)[keyof typeof MobileMenuSettingsOrderByRelevanceFieldEnum]


  export const LanguageSettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    defaultLanguage: 'defaultLanguage',
    supportedLanguages: 'supportedLanguages',
    languageSwitcherPosition: 'languageSwitcherPosition'
  };

  export type LanguageSettingsOrderByRelevanceFieldEnum = (typeof LanguageSettingsOrderByRelevanceFieldEnum)[keyof typeof LanguageSettingsOrderByRelevanceFieldEnum]


  export const CustomIconOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    svgContent: 'svgContent',
    category: 'category'
  };

  export type CustomIconOrderByRelevanceFieldEnum = (typeof CustomIconOrderByRelevanceFieldEnum)[keyof typeof CustomIconOrderByRelevanceFieldEnum]


  export const PackageTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    packageId: 'packageId',
    language: 'language',
    title: 'title',
    description: 'description',
    longDescription: 'longDescription',
    destinations: 'destinations',
    includes: 'includes',
    excludes: 'excludes',
    highlights: 'highlights',
    itinerary: 'itinerary',
    faqs: 'faqs',
    groupSize: 'groupSize',
    difficulty: 'difficulty',
    bestFor: 'bestFor',
    departure: 'departure',
    return: 'return',
    location: 'location'
  };

  export type PackageTranslationOrderByRelevanceFieldEnum = (typeof PackageTranslationOrderByRelevanceFieldEnum)[keyof typeof PackageTranslationOrderByRelevanceFieldEnum]


  export const BlogTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    blogId: 'blogId',
    language: 'language',
    title: 'title',
    excerpt: 'excerpt',
    content: 'content',
    category: 'category',
    tags: 'tags'
  };

  export type BlogTranslationOrderByRelevanceFieldEnum = (typeof BlogTranslationOrderByRelevanceFieldEnum)[keyof typeof BlogTranslationOrderByRelevanceFieldEnum]


  export const TestimonialTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    testimonialId: 'testimonialId',
    language: 'language',
    name: 'name',
    role: 'role',
    content: 'content',
    packageName: 'packageName',
    location: 'location'
  };

  export type TestimonialTranslationOrderByRelevanceFieldEnum = (typeof TestimonialTranslationOrderByRelevanceFieldEnum)[keyof typeof TestimonialTranslationOrderByRelevanceFieldEnum]


  export const GalleryTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    galleryId: 'galleryId',
    language: 'language',
    title: 'title',
    description: 'description',
    tags: 'tags'
  };

  export type GalleryTranslationOrderByRelevanceFieldEnum = (typeof GalleryTranslationOrderByRelevanceFieldEnum)[keyof typeof GalleryTranslationOrderByRelevanceFieldEnum]


  export const SectionContentTranslationOrderByRelevanceFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    language: 'language',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    ctaText: 'ctaText',
    buttonText: 'buttonText',
    phone: 'phone',
    email: 'email',
    destinations: 'destinations',
    features: 'features',
    stats: 'stats',
    packages: 'packages',
    testimonials: 'testimonials',
    posts: 'posts',
    items: 'items',
    categories: 'categories'
  };

  export type SectionContentTranslationOrderByRelevanceFieldEnum = (typeof SectionContentTranslationOrderByRelevanceFieldEnum)[keyof typeof SectionContentTranslationOrderByRelevanceFieldEnum]


  export const ApiKeySettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    keys: 'keys'
  };

  export type ApiKeySettingsOrderByRelevanceFieldEnum = (typeof ApiKeySettingsOrderByRelevanceFieldEnum)[keyof typeof ApiKeySettingsOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    displayName: 'displayName',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    avatar: 'avatar',
    bio: 'bio',
    website: 'website',
    lastLoginIp: 'lastLoginIp'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SectionContentWhereInput = {
    AND?: SectionContentWhereInput | SectionContentWhereInput[]
    OR?: SectionContentWhereInput[]
    NOT?: SectionContentWhereInput | SectionContentWhereInput[]
    id?: StringFilter<"SectionContent"> | string
    sectionId?: StringFilter<"SectionContent"> | string
    title?: StringNullableFilter<"SectionContent"> | string | null
    subtitle?: StringNullableFilter<"SectionContent"> | string | null
    description?: StringNullableFilter<"SectionContent"> | string | null
    ctaText?: StringNullableFilter<"SectionContent"> | string | null
    ctaLink?: StringNullableFilter<"SectionContent"> | string | null
    buttonText?: StringNullableFilter<"SectionContent"> | string | null
    image?: StringNullableFilter<"SectionContent"> | string | null
    logo?: StringNullableFilter<"SectionContent"> | string | null
    phone?: StringNullableFilter<"SectionContent"> | string | null
    email?: StringNullableFilter<"SectionContent"> | string | null
    backgroundVideo?: StringNullableFilter<"SectionContent"> | string | null
    destinations?: StringNullableFilter<"SectionContent"> | string | null
    features?: StringNullableFilter<"SectionContent"> | string | null
    stats?: StringNullableFilter<"SectionContent"> | string | null
    packages?: StringNullableFilter<"SectionContent"> | string | null
    testimonials?: StringNullableFilter<"SectionContent"> | string | null
    posts?: StringNullableFilter<"SectionContent"> | string | null
    items?: StringNullableFilter<"SectionContent"> | string | null
    categories?: StringNullableFilter<"SectionContent"> | string | null
    displayCount?: IntNullableFilter<"SectionContent"> | number | null
    featuredOnly?: BoolNullableFilter<"SectionContent"> | boolean | null
    category?: StringNullableFilter<"SectionContent"> | string | null
    sortBy?: StringNullableFilter<"SectionContent"> | string | null
    layoutStyle?: StringNullableFilter<"SectionContent"> | string | null
    showFilters?: BoolNullableFilter<"SectionContent"> | boolean | null
    enableLightbox?: BoolNullableFilter<"SectionContent"> | boolean | null
    enableAutoSlide?: BoolNullableFilter<"SectionContent"> | boolean | null
    autoSlideInterval?: IntNullableFilter<"SectionContent"> | number | null
    transitionEffect?: StringNullableFilter<"SectionContent"> | string | null
    animationSpeed?: StringNullableFilter<"SectionContent"> | string | null
    updatedAt?: DateTimeFilter<"SectionContent"> | Date | string
    createdAt?: DateTimeFilter<"SectionContent"> | Date | string
  }

  export type SectionContentOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaLink?: SortOrderInput | SortOrder
    buttonText?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    backgroundVideo?: SortOrderInput | SortOrder
    destinations?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    packages?: SortOrderInput | SortOrder
    testimonials?: SortOrderInput | SortOrder
    posts?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    displayCount?: SortOrderInput | SortOrder
    featuredOnly?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    sortBy?: SortOrderInput | SortOrder
    layoutStyle?: SortOrderInput | SortOrder
    showFilters?: SortOrderInput | SortOrder
    enableLightbox?: SortOrderInput | SortOrder
    enableAutoSlide?: SortOrderInput | SortOrder
    autoSlideInterval?: SortOrderInput | SortOrder
    transitionEffect?: SortOrderInput | SortOrder
    animationSpeed?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: SectionContentOrderByRelevanceInput
  }

  export type SectionContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sectionId?: string
    AND?: SectionContentWhereInput | SectionContentWhereInput[]
    OR?: SectionContentWhereInput[]
    NOT?: SectionContentWhereInput | SectionContentWhereInput[]
    title?: StringNullableFilter<"SectionContent"> | string | null
    subtitle?: StringNullableFilter<"SectionContent"> | string | null
    description?: StringNullableFilter<"SectionContent"> | string | null
    ctaText?: StringNullableFilter<"SectionContent"> | string | null
    ctaLink?: StringNullableFilter<"SectionContent"> | string | null
    buttonText?: StringNullableFilter<"SectionContent"> | string | null
    image?: StringNullableFilter<"SectionContent"> | string | null
    logo?: StringNullableFilter<"SectionContent"> | string | null
    phone?: StringNullableFilter<"SectionContent"> | string | null
    email?: StringNullableFilter<"SectionContent"> | string | null
    backgroundVideo?: StringNullableFilter<"SectionContent"> | string | null
    destinations?: StringNullableFilter<"SectionContent"> | string | null
    features?: StringNullableFilter<"SectionContent"> | string | null
    stats?: StringNullableFilter<"SectionContent"> | string | null
    packages?: StringNullableFilter<"SectionContent"> | string | null
    testimonials?: StringNullableFilter<"SectionContent"> | string | null
    posts?: StringNullableFilter<"SectionContent"> | string | null
    items?: StringNullableFilter<"SectionContent"> | string | null
    categories?: StringNullableFilter<"SectionContent"> | string | null
    displayCount?: IntNullableFilter<"SectionContent"> | number | null
    featuredOnly?: BoolNullableFilter<"SectionContent"> | boolean | null
    category?: StringNullableFilter<"SectionContent"> | string | null
    sortBy?: StringNullableFilter<"SectionContent"> | string | null
    layoutStyle?: StringNullableFilter<"SectionContent"> | string | null
    showFilters?: BoolNullableFilter<"SectionContent"> | boolean | null
    enableLightbox?: BoolNullableFilter<"SectionContent"> | boolean | null
    enableAutoSlide?: BoolNullableFilter<"SectionContent"> | boolean | null
    autoSlideInterval?: IntNullableFilter<"SectionContent"> | number | null
    transitionEffect?: StringNullableFilter<"SectionContent"> | string | null
    animationSpeed?: StringNullableFilter<"SectionContent"> | string | null
    updatedAt?: DateTimeFilter<"SectionContent"> | Date | string
    createdAt?: DateTimeFilter<"SectionContent"> | Date | string
  }, "id" | "sectionId">

  export type SectionContentOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaLink?: SortOrderInput | SortOrder
    buttonText?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    backgroundVideo?: SortOrderInput | SortOrder
    destinations?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    packages?: SortOrderInput | SortOrder
    testimonials?: SortOrderInput | SortOrder
    posts?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    displayCount?: SortOrderInput | SortOrder
    featuredOnly?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    sortBy?: SortOrderInput | SortOrder
    layoutStyle?: SortOrderInput | SortOrder
    showFilters?: SortOrderInput | SortOrder
    enableLightbox?: SortOrderInput | SortOrder
    enableAutoSlide?: SortOrderInput | SortOrder
    autoSlideInterval?: SortOrderInput | SortOrder
    transitionEffect?: SortOrderInput | SortOrder
    animationSpeed?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: SectionContentCountOrderByAggregateInput
    _avg?: SectionContentAvgOrderByAggregateInput
    _max?: SectionContentMaxOrderByAggregateInput
    _min?: SectionContentMinOrderByAggregateInput
    _sum?: SectionContentSumOrderByAggregateInput
  }

  export type SectionContentScalarWhereWithAggregatesInput = {
    AND?: SectionContentScalarWhereWithAggregatesInput | SectionContentScalarWhereWithAggregatesInput[]
    OR?: SectionContentScalarWhereWithAggregatesInput[]
    NOT?: SectionContentScalarWhereWithAggregatesInput | SectionContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SectionContent"> | string
    sectionId?: StringWithAggregatesFilter<"SectionContent"> | string
    title?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    subtitle?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    description?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    ctaText?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    ctaLink?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    buttonText?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    image?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    logo?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    email?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    backgroundVideo?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    destinations?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    features?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    stats?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    packages?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    testimonials?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    posts?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    items?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    categories?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    displayCount?: IntNullableWithAggregatesFilter<"SectionContent"> | number | null
    featuredOnly?: BoolNullableWithAggregatesFilter<"SectionContent"> | boolean | null
    category?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    sortBy?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    layoutStyle?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    showFilters?: BoolNullableWithAggregatesFilter<"SectionContent"> | boolean | null
    enableLightbox?: BoolNullableWithAggregatesFilter<"SectionContent"> | boolean | null
    enableAutoSlide?: BoolNullableWithAggregatesFilter<"SectionContent"> | boolean | null
    autoSlideInterval?: IntNullableWithAggregatesFilter<"SectionContent"> | number | null
    transitionEffect?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    animationSpeed?: StringNullableWithAggregatesFilter<"SectionContent"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SectionContent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SectionContent"> | Date | string
  }

  export type DestinationWhereInput = {
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    id?: StringFilter<"Destination"> | string
    name?: StringFilter<"Destination"> | string
    location?: StringFilter<"Destination"> | string
    category?: StringFilter<"Destination"> | string
    rating?: FloatFilter<"Destination"> | number
    visitors?: StringFilter<"Destination"> | string
    duration?: StringFilter<"Destination"> | string
    price?: StringFilter<"Destination"> | string
    description?: StringFilter<"Destination"> | string
    highlights?: StringFilter<"Destination"> | string
    image?: StringFilter<"Destination"> | string
    featured?: BoolFilter<"Destination"> | boolean
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    createdAt?: DateTimeFilter<"Destination"> | Date | string
  }

  export type DestinationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    visitors?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    highlights?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: DestinationOrderByRelevanceInput
  }

  export type DestinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DestinationWhereInput | DestinationWhereInput[]
    OR?: DestinationWhereInput[]
    NOT?: DestinationWhereInput | DestinationWhereInput[]
    name?: StringFilter<"Destination"> | string
    location?: StringFilter<"Destination"> | string
    category?: StringFilter<"Destination"> | string
    rating?: FloatFilter<"Destination"> | number
    visitors?: StringFilter<"Destination"> | string
    duration?: StringFilter<"Destination"> | string
    price?: StringFilter<"Destination"> | string
    description?: StringFilter<"Destination"> | string
    highlights?: StringFilter<"Destination"> | string
    image?: StringFilter<"Destination"> | string
    featured?: BoolFilter<"Destination"> | boolean
    updatedAt?: DateTimeFilter<"Destination"> | Date | string
    createdAt?: DateTimeFilter<"Destination"> | Date | string
  }, "id">

  export type DestinationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    visitors?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    highlights?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: DestinationCountOrderByAggregateInput
    _avg?: DestinationAvgOrderByAggregateInput
    _max?: DestinationMaxOrderByAggregateInput
    _min?: DestinationMinOrderByAggregateInput
    _sum?: DestinationSumOrderByAggregateInput
  }

  export type DestinationScalarWhereWithAggregatesInput = {
    AND?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    OR?: DestinationScalarWhereWithAggregatesInput[]
    NOT?: DestinationScalarWhereWithAggregatesInput | DestinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Destination"> | string
    name?: StringWithAggregatesFilter<"Destination"> | string
    location?: StringWithAggregatesFilter<"Destination"> | string
    category?: StringWithAggregatesFilter<"Destination"> | string
    rating?: FloatWithAggregatesFilter<"Destination"> | number
    visitors?: StringWithAggregatesFilter<"Destination"> | string
    duration?: StringWithAggregatesFilter<"Destination"> | string
    price?: StringWithAggregatesFilter<"Destination"> | string
    description?: StringWithAggregatesFilter<"Destination"> | string
    highlights?: StringWithAggregatesFilter<"Destination"> | string
    image?: StringWithAggregatesFilter<"Destination"> | string
    featured?: BoolWithAggregatesFilter<"Destination"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Destination"> | Date | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: StringFilter<"Package"> | string
    title?: StringFilter<"Package"> | string
    slug?: StringNullableFilter<"Package"> | string | null
    duration?: StringFilter<"Package"> | string
    price?: FloatFilter<"Package"> | number
    originalPrice?: FloatNullableFilter<"Package"> | number | null
    discount?: StringNullableFilter<"Package"> | string | null
    rating?: FloatFilter<"Package"> | number
    reviewCount?: IntFilter<"Package"> | number
    category?: StringFilter<"Package"> | string
    description?: StringFilter<"Package"> | string
    longDescription?: StringNullableFilter<"Package"> | string | null
    destinations?: StringFilter<"Package"> | string
    includes?: StringFilter<"Package"> | string
    excludes?: StringNullableFilter<"Package"> | string | null
    highlights?: StringFilter<"Package"> | string
    itinerary?: StringNullableFilter<"Package"> | string | null
    gallery?: StringNullableFilter<"Package"> | string | null
    faqs?: StringNullableFilter<"Package"> | string | null
    groupSize?: StringFilter<"Package"> | string
    difficulty?: StringFilter<"Package"> | string
    bestFor?: StringFilter<"Package"> | string
    image?: StringFilter<"Package"> | string
    departure?: StringNullableFilter<"Package"> | string | null
    return?: StringNullableFilter<"Package"> | string | null
    totalPeople?: IntNullableFilter<"Package"> | number | null
    location?: StringNullableFilter<"Package"> | string | null
    mapEmbedUrl?: StringNullableFilter<"Package"> | string | null
    featured?: BoolFilter<"Package"> | boolean
    available?: BoolFilter<"Package"> | boolean
    status?: StringFilter<"Package"> | string
    localizedUrls?: StringNullableFilter<"Package"> | string | null
    urlPathEn?: StringNullableFilter<"Package"> | string | null
    urlPathDe?: StringNullableFilter<"Package"> | string | null
    urlPathNl?: StringNullableFilter<"Package"> | string | null
    urlPathZh?: StringNullableFilter<"Package"> | string | null
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    createdAt?: DateTimeFilter<"Package"> | Date | string
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrderInput | SortOrder
    highlights?: SortOrder
    itinerary?: SortOrderInput | SortOrder
    gallery?: SortOrderInput | SortOrder
    faqs?: SortOrderInput | SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    departure?: SortOrderInput | SortOrder
    return?: SortOrderInput | SortOrder
    totalPeople?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    mapEmbedUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    available?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrderInput | SortOrder
    urlPathEn?: SortOrderInput | SortOrder
    urlPathDe?: SortOrderInput | SortOrder
    urlPathNl?: SortOrderInput | SortOrder
    urlPathZh?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: PackageOrderByRelevanceInput
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    title?: StringFilter<"Package"> | string
    duration?: StringFilter<"Package"> | string
    price?: FloatFilter<"Package"> | number
    originalPrice?: FloatNullableFilter<"Package"> | number | null
    discount?: StringNullableFilter<"Package"> | string | null
    rating?: FloatFilter<"Package"> | number
    reviewCount?: IntFilter<"Package"> | number
    category?: StringFilter<"Package"> | string
    description?: StringFilter<"Package"> | string
    longDescription?: StringNullableFilter<"Package"> | string | null
    destinations?: StringFilter<"Package"> | string
    includes?: StringFilter<"Package"> | string
    excludes?: StringNullableFilter<"Package"> | string | null
    highlights?: StringFilter<"Package"> | string
    itinerary?: StringNullableFilter<"Package"> | string | null
    gallery?: StringNullableFilter<"Package"> | string | null
    faqs?: StringNullableFilter<"Package"> | string | null
    groupSize?: StringFilter<"Package"> | string
    difficulty?: StringFilter<"Package"> | string
    bestFor?: StringFilter<"Package"> | string
    image?: StringFilter<"Package"> | string
    departure?: StringNullableFilter<"Package"> | string | null
    return?: StringNullableFilter<"Package"> | string | null
    totalPeople?: IntNullableFilter<"Package"> | number | null
    location?: StringNullableFilter<"Package"> | string | null
    mapEmbedUrl?: StringNullableFilter<"Package"> | string | null
    featured?: BoolFilter<"Package"> | boolean
    available?: BoolFilter<"Package"> | boolean
    status?: StringFilter<"Package"> | string
    localizedUrls?: StringNullableFilter<"Package"> | string | null
    urlPathEn?: StringNullableFilter<"Package"> | string | null
    urlPathDe?: StringNullableFilter<"Package"> | string | null
    urlPathNl?: StringNullableFilter<"Package"> | string | null
    urlPathZh?: StringNullableFilter<"Package"> | string | null
    updatedAt?: DateTimeFilter<"Package"> | Date | string
    createdAt?: DateTimeFilter<"Package"> | Date | string
  }, "id" | "slug">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrderInput | SortOrder
    duration?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    discount?: SortOrderInput | SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    longDescription?: SortOrderInput | SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrderInput | SortOrder
    highlights?: SortOrder
    itinerary?: SortOrderInput | SortOrder
    gallery?: SortOrderInput | SortOrder
    faqs?: SortOrderInput | SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    departure?: SortOrderInput | SortOrder
    return?: SortOrderInput | SortOrder
    totalPeople?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    mapEmbedUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    available?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrderInput | SortOrder
    urlPathEn?: SortOrderInput | SortOrder
    urlPathDe?: SortOrderInput | SortOrder
    urlPathNl?: SortOrderInput | SortOrder
    urlPathZh?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Package"> | string
    title?: StringWithAggregatesFilter<"Package"> | string
    slug?: StringNullableWithAggregatesFilter<"Package"> | string | null
    duration?: StringWithAggregatesFilter<"Package"> | string
    price?: FloatWithAggregatesFilter<"Package"> | number
    originalPrice?: FloatNullableWithAggregatesFilter<"Package"> | number | null
    discount?: StringNullableWithAggregatesFilter<"Package"> | string | null
    rating?: FloatWithAggregatesFilter<"Package"> | number
    reviewCount?: IntWithAggregatesFilter<"Package"> | number
    category?: StringWithAggregatesFilter<"Package"> | string
    description?: StringWithAggregatesFilter<"Package"> | string
    longDescription?: StringNullableWithAggregatesFilter<"Package"> | string | null
    destinations?: StringWithAggregatesFilter<"Package"> | string
    includes?: StringWithAggregatesFilter<"Package"> | string
    excludes?: StringNullableWithAggregatesFilter<"Package"> | string | null
    highlights?: StringWithAggregatesFilter<"Package"> | string
    itinerary?: StringNullableWithAggregatesFilter<"Package"> | string | null
    gallery?: StringNullableWithAggregatesFilter<"Package"> | string | null
    faqs?: StringNullableWithAggregatesFilter<"Package"> | string | null
    groupSize?: StringWithAggregatesFilter<"Package"> | string
    difficulty?: StringWithAggregatesFilter<"Package"> | string
    bestFor?: StringWithAggregatesFilter<"Package"> | string
    image?: StringWithAggregatesFilter<"Package"> | string
    departure?: StringNullableWithAggregatesFilter<"Package"> | string | null
    return?: StringNullableWithAggregatesFilter<"Package"> | string | null
    totalPeople?: IntNullableWithAggregatesFilter<"Package"> | number | null
    location?: StringNullableWithAggregatesFilter<"Package"> | string | null
    mapEmbedUrl?: StringNullableWithAggregatesFilter<"Package"> | string | null
    featured?: BoolWithAggregatesFilter<"Package"> | boolean
    available?: BoolWithAggregatesFilter<"Package"> | boolean
    status?: StringWithAggregatesFilter<"Package"> | string
    localizedUrls?: StringNullableWithAggregatesFilter<"Package"> | string | null
    urlPathEn?: StringNullableWithAggregatesFilter<"Package"> | string | null
    urlPathDe?: StringNullableWithAggregatesFilter<"Package"> | string | null
    urlPathNl?: StringNullableWithAggregatesFilter<"Package"> | string | null
    urlPathZh?: StringNullableWithAggregatesFilter<"Package"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Package"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: StringFilter<"Blog"> | string
    slug?: StringNullableFilter<"Blog"> | string | null
    title?: StringFilter<"Blog"> | string
    excerpt?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    author?: StringFilter<"Blog"> | string
    publishDate?: DateTimeFilter<"Blog"> | Date | string
    readTime?: StringFilter<"Blog"> | string
    category?: StringFilter<"Blog"> | string
    tags?: StringFilter<"Blog"> | string
    image?: StringFilter<"Blog"> | string
    featured?: BoolFilter<"Blog"> | boolean
    status?: StringFilter<"Blog"> | string
    localizedUrls?: StringNullableFilter<"Blog"> | string | null
    urlPathEn?: StringNullableFilter<"Blog"> | string | null
    urlPathDe?: StringNullableFilter<"Blog"> | string | null
    urlPathNl?: StringNullableFilter<"Blog"> | string | null
    urlPathZh?: StringNullableFilter<"Blog"> | string | null
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    createdAt?: DateTimeFilter<"Blog"> | Date | string
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrderInput | SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    readTime?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrderInput | SortOrder
    urlPathEn?: SortOrderInput | SortOrder
    urlPathDe?: SortOrderInput | SortOrder
    urlPathNl?: SortOrderInput | SortOrder
    urlPathZh?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: BlogOrderByRelevanceInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    title?: StringFilter<"Blog"> | string
    excerpt?: StringFilter<"Blog"> | string
    content?: StringFilter<"Blog"> | string
    author?: StringFilter<"Blog"> | string
    publishDate?: DateTimeFilter<"Blog"> | Date | string
    readTime?: StringFilter<"Blog"> | string
    category?: StringFilter<"Blog"> | string
    tags?: StringFilter<"Blog"> | string
    image?: StringFilter<"Blog"> | string
    featured?: BoolFilter<"Blog"> | boolean
    status?: StringFilter<"Blog"> | string
    localizedUrls?: StringNullableFilter<"Blog"> | string | null
    urlPathEn?: StringNullableFilter<"Blog"> | string | null
    urlPathDe?: StringNullableFilter<"Blog"> | string | null
    urlPathNl?: StringNullableFilter<"Blog"> | string | null
    urlPathZh?: StringNullableFilter<"Blog"> | string | null
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
    createdAt?: DateTimeFilter<"Blog"> | Date | string
  }, "id" | "slug">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrderInput | SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    readTime?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrderInput | SortOrder
    urlPathEn?: SortOrderInput | SortOrder
    urlPathDe?: SortOrderInput | SortOrder
    urlPathNl?: SortOrderInput | SortOrder
    urlPathZh?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Blog"> | string
    slug?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    title?: StringWithAggregatesFilter<"Blog"> | string
    excerpt?: StringWithAggregatesFilter<"Blog"> | string
    content?: StringWithAggregatesFilter<"Blog"> | string
    author?: StringWithAggregatesFilter<"Blog"> | string
    publishDate?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    readTime?: StringWithAggregatesFilter<"Blog"> | string
    category?: StringWithAggregatesFilter<"Blog"> | string
    tags?: StringWithAggregatesFilter<"Blog"> | string
    image?: StringWithAggregatesFilter<"Blog"> | string
    featured?: BoolWithAggregatesFilter<"Blog"> | boolean
    status?: StringWithAggregatesFilter<"Blog"> | string
    localizedUrls?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    urlPathEn?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    urlPathDe?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    urlPathNl?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    urlPathZh?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
  }

  export type TestimonialWhereInput = {
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    id?: StringFilter<"Testimonial"> | string
    name?: StringFilter<"Testimonial"> | string
    role?: StringFilter<"Testimonial"> | string
    content?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    image?: StringNullableFilter<"Testimonial"> | string | null
    packageName?: StringFilter<"Testimonial"> | string
    location?: StringFilter<"Testimonial"> | string
    status?: StringFilter<"Testimonial"> | string
    featured?: BoolFilter<"Testimonial"> | boolean
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
  }

  export type TestimonialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    image?: SortOrderInput | SortOrder
    packageName?: SortOrder
    location?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: TestimonialOrderByRelevanceInput
  }

  export type TestimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestimonialWhereInput | TestimonialWhereInput[]
    OR?: TestimonialWhereInput[]
    NOT?: TestimonialWhereInput | TestimonialWhereInput[]
    name?: StringFilter<"Testimonial"> | string
    role?: StringFilter<"Testimonial"> | string
    content?: StringFilter<"Testimonial"> | string
    rating?: IntFilter<"Testimonial"> | number
    image?: StringNullableFilter<"Testimonial"> | string | null
    packageName?: StringFilter<"Testimonial"> | string
    location?: StringFilter<"Testimonial"> | string
    status?: StringFilter<"Testimonial"> | string
    featured?: BoolFilter<"Testimonial"> | boolean
    updatedAt?: DateTimeFilter<"Testimonial"> | Date | string
    createdAt?: DateTimeFilter<"Testimonial"> | Date | string
  }, "id">

  export type TestimonialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    image?: SortOrderInput | SortOrder
    packageName?: SortOrder
    location?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: TestimonialCountOrderByAggregateInput
    _avg?: TestimonialAvgOrderByAggregateInput
    _max?: TestimonialMaxOrderByAggregateInput
    _min?: TestimonialMinOrderByAggregateInput
    _sum?: TestimonialSumOrderByAggregateInput
  }

  export type TestimonialScalarWhereWithAggregatesInput = {
    AND?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    OR?: TestimonialScalarWhereWithAggregatesInput[]
    NOT?: TestimonialScalarWhereWithAggregatesInput | TestimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Testimonial"> | string
    name?: StringWithAggregatesFilter<"Testimonial"> | string
    role?: StringWithAggregatesFilter<"Testimonial"> | string
    content?: StringWithAggregatesFilter<"Testimonial"> | string
    rating?: IntWithAggregatesFilter<"Testimonial"> | number
    image?: StringNullableWithAggregatesFilter<"Testimonial"> | string | null
    packageName?: StringWithAggregatesFilter<"Testimonial"> | string
    location?: StringWithAggregatesFilter<"Testimonial"> | string
    status?: StringWithAggregatesFilter<"Testimonial"> | string
    featured?: BoolWithAggregatesFilter<"Testimonial"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Testimonial"> | Date | string
  }

  export type GalleryItemWhereInput = {
    AND?: GalleryItemWhereInput | GalleryItemWhereInput[]
    OR?: GalleryItemWhereInput[]
    NOT?: GalleryItemWhereInput | GalleryItemWhereInput[]
    id?: StringFilter<"GalleryItem"> | string
    title?: StringFilter<"GalleryItem"> | string
    category?: StringFilter<"GalleryItem"> | string
    image?: StringFilter<"GalleryItem"> | string
    description?: StringNullableFilter<"GalleryItem"> | string | null
    tags?: StringFilter<"GalleryItem"> | string
    likes?: IntFilter<"GalleryItem"> | number
    views?: IntFilter<"GalleryItem"> | number
    updatedAt?: DateTimeFilter<"GalleryItem"> | Date | string
    createdAt?: DateTimeFilter<"GalleryItem"> | Date | string
  }

  export type GalleryItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: GalleryItemOrderByRelevanceInput
  }

  export type GalleryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GalleryItemWhereInput | GalleryItemWhereInput[]
    OR?: GalleryItemWhereInput[]
    NOT?: GalleryItemWhereInput | GalleryItemWhereInput[]
    title?: StringFilter<"GalleryItem"> | string
    category?: StringFilter<"GalleryItem"> | string
    image?: StringFilter<"GalleryItem"> | string
    description?: StringNullableFilter<"GalleryItem"> | string | null
    tags?: StringFilter<"GalleryItem"> | string
    likes?: IntFilter<"GalleryItem"> | number
    views?: IntFilter<"GalleryItem"> | number
    updatedAt?: DateTimeFilter<"GalleryItem"> | Date | string
    createdAt?: DateTimeFilter<"GalleryItem"> | Date | string
  }, "id">

  export type GalleryItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: GalleryItemCountOrderByAggregateInput
    _avg?: GalleryItemAvgOrderByAggregateInput
    _max?: GalleryItemMaxOrderByAggregateInput
    _min?: GalleryItemMinOrderByAggregateInput
    _sum?: GalleryItemSumOrderByAggregateInput
  }

  export type GalleryItemScalarWhereWithAggregatesInput = {
    AND?: GalleryItemScalarWhereWithAggregatesInput | GalleryItemScalarWhereWithAggregatesInput[]
    OR?: GalleryItemScalarWhereWithAggregatesInput[]
    NOT?: GalleryItemScalarWhereWithAggregatesInput | GalleryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GalleryItem"> | string
    title?: StringWithAggregatesFilter<"GalleryItem"> | string
    category?: StringWithAggregatesFilter<"GalleryItem"> | string
    image?: StringWithAggregatesFilter<"GalleryItem"> | string
    description?: StringNullableWithAggregatesFilter<"GalleryItem"> | string | null
    tags?: StringWithAggregatesFilter<"GalleryItem"> | string
    likes?: IntWithAggregatesFilter<"GalleryItem"> | number
    views?: IntWithAggregatesFilter<"GalleryItem"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"GalleryItem"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"GalleryItem"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    whatsappNumber?: StringFilter<"Settings"> | string
    whatsappGreeting?: StringNullableFilter<"Settings"> | string | null
    providerName?: StringFilter<"Settings"> | string
    memberSince?: StringFilter<"Settings"> | string
    providerPhone?: StringFilter<"Settings"> | string
    providerEmail?: StringFilter<"Settings"> | string
    brandName?: StringNullableFilter<"Settings"> | string | null
    siteLogo?: StringNullableFilter<"Settings"> | string | null
    siteTagline?: StringNullableFilter<"Settings"> | string | null
    favicon?: StringNullableFilter<"Settings"> | string | null
    siteName?: StringFilter<"Settings"> | string
    siteDescription?: StringNullableFilter<"Settings"> | string | null
    defaultOgImage?: StringFilter<"Settings"> | string
    siteUrl?: StringFilter<"Settings"> | string
    googleSiteVerification?: StringFilter<"Settings"> | string
    bingSiteVerification?: StringFilter<"Settings"> | string
    activeTemplate?: StringFilter<"Settings"> | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    whatsappNumber?: SortOrder
    whatsappGreeting?: SortOrderInput | SortOrder
    providerName?: SortOrder
    memberSince?: SortOrder
    providerPhone?: SortOrder
    providerEmail?: SortOrder
    brandName?: SortOrderInput | SortOrder
    siteLogo?: SortOrderInput | SortOrder
    siteTagline?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    defaultOgImage?: SortOrder
    siteUrl?: SortOrder
    googleSiteVerification?: SortOrder
    bingSiteVerification?: SortOrder
    activeTemplate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: SettingsOrderByRelevanceInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    whatsappNumber?: StringFilter<"Settings"> | string
    whatsappGreeting?: StringNullableFilter<"Settings"> | string | null
    providerName?: StringFilter<"Settings"> | string
    memberSince?: StringFilter<"Settings"> | string
    providerPhone?: StringFilter<"Settings"> | string
    providerEmail?: StringFilter<"Settings"> | string
    brandName?: StringNullableFilter<"Settings"> | string | null
    siteLogo?: StringNullableFilter<"Settings"> | string | null
    siteTagline?: StringNullableFilter<"Settings"> | string | null
    favicon?: StringNullableFilter<"Settings"> | string | null
    siteName?: StringFilter<"Settings"> | string
    siteDescription?: StringNullableFilter<"Settings"> | string | null
    defaultOgImage?: StringFilter<"Settings"> | string
    siteUrl?: StringFilter<"Settings"> | string
    googleSiteVerification?: StringFilter<"Settings"> | string
    bingSiteVerification?: StringFilter<"Settings"> | string
    activeTemplate?: StringFilter<"Settings"> | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    whatsappNumber?: SortOrder
    whatsappGreeting?: SortOrderInput | SortOrder
    providerName?: SortOrder
    memberSince?: SortOrder
    providerPhone?: SortOrder
    providerEmail?: SortOrder
    brandName?: SortOrderInput | SortOrder
    siteLogo?: SortOrderInput | SortOrder
    siteTagline?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrderInput | SortOrder
    defaultOgImage?: SortOrder
    siteUrl?: SortOrder
    googleSiteVerification?: SortOrder
    bingSiteVerification?: SortOrder
    activeTemplate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    whatsappNumber?: StringWithAggregatesFilter<"Settings"> | string
    whatsappGreeting?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    providerName?: StringWithAggregatesFilter<"Settings"> | string
    memberSince?: StringWithAggregatesFilter<"Settings"> | string
    providerPhone?: StringWithAggregatesFilter<"Settings"> | string
    providerEmail?: StringWithAggregatesFilter<"Settings"> | string
    brandName?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    siteLogo?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    siteTagline?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    siteName?: StringWithAggregatesFilter<"Settings"> | string
    siteDescription?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    defaultOgImage?: StringWithAggregatesFilter<"Settings"> | string
    siteUrl?: StringWithAggregatesFilter<"Settings"> | string
    googleSiteVerification?: StringWithAggregatesFilter<"Settings"> | string
    bingSiteVerification?: StringWithAggregatesFilter<"Settings"> | string
    activeTemplate?: StringWithAggregatesFilter<"Settings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type LocalizedUrlSettingsWhereInput = {
    AND?: LocalizedUrlSettingsWhereInput | LocalizedUrlSettingsWhereInput[]
    OR?: LocalizedUrlSettingsWhereInput[]
    NOT?: LocalizedUrlSettingsWhereInput | LocalizedUrlSettingsWhereInput[]
    id?: StringFilter<"LocalizedUrlSettings"> | string
    contentType?: StringFilter<"LocalizedUrlSettings"> | string
    urlPathId?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathEn?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathDe?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathNl?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathZh?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    autoGenerate?: BoolFilter<"LocalizedUrlSettings"> | boolean
    customPattern?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    updatedAt?: DateTimeFilter<"LocalizedUrlSettings"> | Date | string
    createdAt?: DateTimeFilter<"LocalizedUrlSettings"> | Date | string
  }

  export type LocalizedUrlSettingsOrderByWithRelationInput = {
    id?: SortOrder
    contentType?: SortOrder
    urlPathId?: SortOrderInput | SortOrder
    urlPathEn?: SortOrderInput | SortOrder
    urlPathDe?: SortOrderInput | SortOrder
    urlPathNl?: SortOrderInput | SortOrder
    urlPathZh?: SortOrderInput | SortOrder
    autoGenerate?: SortOrder
    customPattern?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: LocalizedUrlSettingsOrderByRelevanceInput
  }

  export type LocalizedUrlSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentType?: string
    AND?: LocalizedUrlSettingsWhereInput | LocalizedUrlSettingsWhereInput[]
    OR?: LocalizedUrlSettingsWhereInput[]
    NOT?: LocalizedUrlSettingsWhereInput | LocalizedUrlSettingsWhereInput[]
    urlPathId?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathEn?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathDe?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathNl?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    urlPathZh?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    autoGenerate?: BoolFilter<"LocalizedUrlSettings"> | boolean
    customPattern?: StringNullableFilter<"LocalizedUrlSettings"> | string | null
    updatedAt?: DateTimeFilter<"LocalizedUrlSettings"> | Date | string
    createdAt?: DateTimeFilter<"LocalizedUrlSettings"> | Date | string
  }, "id" | "contentType">

  export type LocalizedUrlSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    contentType?: SortOrder
    urlPathId?: SortOrderInput | SortOrder
    urlPathEn?: SortOrderInput | SortOrder
    urlPathDe?: SortOrderInput | SortOrder
    urlPathNl?: SortOrderInput | SortOrder
    urlPathZh?: SortOrderInput | SortOrder
    autoGenerate?: SortOrder
    customPattern?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: LocalizedUrlSettingsCountOrderByAggregateInput
    _max?: LocalizedUrlSettingsMaxOrderByAggregateInput
    _min?: LocalizedUrlSettingsMinOrderByAggregateInput
  }

  export type LocalizedUrlSettingsScalarWhereWithAggregatesInput = {
    AND?: LocalizedUrlSettingsScalarWhereWithAggregatesInput | LocalizedUrlSettingsScalarWhereWithAggregatesInput[]
    OR?: LocalizedUrlSettingsScalarWhereWithAggregatesInput[]
    NOT?: LocalizedUrlSettingsScalarWhereWithAggregatesInput | LocalizedUrlSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocalizedUrlSettings"> | string
    contentType?: StringWithAggregatesFilter<"LocalizedUrlSettings"> | string
    urlPathId?: StringNullableWithAggregatesFilter<"LocalizedUrlSettings"> | string | null
    urlPathEn?: StringNullableWithAggregatesFilter<"LocalizedUrlSettings"> | string | null
    urlPathDe?: StringNullableWithAggregatesFilter<"LocalizedUrlSettings"> | string | null
    urlPathNl?: StringNullableWithAggregatesFilter<"LocalizedUrlSettings"> | string | null
    urlPathZh?: StringNullableWithAggregatesFilter<"LocalizedUrlSettings"> | string | null
    autoGenerate?: BoolWithAggregatesFilter<"LocalizedUrlSettings"> | boolean
    customPattern?: StringNullableWithAggregatesFilter<"LocalizedUrlSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"LocalizedUrlSettings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"LocalizedUrlSettings"> | Date | string
  }

  export type SeoDataWhereInput = {
    AND?: SeoDataWhereInput | SeoDataWhereInput[]
    OR?: SeoDataWhereInput[]
    NOT?: SeoDataWhereInput | SeoDataWhereInput[]
    id?: StringFilter<"SeoData"> | string
    pageType?: StringFilter<"SeoData"> | string
    pageSlug?: StringFilter<"SeoData"> | string
    title?: StringFilter<"SeoData"> | string
    description?: StringFilter<"SeoData"> | string
    keywords?: StringNullableFilter<"SeoData"> | string | null
    canonicalUrl?: StringFilter<"SeoData"> | string
    ogImage?: StringNullableFilter<"SeoData"> | string | null
    ogType?: StringFilter<"SeoData"> | string
    noIndex?: BoolFilter<"SeoData"> | boolean
    updatedAt?: DateTimeFilter<"SeoData"> | Date | string
    createdAt?: DateTimeFilter<"SeoData"> | Date | string
  }

  export type SeoDataOrderByWithRelationInput = {
    id?: SortOrder
    pageType?: SortOrder
    pageSlug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    ogType?: SortOrder
    noIndex?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: SeoDataOrderByRelevanceInput
  }

  export type SeoDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageType_pageSlug?: SeoDataPageTypePageSlugCompoundUniqueInput
    AND?: SeoDataWhereInput | SeoDataWhereInput[]
    OR?: SeoDataWhereInput[]
    NOT?: SeoDataWhereInput | SeoDataWhereInput[]
    pageType?: StringFilter<"SeoData"> | string
    pageSlug?: StringFilter<"SeoData"> | string
    title?: StringFilter<"SeoData"> | string
    description?: StringFilter<"SeoData"> | string
    keywords?: StringNullableFilter<"SeoData"> | string | null
    canonicalUrl?: StringFilter<"SeoData"> | string
    ogImage?: StringNullableFilter<"SeoData"> | string | null
    ogType?: StringFilter<"SeoData"> | string
    noIndex?: BoolFilter<"SeoData"> | boolean
    updatedAt?: DateTimeFilter<"SeoData"> | Date | string
    createdAt?: DateTimeFilter<"SeoData"> | Date | string
  }, "id" | "pageType_pageSlug">

  export type SeoDataOrderByWithAggregationInput = {
    id?: SortOrder
    pageType?: SortOrder
    pageSlug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrder
    ogImage?: SortOrderInput | SortOrder
    ogType?: SortOrder
    noIndex?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: SeoDataCountOrderByAggregateInput
    _max?: SeoDataMaxOrderByAggregateInput
    _min?: SeoDataMinOrderByAggregateInput
  }

  export type SeoDataScalarWhereWithAggregatesInput = {
    AND?: SeoDataScalarWhereWithAggregatesInput | SeoDataScalarWhereWithAggregatesInput[]
    OR?: SeoDataScalarWhereWithAggregatesInput[]
    NOT?: SeoDataScalarWhereWithAggregatesInput | SeoDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SeoData"> | string
    pageType?: StringWithAggregatesFilter<"SeoData"> | string
    pageSlug?: StringWithAggregatesFilter<"SeoData"> | string
    title?: StringWithAggregatesFilter<"SeoData"> | string
    description?: StringWithAggregatesFilter<"SeoData"> | string
    keywords?: StringNullableWithAggregatesFilter<"SeoData"> | string | null
    canonicalUrl?: StringWithAggregatesFilter<"SeoData"> | string
    ogImage?: StringNullableWithAggregatesFilter<"SeoData"> | string | null
    ogType?: StringWithAggregatesFilter<"SeoData"> | string
    noIndex?: BoolWithAggregatesFilter<"SeoData"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"SeoData"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SeoData"> | Date | string
  }

  export type SitemapLogWhereInput = {
    AND?: SitemapLogWhereInput | SitemapLogWhereInput[]
    OR?: SitemapLogWhereInput[]
    NOT?: SitemapLogWhereInput | SitemapLogWhereInput[]
    id?: StringFilter<"SitemapLog"> | string
    totalPages?: IntFilter<"SitemapLog"> | number
    lastGenerated?: DateTimeFilter<"SitemapLog"> | Date | string
    googlePinged?: BoolFilter<"SitemapLog"> | boolean
    bingPinged?: BoolFilter<"SitemapLog"> | boolean
    createdAt?: DateTimeFilter<"SitemapLog"> | Date | string
  }

  export type SitemapLogOrderByWithRelationInput = {
    id?: SortOrder
    totalPages?: SortOrder
    lastGenerated?: SortOrder
    googlePinged?: SortOrder
    bingPinged?: SortOrder
    createdAt?: SortOrder
    _relevance?: SitemapLogOrderByRelevanceInput
  }

  export type SitemapLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SitemapLogWhereInput | SitemapLogWhereInput[]
    OR?: SitemapLogWhereInput[]
    NOT?: SitemapLogWhereInput | SitemapLogWhereInput[]
    totalPages?: IntFilter<"SitemapLog"> | number
    lastGenerated?: DateTimeFilter<"SitemapLog"> | Date | string
    googlePinged?: BoolFilter<"SitemapLog"> | boolean
    bingPinged?: BoolFilter<"SitemapLog"> | boolean
    createdAt?: DateTimeFilter<"SitemapLog"> | Date | string
  }, "id">

  export type SitemapLogOrderByWithAggregationInput = {
    id?: SortOrder
    totalPages?: SortOrder
    lastGenerated?: SortOrder
    googlePinged?: SortOrder
    bingPinged?: SortOrder
    createdAt?: SortOrder
    _count?: SitemapLogCountOrderByAggregateInput
    _avg?: SitemapLogAvgOrderByAggregateInput
    _max?: SitemapLogMaxOrderByAggregateInput
    _min?: SitemapLogMinOrderByAggregateInput
    _sum?: SitemapLogSumOrderByAggregateInput
  }

  export type SitemapLogScalarWhereWithAggregatesInput = {
    AND?: SitemapLogScalarWhereWithAggregatesInput | SitemapLogScalarWhereWithAggregatesInput[]
    OR?: SitemapLogScalarWhereWithAggregatesInput[]
    NOT?: SitemapLogScalarWhereWithAggregatesInput | SitemapLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SitemapLog"> | string
    totalPages?: IntWithAggregatesFilter<"SitemapLog"> | number
    lastGenerated?: DateTimeWithAggregatesFilter<"SitemapLog"> | Date | string
    googlePinged?: BoolWithAggregatesFilter<"SitemapLog"> | boolean
    bingPinged?: BoolWithAggregatesFilter<"SitemapLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SitemapLog"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    packageId?: StringFilter<"Booking"> | string
    packageName?: StringFilter<"Booking"> | string
    customerName?: StringFilter<"Booking"> | string
    customerEmail?: StringFilter<"Booking"> | string
    customerPhone?: StringFilter<"Booking"> | string
    checkInDate?: DateTimeFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeFilter<"Booking"> | Date | string
    adults?: IntFilter<"Booking"> | number
    children?: IntFilter<"Booking"> | number
    infants?: IntFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    packageName?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: BookingOrderByRelevanceInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    packageId?: StringFilter<"Booking"> | string
    packageName?: StringFilter<"Booking"> | string
    customerName?: StringFilter<"Booking"> | string
    customerEmail?: StringFilter<"Booking"> | string
    customerPhone?: StringFilter<"Booking"> | string
    checkInDate?: DateTimeFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeFilter<"Booking"> | Date | string
    adults?: IntFilter<"Booking"> | number
    children?: IntFilter<"Booking"> | number
    infants?: IntFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    paymentStatus?: StringFilter<"Booking"> | string
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    packageName?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    specialRequests?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    packageId?: StringWithAggregatesFilter<"Booking"> | string
    packageName?: StringWithAggregatesFilter<"Booking"> | string
    customerName?: StringWithAggregatesFilter<"Booking"> | string
    customerEmail?: StringWithAggregatesFilter<"Booking"> | string
    customerPhone?: StringWithAggregatesFilter<"Booking"> | string
    checkInDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    checkOutDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    adults?: IntWithAggregatesFilter<"Booking"> | number
    children?: IntWithAggregatesFilter<"Booking"> | number
    infants?: IntWithAggregatesFilter<"Booking"> | number
    totalPrice?: FloatWithAggregatesFilter<"Booking"> | number
    status?: StringWithAggregatesFilter<"Booking"> | string
    paymentStatus?: StringWithAggregatesFilter<"Booking"> | string
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type NavigationMenuWhereInput = {
    AND?: NavigationMenuWhereInput | NavigationMenuWhereInput[]
    OR?: NavigationMenuWhereInput[]
    NOT?: NavigationMenuWhereInput | NavigationMenuWhereInput[]
    id?: StringFilter<"NavigationMenu"> | string
    name?: StringFilter<"NavigationMenu"> | string
    location?: StringFilter<"NavigationMenu"> | string
    isActive?: BoolFilter<"NavigationMenu"> | boolean
    createdAt?: DateTimeFilter<"NavigationMenu"> | Date | string
    updatedAt?: DateTimeFilter<"NavigationMenu"> | Date | string
    items?: NavigationItemListRelationFilter
  }

  export type NavigationMenuOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: NavigationItemOrderByRelationAggregateInput
    _relevance?: NavigationMenuOrderByRelevanceInput
  }

  export type NavigationMenuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NavigationMenuWhereInput | NavigationMenuWhereInput[]
    OR?: NavigationMenuWhereInput[]
    NOT?: NavigationMenuWhereInput | NavigationMenuWhereInput[]
    name?: StringFilter<"NavigationMenu"> | string
    location?: StringFilter<"NavigationMenu"> | string
    isActive?: BoolFilter<"NavigationMenu"> | boolean
    createdAt?: DateTimeFilter<"NavigationMenu"> | Date | string
    updatedAt?: DateTimeFilter<"NavigationMenu"> | Date | string
    items?: NavigationItemListRelationFilter
  }, "id">

  export type NavigationMenuOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NavigationMenuCountOrderByAggregateInput
    _max?: NavigationMenuMaxOrderByAggregateInput
    _min?: NavigationMenuMinOrderByAggregateInput
  }

  export type NavigationMenuScalarWhereWithAggregatesInput = {
    AND?: NavigationMenuScalarWhereWithAggregatesInput | NavigationMenuScalarWhereWithAggregatesInput[]
    OR?: NavigationMenuScalarWhereWithAggregatesInput[]
    NOT?: NavigationMenuScalarWhereWithAggregatesInput | NavigationMenuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NavigationMenu"> | string
    name?: StringWithAggregatesFilter<"NavigationMenu"> | string
    location?: StringWithAggregatesFilter<"NavigationMenu"> | string
    isActive?: BoolWithAggregatesFilter<"NavigationMenu"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NavigationMenu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NavigationMenu"> | Date | string
  }

  export type NavigationItemWhereInput = {
    AND?: NavigationItemWhereInput | NavigationItemWhereInput[]
    OR?: NavigationItemWhereInput[]
    NOT?: NavigationItemWhereInput | NavigationItemWhereInput[]
    id?: StringFilter<"NavigationItem"> | string
    menuId?: StringFilter<"NavigationItem"> | string
    parentId?: StringNullableFilter<"NavigationItem"> | string | null
    order?: IntFilter<"NavigationItem"> | number
    isActive?: BoolFilter<"NavigationItem"> | boolean
    isExternal?: BoolFilter<"NavigationItem"> | boolean
    target?: StringFilter<"NavigationItem"> | string
    iconType?: StringFilter<"NavigationItem"> | string
    iconName?: StringNullableFilter<"NavigationItem"> | string | null
    iconUrl?: StringNullableFilter<"NavigationItem"> | string | null
    backgroundColor?: StringNullableFilter<"NavigationItem"> | string | null
    textColor?: StringNullableFilter<"NavigationItem"> | string | null
    hoverColor?: StringNullableFilter<"NavigationItem"> | string | null
    activeColor?: StringNullableFilter<"NavigationItem"> | string | null
    fontFamily?: StringNullableFilter<"NavigationItem"> | string | null
    fontSize?: StringNullableFilter<"NavigationItem"> | string | null
    fontWeight?: StringNullableFilter<"NavigationItem"> | string | null
    createdAt?: DateTimeFilter<"NavigationItem"> | Date | string
    updatedAt?: DateTimeFilter<"NavigationItem"> | Date | string
    translations?: NavigationItemTranslationListRelationFilter
    menu?: XOR<NavigationMenuScalarRelationFilter, NavigationMenuWhereInput>
    parent?: XOR<NavigationItemNullableScalarRelationFilter, NavigationItemWhereInput> | null
    children?: NavigationItemListRelationFilter
  }

  export type NavigationItemOrderByWithRelationInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isExternal?: SortOrder
    target?: SortOrder
    iconType?: SortOrder
    iconName?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    backgroundColor?: SortOrderInput | SortOrder
    textColor?: SortOrderInput | SortOrder
    hoverColor?: SortOrderInput | SortOrder
    activeColor?: SortOrderInput | SortOrder
    fontFamily?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    fontWeight?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: NavigationItemTranslationOrderByRelationAggregateInput
    menu?: NavigationMenuOrderByWithRelationInput
    parent?: NavigationItemOrderByWithRelationInput
    children?: NavigationItemOrderByRelationAggregateInput
    _relevance?: NavigationItemOrderByRelevanceInput
  }

  export type NavigationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NavigationItemWhereInput | NavigationItemWhereInput[]
    OR?: NavigationItemWhereInput[]
    NOT?: NavigationItemWhereInput | NavigationItemWhereInput[]
    menuId?: StringFilter<"NavigationItem"> | string
    parentId?: StringNullableFilter<"NavigationItem"> | string | null
    order?: IntFilter<"NavigationItem"> | number
    isActive?: BoolFilter<"NavigationItem"> | boolean
    isExternal?: BoolFilter<"NavigationItem"> | boolean
    target?: StringFilter<"NavigationItem"> | string
    iconType?: StringFilter<"NavigationItem"> | string
    iconName?: StringNullableFilter<"NavigationItem"> | string | null
    iconUrl?: StringNullableFilter<"NavigationItem"> | string | null
    backgroundColor?: StringNullableFilter<"NavigationItem"> | string | null
    textColor?: StringNullableFilter<"NavigationItem"> | string | null
    hoverColor?: StringNullableFilter<"NavigationItem"> | string | null
    activeColor?: StringNullableFilter<"NavigationItem"> | string | null
    fontFamily?: StringNullableFilter<"NavigationItem"> | string | null
    fontSize?: StringNullableFilter<"NavigationItem"> | string | null
    fontWeight?: StringNullableFilter<"NavigationItem"> | string | null
    createdAt?: DateTimeFilter<"NavigationItem"> | Date | string
    updatedAt?: DateTimeFilter<"NavigationItem"> | Date | string
    translations?: NavigationItemTranslationListRelationFilter
    menu?: XOR<NavigationMenuScalarRelationFilter, NavigationMenuWhereInput>
    parent?: XOR<NavigationItemNullableScalarRelationFilter, NavigationItemWhereInput> | null
    children?: NavigationItemListRelationFilter
  }, "id">

  export type NavigationItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isExternal?: SortOrder
    target?: SortOrder
    iconType?: SortOrder
    iconName?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    backgroundColor?: SortOrderInput | SortOrder
    textColor?: SortOrderInput | SortOrder
    hoverColor?: SortOrderInput | SortOrder
    activeColor?: SortOrderInput | SortOrder
    fontFamily?: SortOrderInput | SortOrder
    fontSize?: SortOrderInput | SortOrder
    fontWeight?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NavigationItemCountOrderByAggregateInput
    _avg?: NavigationItemAvgOrderByAggregateInput
    _max?: NavigationItemMaxOrderByAggregateInput
    _min?: NavigationItemMinOrderByAggregateInput
    _sum?: NavigationItemSumOrderByAggregateInput
  }

  export type NavigationItemScalarWhereWithAggregatesInput = {
    AND?: NavigationItemScalarWhereWithAggregatesInput | NavigationItemScalarWhereWithAggregatesInput[]
    OR?: NavigationItemScalarWhereWithAggregatesInput[]
    NOT?: NavigationItemScalarWhereWithAggregatesInput | NavigationItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NavigationItem"> | string
    menuId?: StringWithAggregatesFilter<"NavigationItem"> | string
    parentId?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    order?: IntWithAggregatesFilter<"NavigationItem"> | number
    isActive?: BoolWithAggregatesFilter<"NavigationItem"> | boolean
    isExternal?: BoolWithAggregatesFilter<"NavigationItem"> | boolean
    target?: StringWithAggregatesFilter<"NavigationItem"> | string
    iconType?: StringWithAggregatesFilter<"NavigationItem"> | string
    iconName?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    iconUrl?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    backgroundColor?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    textColor?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    hoverColor?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    activeColor?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    fontFamily?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    fontSize?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    fontWeight?: StringNullableWithAggregatesFilter<"NavigationItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NavigationItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NavigationItem"> | Date | string
  }

  export type NavigationItemTranslationWhereInput = {
    AND?: NavigationItemTranslationWhereInput | NavigationItemTranslationWhereInput[]
    OR?: NavigationItemTranslationWhereInput[]
    NOT?: NavigationItemTranslationWhereInput | NavigationItemTranslationWhereInput[]
    id?: StringFilter<"NavigationItemTranslation"> | string
    itemId?: StringFilter<"NavigationItemTranslation"> | string
    language?: StringFilter<"NavigationItemTranslation"> | string
    title?: StringFilter<"NavigationItemTranslation"> | string
    url?: StringFilter<"NavigationItemTranslation"> | string
    item?: XOR<NavigationItemScalarRelationFilter, NavigationItemWhereInput>
  }

  export type NavigationItemTranslationOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    url?: SortOrder
    item?: NavigationItemOrderByWithRelationInput
    _relevance?: NavigationItemTranslationOrderByRelevanceInput
  }

  export type NavigationItemTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId_language?: NavigationItemTranslationItemIdLanguageCompoundUniqueInput
    AND?: NavigationItemTranslationWhereInput | NavigationItemTranslationWhereInput[]
    OR?: NavigationItemTranslationWhereInput[]
    NOT?: NavigationItemTranslationWhereInput | NavigationItemTranslationWhereInput[]
    itemId?: StringFilter<"NavigationItemTranslation"> | string
    language?: StringFilter<"NavigationItemTranslation"> | string
    title?: StringFilter<"NavigationItemTranslation"> | string
    url?: StringFilter<"NavigationItemTranslation"> | string
    item?: XOR<NavigationItemScalarRelationFilter, NavigationItemWhereInput>
  }, "id" | "itemId_language">

  export type NavigationItemTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    url?: SortOrder
    _count?: NavigationItemTranslationCountOrderByAggregateInput
    _max?: NavigationItemTranslationMaxOrderByAggregateInput
    _min?: NavigationItemTranslationMinOrderByAggregateInput
  }

  export type NavigationItemTranslationScalarWhereWithAggregatesInput = {
    AND?: NavigationItemTranslationScalarWhereWithAggregatesInput | NavigationItemTranslationScalarWhereWithAggregatesInput[]
    OR?: NavigationItemTranslationScalarWhereWithAggregatesInput[]
    NOT?: NavigationItemTranslationScalarWhereWithAggregatesInput | NavigationItemTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NavigationItemTranslation"> | string
    itemId?: StringWithAggregatesFilter<"NavigationItemTranslation"> | string
    language?: StringWithAggregatesFilter<"NavigationItemTranslation"> | string
    title?: StringWithAggregatesFilter<"NavigationItemTranslation"> | string
    url?: StringWithAggregatesFilter<"NavigationItemTranslation"> | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    slug?: StringFilter<"Banner"> | string
    name?: StringFilter<"Banner"> | string
    title?: StringNullableFilter<"Banner"> | string | null
    subtitle?: StringNullableFilter<"Banner"> | string | null
    description?: StringNullableFilter<"Banner"> | string | null
    displayType?: StringFilter<"Banner"> | string
    imageUrl?: StringNullableFilter<"Banner"> | string | null
    backgroundColor?: StringNullableFilter<"Banner"> | string | null
    overlayColor?: StringNullableFilter<"Banner"> | string | null
    ctaText?: StringNullableFilter<"Banner"> | string | null
    ctaUrl?: StringNullableFilter<"Banner"> | string | null
    isActive?: BoolFilter<"Banner"> | boolean
    customHtml?: StringNullableFilter<"Banner"> | string | null
    createdBy?: StringNullableFilter<"Banner"> | string | null
    updatedBy?: StringNullableFilter<"Banner"> | string | null
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
    translations?: BannerTranslationListRelationFilter
    placements?: BannerPlacementListRelationFilter
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    displayType?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    backgroundColor?: SortOrderInput | SortOrder
    overlayColor?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customHtml?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: BannerTranslationOrderByRelationAggregateInput
    placements?: BannerPlacementOrderByRelationAggregateInput
    _relevance?: BannerOrderByRelevanceInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    name?: StringFilter<"Banner"> | string
    title?: StringNullableFilter<"Banner"> | string | null
    subtitle?: StringNullableFilter<"Banner"> | string | null
    description?: StringNullableFilter<"Banner"> | string | null
    displayType?: StringFilter<"Banner"> | string
    imageUrl?: StringNullableFilter<"Banner"> | string | null
    backgroundColor?: StringNullableFilter<"Banner"> | string | null
    overlayColor?: StringNullableFilter<"Banner"> | string | null
    ctaText?: StringNullableFilter<"Banner"> | string | null
    ctaUrl?: StringNullableFilter<"Banner"> | string | null
    isActive?: BoolFilter<"Banner"> | boolean
    customHtml?: StringNullableFilter<"Banner"> | string | null
    createdBy?: StringNullableFilter<"Banner"> | string | null
    updatedBy?: StringNullableFilter<"Banner"> | string | null
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
    translations?: BannerTranslationListRelationFilter
    placements?: BannerPlacementListRelationFilter
  }, "id" | "slug">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    displayType?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    backgroundColor?: SortOrderInput | SortOrder
    overlayColor?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customHtml?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    slug?: StringWithAggregatesFilter<"Banner"> | string
    name?: StringWithAggregatesFilter<"Banner"> | string
    title?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    subtitle?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    description?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    displayType?: StringWithAggregatesFilter<"Banner"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    backgroundColor?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    overlayColor?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    ctaText?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    ctaUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    isActive?: BoolWithAggregatesFilter<"Banner"> | boolean
    customHtml?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type BannerTranslationWhereInput = {
    AND?: BannerTranslationWhereInput | BannerTranslationWhereInput[]
    OR?: BannerTranslationWhereInput[]
    NOT?: BannerTranslationWhereInput | BannerTranslationWhereInput[]
    id?: StringFilter<"BannerTranslation"> | string
    bannerId?: StringFilter<"BannerTranslation"> | string
    language?: StringFilter<"BannerTranslation"> | string
    title?: StringNullableFilter<"BannerTranslation"> | string | null
    subtitle?: StringNullableFilter<"BannerTranslation"> | string | null
    description?: StringNullableFilter<"BannerTranslation"> | string | null
    ctaText?: StringNullableFilter<"BannerTranslation"> | string | null
    ctaUrl?: StringNullableFilter<"BannerTranslation"> | string | null
    imageUrl?: StringNullableFilter<"BannerTranslation"> | string | null
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
  }

  export type BannerTranslationOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    banner?: BannerOrderByWithRelationInput
    _relevance?: BannerTranslationOrderByRelevanceInput
  }

  export type BannerTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bannerId_language?: BannerTranslationBannerIdLanguageCompoundUniqueInput
    AND?: BannerTranslationWhereInput | BannerTranslationWhereInput[]
    OR?: BannerTranslationWhereInput[]
    NOT?: BannerTranslationWhereInput | BannerTranslationWhereInput[]
    bannerId?: StringFilter<"BannerTranslation"> | string
    language?: StringFilter<"BannerTranslation"> | string
    title?: StringNullableFilter<"BannerTranslation"> | string | null
    subtitle?: StringNullableFilter<"BannerTranslation"> | string | null
    description?: StringNullableFilter<"BannerTranslation"> | string | null
    ctaText?: StringNullableFilter<"BannerTranslation"> | string | null
    ctaUrl?: StringNullableFilter<"BannerTranslation"> | string | null
    imageUrl?: StringNullableFilter<"BannerTranslation"> | string | null
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
  }, "id" | "bannerId_language">

  export type BannerTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    _count?: BannerTranslationCountOrderByAggregateInput
    _max?: BannerTranslationMaxOrderByAggregateInput
    _min?: BannerTranslationMinOrderByAggregateInput
  }

  export type BannerTranslationScalarWhereWithAggregatesInput = {
    AND?: BannerTranslationScalarWhereWithAggregatesInput | BannerTranslationScalarWhereWithAggregatesInput[]
    OR?: BannerTranslationScalarWhereWithAggregatesInput[]
    NOT?: BannerTranslationScalarWhereWithAggregatesInput | BannerTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerTranslation"> | string
    bannerId?: StringWithAggregatesFilter<"BannerTranslation"> | string
    language?: StringWithAggregatesFilter<"BannerTranslation"> | string
    title?: StringNullableWithAggregatesFilter<"BannerTranslation"> | string | null
    subtitle?: StringNullableWithAggregatesFilter<"BannerTranslation"> | string | null
    description?: StringNullableWithAggregatesFilter<"BannerTranslation"> | string | null
    ctaText?: StringNullableWithAggregatesFilter<"BannerTranslation"> | string | null
    ctaUrl?: StringNullableWithAggregatesFilter<"BannerTranslation"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"BannerTranslation"> | string | null
  }

  export type BannerPlacementWhereInput = {
    AND?: BannerPlacementWhereInput | BannerPlacementWhereInput[]
    OR?: BannerPlacementWhereInput[]
    NOT?: BannerPlacementWhereInput | BannerPlacementWhereInput[]
    id?: StringFilter<"BannerPlacement"> | string
    bannerId?: StringFilter<"BannerPlacement"> | string
    location?: StringFilter<"BannerPlacement"> | string
    position?: IntFilter<"BannerPlacement"> | number
    isActive?: BoolFilter<"BannerPlacement"> | boolean
    startDate?: DateTimeNullableFilter<"BannerPlacement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BannerPlacement"> | Date | string | null
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
  }

  export type BannerPlacementOrderByWithRelationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    location?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    banner?: BannerOrderByWithRelationInput
    _relevance?: BannerPlacementOrderByRelevanceInput
  }

  export type BannerPlacementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerPlacementWhereInput | BannerPlacementWhereInput[]
    OR?: BannerPlacementWhereInput[]
    NOT?: BannerPlacementWhereInput | BannerPlacementWhereInput[]
    bannerId?: StringFilter<"BannerPlacement"> | string
    location?: StringFilter<"BannerPlacement"> | string
    position?: IntFilter<"BannerPlacement"> | number
    isActive?: BoolFilter<"BannerPlacement"> | boolean
    startDate?: DateTimeNullableFilter<"BannerPlacement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BannerPlacement"> | Date | string | null
    banner?: XOR<BannerScalarRelationFilter, BannerWhereInput>
  }, "id">

  export type BannerPlacementOrderByWithAggregationInput = {
    id?: SortOrder
    bannerId?: SortOrder
    location?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: BannerPlacementCountOrderByAggregateInput
    _avg?: BannerPlacementAvgOrderByAggregateInput
    _max?: BannerPlacementMaxOrderByAggregateInput
    _min?: BannerPlacementMinOrderByAggregateInput
    _sum?: BannerPlacementSumOrderByAggregateInput
  }

  export type BannerPlacementScalarWhereWithAggregatesInput = {
    AND?: BannerPlacementScalarWhereWithAggregatesInput | BannerPlacementScalarWhereWithAggregatesInput[]
    OR?: BannerPlacementScalarWhereWithAggregatesInput[]
    NOT?: BannerPlacementScalarWhereWithAggregatesInput | BannerPlacementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BannerPlacement"> | string
    bannerId?: StringWithAggregatesFilter<"BannerPlacement"> | string
    location?: StringWithAggregatesFilter<"BannerPlacement"> | string
    position?: IntWithAggregatesFilter<"BannerPlacement"> | number
    isActive?: BoolWithAggregatesFilter<"BannerPlacement"> | boolean
    startDate?: DateTimeNullableWithAggregatesFilter<"BannerPlacement"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"BannerPlacement"> | Date | string | null
  }

  export type TopbarSettingsWhereInput = {
    AND?: TopbarSettingsWhereInput | TopbarSettingsWhereInput[]
    OR?: TopbarSettingsWhereInput[]
    NOT?: TopbarSettingsWhereInput | TopbarSettingsWhereInput[]
    id?: StringFilter<"TopbarSettings"> | string
    isEnabled?: BoolFilter<"TopbarSettings"> | boolean
    phone?: StringFilter<"TopbarSettings"> | string
    email?: StringFilter<"TopbarSettings"> | string
    announcement?: StringNullableFilter<"TopbarSettings"> | string | null
    showLanguage?: BoolFilter<"TopbarSettings"> | boolean
    showSocial?: BoolFilter<"TopbarSettings"> | boolean
    socialLinks?: StringNullableFilter<"TopbarSettings"> | string | null
    backgroundColor?: StringFilter<"TopbarSettings"> | string
    textColor?: StringFilter<"TopbarSettings"> | string
    updatedAt?: DateTimeFilter<"TopbarSettings"> | Date | string
    createdAt?: DateTimeFilter<"TopbarSettings"> | Date | string
  }

  export type TopbarSettingsOrderByWithRelationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    announcement?: SortOrderInput | SortOrder
    showLanguage?: SortOrder
    showSocial?: SortOrder
    socialLinks?: SortOrderInput | SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: TopbarSettingsOrderByRelevanceInput
  }

  export type TopbarSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TopbarSettingsWhereInput | TopbarSettingsWhereInput[]
    OR?: TopbarSettingsWhereInput[]
    NOT?: TopbarSettingsWhereInput | TopbarSettingsWhereInput[]
    isEnabled?: BoolFilter<"TopbarSettings"> | boolean
    phone?: StringFilter<"TopbarSettings"> | string
    email?: StringFilter<"TopbarSettings"> | string
    announcement?: StringNullableFilter<"TopbarSettings"> | string | null
    showLanguage?: BoolFilter<"TopbarSettings"> | boolean
    showSocial?: BoolFilter<"TopbarSettings"> | boolean
    socialLinks?: StringNullableFilter<"TopbarSettings"> | string | null
    backgroundColor?: StringFilter<"TopbarSettings"> | string
    textColor?: StringFilter<"TopbarSettings"> | string
    updatedAt?: DateTimeFilter<"TopbarSettings"> | Date | string
    createdAt?: DateTimeFilter<"TopbarSettings"> | Date | string
  }, "id">

  export type TopbarSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    announcement?: SortOrderInput | SortOrder
    showLanguage?: SortOrder
    showSocial?: SortOrder
    socialLinks?: SortOrderInput | SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: TopbarSettingsCountOrderByAggregateInput
    _max?: TopbarSettingsMaxOrderByAggregateInput
    _min?: TopbarSettingsMinOrderByAggregateInput
  }

  export type TopbarSettingsScalarWhereWithAggregatesInput = {
    AND?: TopbarSettingsScalarWhereWithAggregatesInput | TopbarSettingsScalarWhereWithAggregatesInput[]
    OR?: TopbarSettingsScalarWhereWithAggregatesInput[]
    NOT?: TopbarSettingsScalarWhereWithAggregatesInput | TopbarSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TopbarSettings"> | string
    isEnabled?: BoolWithAggregatesFilter<"TopbarSettings"> | boolean
    phone?: StringWithAggregatesFilter<"TopbarSettings"> | string
    email?: StringWithAggregatesFilter<"TopbarSettings"> | string
    announcement?: StringNullableWithAggregatesFilter<"TopbarSettings"> | string | null
    showLanguage?: BoolWithAggregatesFilter<"TopbarSettings"> | boolean
    showSocial?: BoolWithAggregatesFilter<"TopbarSettings"> | boolean
    socialLinks?: StringNullableWithAggregatesFilter<"TopbarSettings"> | string | null
    backgroundColor?: StringWithAggregatesFilter<"TopbarSettings"> | string
    textColor?: StringWithAggregatesFilter<"TopbarSettings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"TopbarSettings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TopbarSettings"> | Date | string
  }

  export type MobileMenuSettingsWhereInput = {
    AND?: MobileMenuSettingsWhereInput | MobileMenuSettingsWhereInput[]
    OR?: MobileMenuSettingsWhereInput[]
    NOT?: MobileMenuSettingsWhereInput | MobileMenuSettingsWhereInput[]
    id?: StringFilter<"MobileMenuSettings"> | string
    menuType?: StringFilter<"MobileMenuSettings"> | string
    position?: StringFilter<"MobileMenuSettings"> | string
    animation?: StringFilter<"MobileMenuSettings"> | string
    backgroundColor?: StringFilter<"MobileMenuSettings"> | string
    textColor?: StringFilter<"MobileMenuSettings"> | string
    iconColor?: StringFilter<"MobileMenuSettings"> | string
    updatedAt?: DateTimeFilter<"MobileMenuSettings"> | Date | string
    createdAt?: DateTimeFilter<"MobileMenuSettings"> | Date | string
  }

  export type MobileMenuSettingsOrderByWithRelationInput = {
    id?: SortOrder
    menuType?: SortOrder
    position?: SortOrder
    animation?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    iconColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: MobileMenuSettingsOrderByRelevanceInput
  }

  export type MobileMenuSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MobileMenuSettingsWhereInput | MobileMenuSettingsWhereInput[]
    OR?: MobileMenuSettingsWhereInput[]
    NOT?: MobileMenuSettingsWhereInput | MobileMenuSettingsWhereInput[]
    menuType?: StringFilter<"MobileMenuSettings"> | string
    position?: StringFilter<"MobileMenuSettings"> | string
    animation?: StringFilter<"MobileMenuSettings"> | string
    backgroundColor?: StringFilter<"MobileMenuSettings"> | string
    textColor?: StringFilter<"MobileMenuSettings"> | string
    iconColor?: StringFilter<"MobileMenuSettings"> | string
    updatedAt?: DateTimeFilter<"MobileMenuSettings"> | Date | string
    createdAt?: DateTimeFilter<"MobileMenuSettings"> | Date | string
  }, "id">

  export type MobileMenuSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    menuType?: SortOrder
    position?: SortOrder
    animation?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    iconColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: MobileMenuSettingsCountOrderByAggregateInput
    _max?: MobileMenuSettingsMaxOrderByAggregateInput
    _min?: MobileMenuSettingsMinOrderByAggregateInput
  }

  export type MobileMenuSettingsScalarWhereWithAggregatesInput = {
    AND?: MobileMenuSettingsScalarWhereWithAggregatesInput | MobileMenuSettingsScalarWhereWithAggregatesInput[]
    OR?: MobileMenuSettingsScalarWhereWithAggregatesInput[]
    NOT?: MobileMenuSettingsScalarWhereWithAggregatesInput | MobileMenuSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    menuType?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    position?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    animation?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    backgroundColor?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    textColor?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    iconColor?: StringWithAggregatesFilter<"MobileMenuSettings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"MobileMenuSettings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MobileMenuSettings"> | Date | string
  }

  export type LanguageSettingsWhereInput = {
    AND?: LanguageSettingsWhereInput | LanguageSettingsWhereInput[]
    OR?: LanguageSettingsWhereInput[]
    NOT?: LanguageSettingsWhereInput | LanguageSettingsWhereInput[]
    id?: StringFilter<"LanguageSettings"> | string
    defaultLanguage?: StringFilter<"LanguageSettings"> | string
    supportedLanguages?: StringNullableFilter<"LanguageSettings"> | string | null
    showLanguageSwitcher?: BoolFilter<"LanguageSettings"> | boolean
    languageSwitcherPosition?: StringFilter<"LanguageSettings"> | string
    updatedAt?: DateTimeFilter<"LanguageSettings"> | Date | string
    createdAt?: DateTimeFilter<"LanguageSettings"> | Date | string
  }

  export type LanguageSettingsOrderByWithRelationInput = {
    id?: SortOrder
    defaultLanguage?: SortOrder
    supportedLanguages?: SortOrderInput | SortOrder
    showLanguageSwitcher?: SortOrder
    languageSwitcherPosition?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: LanguageSettingsOrderByRelevanceInput
  }

  export type LanguageSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LanguageSettingsWhereInput | LanguageSettingsWhereInput[]
    OR?: LanguageSettingsWhereInput[]
    NOT?: LanguageSettingsWhereInput | LanguageSettingsWhereInput[]
    defaultLanguage?: StringFilter<"LanguageSettings"> | string
    supportedLanguages?: StringNullableFilter<"LanguageSettings"> | string | null
    showLanguageSwitcher?: BoolFilter<"LanguageSettings"> | boolean
    languageSwitcherPosition?: StringFilter<"LanguageSettings"> | string
    updatedAt?: DateTimeFilter<"LanguageSettings"> | Date | string
    createdAt?: DateTimeFilter<"LanguageSettings"> | Date | string
  }, "id">

  export type LanguageSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    defaultLanguage?: SortOrder
    supportedLanguages?: SortOrderInput | SortOrder
    showLanguageSwitcher?: SortOrder
    languageSwitcherPosition?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: LanguageSettingsCountOrderByAggregateInput
    _max?: LanguageSettingsMaxOrderByAggregateInput
    _min?: LanguageSettingsMinOrderByAggregateInput
  }

  export type LanguageSettingsScalarWhereWithAggregatesInput = {
    AND?: LanguageSettingsScalarWhereWithAggregatesInput | LanguageSettingsScalarWhereWithAggregatesInput[]
    OR?: LanguageSettingsScalarWhereWithAggregatesInput[]
    NOT?: LanguageSettingsScalarWhereWithAggregatesInput | LanguageSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LanguageSettings"> | string
    defaultLanguage?: StringWithAggregatesFilter<"LanguageSettings"> | string
    supportedLanguages?: StringNullableWithAggregatesFilter<"LanguageSettings"> | string | null
    showLanguageSwitcher?: BoolWithAggregatesFilter<"LanguageSettings"> | boolean
    languageSwitcherPosition?: StringWithAggregatesFilter<"LanguageSettings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"LanguageSettings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"LanguageSettings"> | Date | string
  }

  export type CustomIconWhereInput = {
    AND?: CustomIconWhereInput | CustomIconWhereInput[]
    OR?: CustomIconWhereInput[]
    NOT?: CustomIconWhereInput | CustomIconWhereInput[]
    id?: StringFilter<"CustomIcon"> | string
    name?: StringFilter<"CustomIcon"> | string
    svgContent?: StringFilter<"CustomIcon"> | string
    category?: StringFilter<"CustomIcon"> | string
    isActive?: BoolFilter<"CustomIcon"> | boolean
    createdAt?: DateTimeFilter<"CustomIcon"> | Date | string
    updatedAt?: DateTimeFilter<"CustomIcon"> | Date | string
  }

  export type CustomIconOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    svgContent?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CustomIconOrderByRelevanceInput
  }

  export type CustomIconWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CustomIconWhereInput | CustomIconWhereInput[]
    OR?: CustomIconWhereInput[]
    NOT?: CustomIconWhereInput | CustomIconWhereInput[]
    svgContent?: StringFilter<"CustomIcon"> | string
    category?: StringFilter<"CustomIcon"> | string
    isActive?: BoolFilter<"CustomIcon"> | boolean
    createdAt?: DateTimeFilter<"CustomIcon"> | Date | string
    updatedAt?: DateTimeFilter<"CustomIcon"> | Date | string
  }, "id" | "name">

  export type CustomIconOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    svgContent?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomIconCountOrderByAggregateInput
    _max?: CustomIconMaxOrderByAggregateInput
    _min?: CustomIconMinOrderByAggregateInput
  }

  export type CustomIconScalarWhereWithAggregatesInput = {
    AND?: CustomIconScalarWhereWithAggregatesInput | CustomIconScalarWhereWithAggregatesInput[]
    OR?: CustomIconScalarWhereWithAggregatesInput[]
    NOT?: CustomIconScalarWhereWithAggregatesInput | CustomIconScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomIcon"> | string
    name?: StringWithAggregatesFilter<"CustomIcon"> | string
    svgContent?: StringWithAggregatesFilter<"CustomIcon"> | string
    category?: StringWithAggregatesFilter<"CustomIcon"> | string
    isActive?: BoolWithAggregatesFilter<"CustomIcon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomIcon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomIcon"> | Date | string
  }

  export type PackageTranslationWhereInput = {
    AND?: PackageTranslationWhereInput | PackageTranslationWhereInput[]
    OR?: PackageTranslationWhereInput[]
    NOT?: PackageTranslationWhereInput | PackageTranslationWhereInput[]
    id?: StringFilter<"PackageTranslation"> | string
    packageId?: StringFilter<"PackageTranslation"> | string
    language?: StringFilter<"PackageTranslation"> | string
    title?: StringNullableFilter<"PackageTranslation"> | string | null
    description?: StringNullableFilter<"PackageTranslation"> | string | null
    longDescription?: StringNullableFilter<"PackageTranslation"> | string | null
    destinations?: StringNullableFilter<"PackageTranslation"> | string | null
    includes?: StringNullableFilter<"PackageTranslation"> | string | null
    excludes?: StringNullableFilter<"PackageTranslation"> | string | null
    highlights?: StringNullableFilter<"PackageTranslation"> | string | null
    itinerary?: StringNullableFilter<"PackageTranslation"> | string | null
    faqs?: StringNullableFilter<"PackageTranslation"> | string | null
    groupSize?: StringNullableFilter<"PackageTranslation"> | string | null
    difficulty?: StringNullableFilter<"PackageTranslation"> | string | null
    bestFor?: StringNullableFilter<"PackageTranslation"> | string | null
    departure?: StringNullableFilter<"PackageTranslation"> | string | null
    return?: StringNullableFilter<"PackageTranslation"> | string | null
    location?: StringNullableFilter<"PackageTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"PackageTranslation"> | boolean
    createdAt?: DateTimeFilter<"PackageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PackageTranslation"> | Date | string
  }

  export type PackageTranslationOrderByWithRelationInput = {
    id?: SortOrder
    packageId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    destinations?: SortOrderInput | SortOrder
    includes?: SortOrderInput | SortOrder
    excludes?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    itinerary?: SortOrderInput | SortOrder
    faqs?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    bestFor?: SortOrderInput | SortOrder
    departure?: SortOrderInput | SortOrder
    return?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: PackageTranslationOrderByRelevanceInput
  }

  export type PackageTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    packageId_language?: PackageTranslationPackageIdLanguageCompoundUniqueInput
    AND?: PackageTranslationWhereInput | PackageTranslationWhereInput[]
    OR?: PackageTranslationWhereInput[]
    NOT?: PackageTranslationWhereInput | PackageTranslationWhereInput[]
    packageId?: StringFilter<"PackageTranslation"> | string
    language?: StringFilter<"PackageTranslation"> | string
    title?: StringNullableFilter<"PackageTranslation"> | string | null
    description?: StringNullableFilter<"PackageTranslation"> | string | null
    longDescription?: StringNullableFilter<"PackageTranslation"> | string | null
    destinations?: StringNullableFilter<"PackageTranslation"> | string | null
    includes?: StringNullableFilter<"PackageTranslation"> | string | null
    excludes?: StringNullableFilter<"PackageTranslation"> | string | null
    highlights?: StringNullableFilter<"PackageTranslation"> | string | null
    itinerary?: StringNullableFilter<"PackageTranslation"> | string | null
    faqs?: StringNullableFilter<"PackageTranslation"> | string | null
    groupSize?: StringNullableFilter<"PackageTranslation"> | string | null
    difficulty?: StringNullableFilter<"PackageTranslation"> | string | null
    bestFor?: StringNullableFilter<"PackageTranslation"> | string | null
    departure?: StringNullableFilter<"PackageTranslation"> | string | null
    return?: StringNullableFilter<"PackageTranslation"> | string | null
    location?: StringNullableFilter<"PackageTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"PackageTranslation"> | boolean
    createdAt?: DateTimeFilter<"PackageTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PackageTranslation"> | Date | string
  }, "id" | "packageId_language">

  export type PackageTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    packageId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    longDescription?: SortOrderInput | SortOrder
    destinations?: SortOrderInput | SortOrder
    includes?: SortOrderInput | SortOrder
    excludes?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    itinerary?: SortOrderInput | SortOrder
    faqs?: SortOrderInput | SortOrder
    groupSize?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    bestFor?: SortOrderInput | SortOrder
    departure?: SortOrderInput | SortOrder
    return?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackageTranslationCountOrderByAggregateInput
    _max?: PackageTranslationMaxOrderByAggregateInput
    _min?: PackageTranslationMinOrderByAggregateInput
  }

  export type PackageTranslationScalarWhereWithAggregatesInput = {
    AND?: PackageTranslationScalarWhereWithAggregatesInput | PackageTranslationScalarWhereWithAggregatesInput[]
    OR?: PackageTranslationScalarWhereWithAggregatesInput[]
    NOT?: PackageTranslationScalarWhereWithAggregatesInput | PackageTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackageTranslation"> | string
    packageId?: StringWithAggregatesFilter<"PackageTranslation"> | string
    language?: StringWithAggregatesFilter<"PackageTranslation"> | string
    title?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    description?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    longDescription?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    destinations?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    includes?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    excludes?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    highlights?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    itinerary?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    faqs?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    groupSize?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    bestFor?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    departure?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    return?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    location?: StringNullableWithAggregatesFilter<"PackageTranslation"> | string | null
    isAutoTranslated?: BoolWithAggregatesFilter<"PackageTranslation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PackageTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PackageTranslation"> | Date | string
  }

  export type BlogTranslationWhereInput = {
    AND?: BlogTranslationWhereInput | BlogTranslationWhereInput[]
    OR?: BlogTranslationWhereInput[]
    NOT?: BlogTranslationWhereInput | BlogTranslationWhereInput[]
    id?: StringFilter<"BlogTranslation"> | string
    blogId?: StringFilter<"BlogTranslation"> | string
    language?: StringFilter<"BlogTranslation"> | string
    title?: StringNullableFilter<"BlogTranslation"> | string | null
    excerpt?: StringNullableFilter<"BlogTranslation"> | string | null
    content?: StringNullableFilter<"BlogTranslation"> | string | null
    category?: StringNullableFilter<"BlogTranslation"> | string | null
    tags?: StringNullableFilter<"BlogTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"BlogTranslation"> | boolean
    createdAt?: DateTimeFilter<"BlogTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTranslation"> | Date | string
  }

  export type BlogTranslationOrderByWithRelationInput = {
    id?: SortOrder
    blogId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BlogTranslationOrderByRelevanceInput
  }

  export type BlogTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blogId_language?: BlogTranslationBlogIdLanguageCompoundUniqueInput
    AND?: BlogTranslationWhereInput | BlogTranslationWhereInput[]
    OR?: BlogTranslationWhereInput[]
    NOT?: BlogTranslationWhereInput | BlogTranslationWhereInput[]
    blogId?: StringFilter<"BlogTranslation"> | string
    language?: StringFilter<"BlogTranslation"> | string
    title?: StringNullableFilter<"BlogTranslation"> | string | null
    excerpt?: StringNullableFilter<"BlogTranslation"> | string | null
    content?: StringNullableFilter<"BlogTranslation"> | string | null
    category?: StringNullableFilter<"BlogTranslation"> | string | null
    tags?: StringNullableFilter<"BlogTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"BlogTranslation"> | boolean
    createdAt?: DateTimeFilter<"BlogTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTranslation"> | Date | string
  }, "id" | "blogId_language">

  export type BlogTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    blogId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogTranslationCountOrderByAggregateInput
    _max?: BlogTranslationMaxOrderByAggregateInput
    _min?: BlogTranslationMinOrderByAggregateInput
  }

  export type BlogTranslationScalarWhereWithAggregatesInput = {
    AND?: BlogTranslationScalarWhereWithAggregatesInput | BlogTranslationScalarWhereWithAggregatesInput[]
    OR?: BlogTranslationScalarWhereWithAggregatesInput[]
    NOT?: BlogTranslationScalarWhereWithAggregatesInput | BlogTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlogTranslation"> | string
    blogId?: StringWithAggregatesFilter<"BlogTranslation"> | string
    language?: StringWithAggregatesFilter<"BlogTranslation"> | string
    title?: StringNullableWithAggregatesFilter<"BlogTranslation"> | string | null
    excerpt?: StringNullableWithAggregatesFilter<"BlogTranslation"> | string | null
    content?: StringNullableWithAggregatesFilter<"BlogTranslation"> | string | null
    category?: StringNullableWithAggregatesFilter<"BlogTranslation"> | string | null
    tags?: StringNullableWithAggregatesFilter<"BlogTranslation"> | string | null
    isAutoTranslated?: BoolWithAggregatesFilter<"BlogTranslation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BlogTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogTranslation"> | Date | string
  }

  export type TestimonialTranslationWhereInput = {
    AND?: TestimonialTranslationWhereInput | TestimonialTranslationWhereInput[]
    OR?: TestimonialTranslationWhereInput[]
    NOT?: TestimonialTranslationWhereInput | TestimonialTranslationWhereInput[]
    id?: StringFilter<"TestimonialTranslation"> | string
    testimonialId?: StringFilter<"TestimonialTranslation"> | string
    language?: StringFilter<"TestimonialTranslation"> | string
    name?: StringNullableFilter<"TestimonialTranslation"> | string | null
    role?: StringNullableFilter<"TestimonialTranslation"> | string | null
    content?: StringNullableFilter<"TestimonialTranslation"> | string | null
    packageName?: StringNullableFilter<"TestimonialTranslation"> | string | null
    location?: StringNullableFilter<"TestimonialTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"TestimonialTranslation"> | boolean
    createdAt?: DateTimeFilter<"TestimonialTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TestimonialTranslation"> | Date | string
  }

  export type TestimonialTranslationOrderByWithRelationInput = {
    id?: SortOrder
    testimonialId?: SortOrder
    language?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    packageName?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: TestimonialTranslationOrderByRelevanceInput
  }

  export type TestimonialTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    testimonialId_language?: TestimonialTranslationTestimonialIdLanguageCompoundUniqueInput
    AND?: TestimonialTranslationWhereInput | TestimonialTranslationWhereInput[]
    OR?: TestimonialTranslationWhereInput[]
    NOT?: TestimonialTranslationWhereInput | TestimonialTranslationWhereInput[]
    testimonialId?: StringFilter<"TestimonialTranslation"> | string
    language?: StringFilter<"TestimonialTranslation"> | string
    name?: StringNullableFilter<"TestimonialTranslation"> | string | null
    role?: StringNullableFilter<"TestimonialTranslation"> | string | null
    content?: StringNullableFilter<"TestimonialTranslation"> | string | null
    packageName?: StringNullableFilter<"TestimonialTranslation"> | string | null
    location?: StringNullableFilter<"TestimonialTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"TestimonialTranslation"> | boolean
    createdAt?: DateTimeFilter<"TestimonialTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"TestimonialTranslation"> | Date | string
  }, "id" | "testimonialId_language">

  export type TestimonialTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    testimonialId?: SortOrder
    language?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    packageName?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestimonialTranslationCountOrderByAggregateInput
    _max?: TestimonialTranslationMaxOrderByAggregateInput
    _min?: TestimonialTranslationMinOrderByAggregateInput
  }

  export type TestimonialTranslationScalarWhereWithAggregatesInput = {
    AND?: TestimonialTranslationScalarWhereWithAggregatesInput | TestimonialTranslationScalarWhereWithAggregatesInput[]
    OR?: TestimonialTranslationScalarWhereWithAggregatesInput[]
    NOT?: TestimonialTranslationScalarWhereWithAggregatesInput | TestimonialTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestimonialTranslation"> | string
    testimonialId?: StringWithAggregatesFilter<"TestimonialTranslation"> | string
    language?: StringWithAggregatesFilter<"TestimonialTranslation"> | string
    name?: StringNullableWithAggregatesFilter<"TestimonialTranslation"> | string | null
    role?: StringNullableWithAggregatesFilter<"TestimonialTranslation"> | string | null
    content?: StringNullableWithAggregatesFilter<"TestimonialTranslation"> | string | null
    packageName?: StringNullableWithAggregatesFilter<"TestimonialTranslation"> | string | null
    location?: StringNullableWithAggregatesFilter<"TestimonialTranslation"> | string | null
    isAutoTranslated?: BoolWithAggregatesFilter<"TestimonialTranslation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TestimonialTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestimonialTranslation"> | Date | string
  }

  export type GalleryTranslationWhereInput = {
    AND?: GalleryTranslationWhereInput | GalleryTranslationWhereInput[]
    OR?: GalleryTranslationWhereInput[]
    NOT?: GalleryTranslationWhereInput | GalleryTranslationWhereInput[]
    id?: StringFilter<"GalleryTranslation"> | string
    galleryId?: StringFilter<"GalleryTranslation"> | string
    language?: StringFilter<"GalleryTranslation"> | string
    title?: StringNullableFilter<"GalleryTranslation"> | string | null
    description?: StringNullableFilter<"GalleryTranslation"> | string | null
    tags?: StringNullableFilter<"GalleryTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"GalleryTranslation"> | boolean
    createdAt?: DateTimeFilter<"GalleryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GalleryTranslation"> | Date | string
  }

  export type GalleryTranslationOrderByWithRelationInput = {
    id?: SortOrder
    galleryId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: GalleryTranslationOrderByRelevanceInput
  }

  export type GalleryTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    galleryId_language?: GalleryTranslationGalleryIdLanguageCompoundUniqueInput
    AND?: GalleryTranslationWhereInput | GalleryTranslationWhereInput[]
    OR?: GalleryTranslationWhereInput[]
    NOT?: GalleryTranslationWhereInput | GalleryTranslationWhereInput[]
    galleryId?: StringFilter<"GalleryTranslation"> | string
    language?: StringFilter<"GalleryTranslation"> | string
    title?: StringNullableFilter<"GalleryTranslation"> | string | null
    description?: StringNullableFilter<"GalleryTranslation"> | string | null
    tags?: StringNullableFilter<"GalleryTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"GalleryTranslation"> | boolean
    createdAt?: DateTimeFilter<"GalleryTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"GalleryTranslation"> | Date | string
  }, "id" | "galleryId_language">

  export type GalleryTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    galleryId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GalleryTranslationCountOrderByAggregateInput
    _max?: GalleryTranslationMaxOrderByAggregateInput
    _min?: GalleryTranslationMinOrderByAggregateInput
  }

  export type GalleryTranslationScalarWhereWithAggregatesInput = {
    AND?: GalleryTranslationScalarWhereWithAggregatesInput | GalleryTranslationScalarWhereWithAggregatesInput[]
    OR?: GalleryTranslationScalarWhereWithAggregatesInput[]
    NOT?: GalleryTranslationScalarWhereWithAggregatesInput | GalleryTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GalleryTranslation"> | string
    galleryId?: StringWithAggregatesFilter<"GalleryTranslation"> | string
    language?: StringWithAggregatesFilter<"GalleryTranslation"> | string
    title?: StringNullableWithAggregatesFilter<"GalleryTranslation"> | string | null
    description?: StringNullableWithAggregatesFilter<"GalleryTranslation"> | string | null
    tags?: StringNullableWithAggregatesFilter<"GalleryTranslation"> | string | null
    isAutoTranslated?: BoolWithAggregatesFilter<"GalleryTranslation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GalleryTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GalleryTranslation"> | Date | string
  }

  export type SectionContentTranslationWhereInput = {
    AND?: SectionContentTranslationWhereInput | SectionContentTranslationWhereInput[]
    OR?: SectionContentTranslationWhereInput[]
    NOT?: SectionContentTranslationWhereInput | SectionContentTranslationWhereInput[]
    id?: StringFilter<"SectionContentTranslation"> | string
    sectionId?: StringFilter<"SectionContentTranslation"> | string
    language?: StringFilter<"SectionContentTranslation"> | string
    title?: StringNullableFilter<"SectionContentTranslation"> | string | null
    subtitle?: StringNullableFilter<"SectionContentTranslation"> | string | null
    description?: StringNullableFilter<"SectionContentTranslation"> | string | null
    ctaText?: StringNullableFilter<"SectionContentTranslation"> | string | null
    buttonText?: StringNullableFilter<"SectionContentTranslation"> | string | null
    phone?: StringNullableFilter<"SectionContentTranslation"> | string | null
    email?: StringNullableFilter<"SectionContentTranslation"> | string | null
    destinations?: StringNullableFilter<"SectionContentTranslation"> | string | null
    features?: StringNullableFilter<"SectionContentTranslation"> | string | null
    stats?: StringNullableFilter<"SectionContentTranslation"> | string | null
    packages?: StringNullableFilter<"SectionContentTranslation"> | string | null
    testimonials?: StringNullableFilter<"SectionContentTranslation"> | string | null
    posts?: StringNullableFilter<"SectionContentTranslation"> | string | null
    items?: StringNullableFilter<"SectionContentTranslation"> | string | null
    categories?: StringNullableFilter<"SectionContentTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"SectionContentTranslation"> | boolean
    createdAt?: DateTimeFilter<"SectionContentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"SectionContentTranslation"> | Date | string
  }

  export type SectionContentTranslationOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    buttonText?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    destinations?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    packages?: SortOrderInput | SortOrder
    testimonials?: SortOrderInput | SortOrder
    posts?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SectionContentTranslationOrderByRelevanceInput
  }

  export type SectionContentTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sectionId_language?: SectionContentTranslationSectionIdLanguageCompoundUniqueInput
    AND?: SectionContentTranslationWhereInput | SectionContentTranslationWhereInput[]
    OR?: SectionContentTranslationWhereInput[]
    NOT?: SectionContentTranslationWhereInput | SectionContentTranslationWhereInput[]
    sectionId?: StringFilter<"SectionContentTranslation"> | string
    language?: StringFilter<"SectionContentTranslation"> | string
    title?: StringNullableFilter<"SectionContentTranslation"> | string | null
    subtitle?: StringNullableFilter<"SectionContentTranslation"> | string | null
    description?: StringNullableFilter<"SectionContentTranslation"> | string | null
    ctaText?: StringNullableFilter<"SectionContentTranslation"> | string | null
    buttonText?: StringNullableFilter<"SectionContentTranslation"> | string | null
    phone?: StringNullableFilter<"SectionContentTranslation"> | string | null
    email?: StringNullableFilter<"SectionContentTranslation"> | string | null
    destinations?: StringNullableFilter<"SectionContentTranslation"> | string | null
    features?: StringNullableFilter<"SectionContentTranslation"> | string | null
    stats?: StringNullableFilter<"SectionContentTranslation"> | string | null
    packages?: StringNullableFilter<"SectionContentTranslation"> | string | null
    testimonials?: StringNullableFilter<"SectionContentTranslation"> | string | null
    posts?: StringNullableFilter<"SectionContentTranslation"> | string | null
    items?: StringNullableFilter<"SectionContentTranslation"> | string | null
    categories?: StringNullableFilter<"SectionContentTranslation"> | string | null
    isAutoTranslated?: BoolFilter<"SectionContentTranslation"> | boolean
    createdAt?: DateTimeFilter<"SectionContentTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"SectionContentTranslation"> | Date | string
  }, "id" | "sectionId_language">

  export type SectionContentTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    buttonText?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    destinations?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    stats?: SortOrderInput | SortOrder
    packages?: SortOrderInput | SortOrder
    testimonials?: SortOrderInput | SortOrder
    posts?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SectionContentTranslationCountOrderByAggregateInput
    _max?: SectionContentTranslationMaxOrderByAggregateInput
    _min?: SectionContentTranslationMinOrderByAggregateInput
  }

  export type SectionContentTranslationScalarWhereWithAggregatesInput = {
    AND?: SectionContentTranslationScalarWhereWithAggregatesInput | SectionContentTranslationScalarWhereWithAggregatesInput[]
    OR?: SectionContentTranslationScalarWhereWithAggregatesInput[]
    NOT?: SectionContentTranslationScalarWhereWithAggregatesInput | SectionContentTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SectionContentTranslation"> | string
    sectionId?: StringWithAggregatesFilter<"SectionContentTranslation"> | string
    language?: StringWithAggregatesFilter<"SectionContentTranslation"> | string
    title?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    subtitle?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    description?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    ctaText?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    buttonText?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    email?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    destinations?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    features?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    stats?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    packages?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    testimonials?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    posts?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    items?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    categories?: StringNullableWithAggregatesFilter<"SectionContentTranslation"> | string | null
    isAutoTranslated?: BoolWithAggregatesFilter<"SectionContentTranslation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SectionContentTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SectionContentTranslation"> | Date | string
  }

  export type ApiKeySettingsWhereInput = {
    AND?: ApiKeySettingsWhereInput | ApiKeySettingsWhereInput[]
    OR?: ApiKeySettingsWhereInput[]
    NOT?: ApiKeySettingsWhereInput | ApiKeySettingsWhereInput[]
    id?: StringFilter<"ApiKeySettings"> | string
    keys?: StringNullableFilter<"ApiKeySettings"> | string | null
    updatedAt?: DateTimeFilter<"ApiKeySettings"> | Date | string
    createdAt?: DateTimeFilter<"ApiKeySettings"> | Date | string
  }

  export type ApiKeySettingsOrderByWithRelationInput = {
    id?: SortOrder
    keys?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _relevance?: ApiKeySettingsOrderByRelevanceInput
  }

  export type ApiKeySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiKeySettingsWhereInput | ApiKeySettingsWhereInput[]
    OR?: ApiKeySettingsWhereInput[]
    NOT?: ApiKeySettingsWhereInput | ApiKeySettingsWhereInput[]
    keys?: StringNullableFilter<"ApiKeySettings"> | string | null
    updatedAt?: DateTimeFilter<"ApiKeySettings"> | Date | string
    createdAt?: DateTimeFilter<"ApiKeySettings"> | Date | string
  }, "id">

  export type ApiKeySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    keys?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: ApiKeySettingsCountOrderByAggregateInput
    _max?: ApiKeySettingsMaxOrderByAggregateInput
    _min?: ApiKeySettingsMinOrderByAggregateInput
  }

  export type ApiKeySettingsScalarWhereWithAggregatesInput = {
    AND?: ApiKeySettingsScalarWhereWithAggregatesInput | ApiKeySettingsScalarWhereWithAggregatesInput[]
    OR?: ApiKeySettingsScalarWhereWithAggregatesInput[]
    NOT?: ApiKeySettingsScalarWhereWithAggregatesInput | ApiKeySettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKeySettings"> | string
    keys?: StringNullableWithAggregatesFilter<"ApiKeySettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKeySettings"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ApiKeySettings"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    website?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"User"> | string | null
    loginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type SectionContentCreateInput = {
    id?: string
    sectionId: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaLink?: string | null
    buttonText?: string | null
    image?: string | null
    logo?: string | null
    phone?: string | null
    email?: string | null
    backgroundVideo?: string | null
    destinations?: string | null
    features?: string | null
    stats?: string | null
    packages?: string | null
    testimonials?: string | null
    posts?: string | null
    items?: string | null
    categories?: string | null
    displayCount?: number | null
    featuredOnly?: boolean | null
    category?: string | null
    sortBy?: string | null
    layoutStyle?: string | null
    showFilters?: boolean | null
    enableLightbox?: boolean | null
    enableAutoSlide?: boolean | null
    autoSlideInterval?: number | null
    transitionEffect?: string | null
    animationSpeed?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionContentUncheckedCreateInput = {
    id?: string
    sectionId: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaLink?: string | null
    buttonText?: string | null
    image?: string | null
    logo?: string | null
    phone?: string | null
    email?: string | null
    backgroundVideo?: string | null
    destinations?: string | null
    features?: string | null
    stats?: string | null
    packages?: string | null
    testimonials?: string | null
    posts?: string | null
    items?: string | null
    categories?: string | null
    displayCount?: number | null
    featuredOnly?: boolean | null
    category?: string | null
    sortBy?: string | null
    layoutStyle?: string | null
    showFilters?: boolean | null
    enableLightbox?: boolean | null
    enableAutoSlide?: boolean | null
    autoSlideInterval?: number | null
    transitionEffect?: string | null
    animationSpeed?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLink?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundVideo?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: NullableIntFieldUpdateOperationsInput | number | null
    featuredOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sortBy?: NullableStringFieldUpdateOperationsInput | string | null
    layoutStyle?: NullableStringFieldUpdateOperationsInput | string | null
    showFilters?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableLightbox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableAutoSlide?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autoSlideInterval?: NullableIntFieldUpdateOperationsInput | number | null
    transitionEffect?: NullableStringFieldUpdateOperationsInput | string | null
    animationSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLink?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundVideo?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: NullableIntFieldUpdateOperationsInput | number | null
    featuredOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sortBy?: NullableStringFieldUpdateOperationsInput | string | null
    layoutStyle?: NullableStringFieldUpdateOperationsInput | string | null
    showFilters?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableLightbox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableAutoSlide?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autoSlideInterval?: NullableIntFieldUpdateOperationsInput | number | null
    transitionEffect?: NullableStringFieldUpdateOperationsInput | string | null
    animationSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentCreateManyInput = {
    id?: string
    sectionId: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaLink?: string | null
    buttonText?: string | null
    image?: string | null
    logo?: string | null
    phone?: string | null
    email?: string | null
    backgroundVideo?: string | null
    destinations?: string | null
    features?: string | null
    stats?: string | null
    packages?: string | null
    testimonials?: string | null
    posts?: string | null
    items?: string | null
    categories?: string | null
    displayCount?: number | null
    featuredOnly?: boolean | null
    category?: string | null
    sortBy?: string | null
    layoutStyle?: string | null
    showFilters?: boolean | null
    enableLightbox?: boolean | null
    enableAutoSlide?: boolean | null
    autoSlideInterval?: number | null
    transitionEffect?: string | null
    animationSpeed?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SectionContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLink?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundVideo?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: NullableIntFieldUpdateOperationsInput | number | null
    featuredOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sortBy?: NullableStringFieldUpdateOperationsInput | string | null
    layoutStyle?: NullableStringFieldUpdateOperationsInput | string | null
    showFilters?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableLightbox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableAutoSlide?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autoSlideInterval?: NullableIntFieldUpdateOperationsInput | number | null
    transitionEffect?: NullableStringFieldUpdateOperationsInput | string | null
    animationSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaLink?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundVideo?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: NullableIntFieldUpdateOperationsInput | number | null
    featuredOnly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sortBy?: NullableStringFieldUpdateOperationsInput | string | null
    layoutStyle?: NullableStringFieldUpdateOperationsInput | string | null
    showFilters?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableLightbox?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enableAutoSlide?: NullableBoolFieldUpdateOperationsInput | boolean | null
    autoSlideInterval?: NullableIntFieldUpdateOperationsInput | number | null
    transitionEffect?: NullableStringFieldUpdateOperationsInput | string | null
    animationSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationCreateInput = {
    id?: string
    name: string
    location: string
    category: string
    rating: number
    visitors: string
    duration: string
    price: string
    description: string
    highlights: string
    image: string
    featured?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DestinationUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    category: string
    rating: number
    visitors: string
    duration: string
    price: string
    description: string
    highlights: string
    image: string
    featured?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DestinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    visitors?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    highlights?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    visitors?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    highlights?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationCreateManyInput = {
    id?: string
    name: string
    location: string
    category: string
    rating: number
    visitors: string
    duration: string
    price: string
    description: string
    highlights: string
    image: string
    featured?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type DestinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    visitors?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    highlights?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DestinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    visitors?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    highlights?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateInput = {
    id?: string
    title: string
    slug?: string | null
    duration: string
    price: number
    originalPrice?: number | null
    discount?: string | null
    rating: number
    reviewCount: number
    category: string
    description: string
    longDescription?: string | null
    destinations: string
    includes: string
    excludes?: string | null
    highlights: string
    itinerary?: string | null
    gallery?: string | null
    faqs?: string | null
    groupSize: string
    difficulty: string
    bestFor: string
    image: string
    departure?: string | null
    return?: string | null
    totalPeople?: number | null
    location?: string | null
    mapEmbedUrl?: string | null
    featured?: boolean
    available?: boolean
    status?: string
    localizedUrls?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PackageUncheckedCreateInput = {
    id?: string
    title: string
    slug?: string | null
    duration: string
    price: number
    originalPrice?: number | null
    discount?: string | null
    rating: number
    reviewCount: number
    category: string
    description: string
    longDescription?: string | null
    destinations: string
    includes: string
    excludes?: string | null
    highlights: string
    itinerary?: string | null
    gallery?: string | null
    faqs?: string | null
    groupSize: string
    difficulty: string
    bestFor: string
    image: string
    departure?: string | null
    return?: string | null
    totalPeople?: number | null
    location?: string | null
    mapEmbedUrl?: string | null
    featured?: boolean
    available?: boolean
    status?: string
    localizedUrls?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: StringFieldUpdateOperationsInput | string
    includes?: StringFieldUpdateOperationsInput | string
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: StringFieldUpdateOperationsInput | string
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    totalPeople?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: StringFieldUpdateOperationsInput | string
    includes?: StringFieldUpdateOperationsInput | string
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: StringFieldUpdateOperationsInput | string
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    totalPeople?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateManyInput = {
    id?: string
    title: string
    slug?: string | null
    duration: string
    price: number
    originalPrice?: number | null
    discount?: string | null
    rating: number
    reviewCount: number
    category: string
    description: string
    longDescription?: string | null
    destinations: string
    includes: string
    excludes?: string | null
    highlights: string
    itinerary?: string | null
    gallery?: string | null
    faqs?: string | null
    groupSize: string
    difficulty: string
    bestFor: string
    image: string
    departure?: string | null
    return?: string | null
    totalPeople?: number | null
    location?: string | null
    mapEmbedUrl?: string | null
    featured?: boolean
    available?: boolean
    status?: string
    localizedUrls?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type PackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: StringFieldUpdateOperationsInput | string
    includes?: StringFieldUpdateOperationsInput | string
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: StringFieldUpdateOperationsInput | string
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    totalPeople?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    originalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    discount?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: StringFieldUpdateOperationsInput | string
    includes?: StringFieldUpdateOperationsInput | string
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: StringFieldUpdateOperationsInput | string
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    bestFor?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    totalPeople?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    id?: string
    slug?: string | null
    title: string
    excerpt: string
    content: string
    author: string
    publishDate: Date | string
    readTime: string
    category: string
    tags: string
    image: string
    featured?: boolean
    status?: string
    localizedUrls?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    slug?: string | null
    title: string
    excerpt: string
    content: string
    author: string
    publishDate: Date | string
    readTime: string
    category: string
    tags: string
    image: string
    featured?: boolean
    status?: string
    localizedUrls?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type BlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateManyInput = {
    id?: string
    slug?: string | null
    title: string
    excerpt: string
    content: string
    author: string
    publishDate: Date | string
    readTime: string
    category: string
    tags: string
    image: string
    featured?: boolean
    status?: string
    localizedUrls?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type BlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    readTime?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    tags?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    localizedUrls?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateInput = {
    id?: string
    name: string
    role: string
    content: string
    rating: number
    image?: string | null
    packageName?: string
    location?: string
    status?: string
    featured?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TestimonialUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    content: string
    rating: number
    image?: string | null
    packageName?: string
    location?: string
    status?: string
    featured?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TestimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialCreateManyInput = {
    id?: string
    name: string
    role: string
    content: string
    rating: number
    image?: string | null
    packageName?: string
    location?: string
    status?: string
    featured?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TestimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryItemCreateInput = {
    id?: string
    title: string
    category: string
    image: string
    description?: string | null
    tags: string
    likes?: number
    views?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type GalleryItemUncheckedCreateInput = {
    id?: string
    title: string
    category: string
    image: string
    description?: string | null
    tags: string
    likes?: number
    views?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type GalleryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryItemCreateManyInput = {
    id?: string
    title: string
    category: string
    image: string
    description?: string | null
    tags: string
    likes?: number
    views?: number
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type GalleryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    whatsappNumber?: string
    whatsappGreeting?: string | null
    providerName?: string
    memberSince?: string
    providerPhone?: string
    providerEmail?: string
    brandName?: string | null
    siteLogo?: string | null
    siteTagline?: string | null
    favicon?: string | null
    siteName?: string
    siteDescription?: string | null
    defaultOgImage?: string
    siteUrl?: string
    googleSiteVerification?: string
    bingSiteVerification?: string
    activeTemplate?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    whatsappNumber?: string
    whatsappGreeting?: string | null
    providerName?: string
    memberSince?: string
    providerPhone?: string
    providerEmail?: string
    brandName?: string | null
    siteLogo?: string | null
    siteTagline?: string | null
    favicon?: string | null
    siteName?: string
    siteDescription?: string | null
    defaultOgImage?: string
    siteUrl?: string
    googleSiteVerification?: string
    bingSiteVerification?: string
    activeTemplate?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsappNumber?: StringFieldUpdateOperationsInput | string
    whatsappGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: StringFieldUpdateOperationsInput | string
    memberSince?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    siteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    siteTagline?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    defaultOgImage?: StringFieldUpdateOperationsInput | string
    siteUrl?: StringFieldUpdateOperationsInput | string
    googleSiteVerification?: StringFieldUpdateOperationsInput | string
    bingSiteVerification?: StringFieldUpdateOperationsInput | string
    activeTemplate?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsappNumber?: StringFieldUpdateOperationsInput | string
    whatsappGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: StringFieldUpdateOperationsInput | string
    memberSince?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    siteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    siteTagline?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    defaultOgImage?: StringFieldUpdateOperationsInput | string
    siteUrl?: StringFieldUpdateOperationsInput | string
    googleSiteVerification?: StringFieldUpdateOperationsInput | string
    bingSiteVerification?: StringFieldUpdateOperationsInput | string
    activeTemplate?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    whatsappNumber?: string
    whatsappGreeting?: string | null
    providerName?: string
    memberSince?: string
    providerPhone?: string
    providerEmail?: string
    brandName?: string | null
    siteLogo?: string | null
    siteTagline?: string | null
    favicon?: string | null
    siteName?: string
    siteDescription?: string | null
    defaultOgImage?: string
    siteUrl?: string
    googleSiteVerification?: string
    bingSiteVerification?: string
    activeTemplate?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsappNumber?: StringFieldUpdateOperationsInput | string
    whatsappGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: StringFieldUpdateOperationsInput | string
    memberSince?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    siteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    siteTagline?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    defaultOgImage?: StringFieldUpdateOperationsInput | string
    siteUrl?: StringFieldUpdateOperationsInput | string
    googleSiteVerification?: StringFieldUpdateOperationsInput | string
    bingSiteVerification?: StringFieldUpdateOperationsInput | string
    activeTemplate?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsappNumber?: StringFieldUpdateOperationsInput | string
    whatsappGreeting?: NullableStringFieldUpdateOperationsInput | string | null
    providerName?: StringFieldUpdateOperationsInput | string
    memberSince?: StringFieldUpdateOperationsInput | string
    providerPhone?: StringFieldUpdateOperationsInput | string
    providerEmail?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    siteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    siteTagline?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null
    defaultOgImage?: StringFieldUpdateOperationsInput | string
    siteUrl?: StringFieldUpdateOperationsInput | string
    googleSiteVerification?: StringFieldUpdateOperationsInput | string
    bingSiteVerification?: StringFieldUpdateOperationsInput | string
    activeTemplate?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizedUrlSettingsCreateInput = {
    id?: string
    contentType: string
    urlPathId?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    autoGenerate?: boolean
    customPattern?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LocalizedUrlSettingsUncheckedCreateInput = {
    id?: string
    contentType: string
    urlPathId?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    autoGenerate?: boolean
    customPattern?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LocalizedUrlSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    urlPathId?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerate?: BoolFieldUpdateOperationsInput | boolean
    customPattern?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizedUrlSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    urlPathId?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerate?: BoolFieldUpdateOperationsInput | boolean
    customPattern?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizedUrlSettingsCreateManyInput = {
    id?: string
    contentType: string
    urlPathId?: string | null
    urlPathEn?: string | null
    urlPathDe?: string | null
    urlPathNl?: string | null
    urlPathZh?: string | null
    autoGenerate?: boolean
    customPattern?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LocalizedUrlSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    urlPathId?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerate?: BoolFieldUpdateOperationsInput | boolean
    customPattern?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalizedUrlSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    urlPathId?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathEn?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathDe?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathNl?: NullableStringFieldUpdateOperationsInput | string | null
    urlPathZh?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerate?: BoolFieldUpdateOperationsInput | boolean
    customPattern?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoDataCreateInput = {
    id?: string
    pageType: string
    pageSlug: string
    title: string
    description: string
    keywords?: string | null
    canonicalUrl: string
    ogImage?: string | null
    ogType?: string
    noIndex?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeoDataUncheckedCreateInput = {
    id?: string
    pageType: string
    pageSlug: string
    title: string
    description: string
    keywords?: string | null
    canonicalUrl: string
    ogImage?: string | null
    ogType?: string
    noIndex?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeoDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageSlug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: StringFieldUpdateOperationsInput | string
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageSlug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: StringFieldUpdateOperationsInput | string
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoDataCreateManyInput = {
    id?: string
    pageType: string
    pageSlug: string
    title: string
    description: string
    keywords?: string | null
    canonicalUrl: string
    ogImage?: string | null
    ogType?: string
    noIndex?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeoDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageSlug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: StringFieldUpdateOperationsInput | string
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeoDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageType?: StringFieldUpdateOperationsInput | string
    pageSlug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    keywords?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: StringFieldUpdateOperationsInput | string
    ogImage?: NullableStringFieldUpdateOperationsInput | string | null
    ogType?: StringFieldUpdateOperationsInput | string
    noIndex?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapLogCreateInput = {
    id?: string
    totalPages: number
    lastGenerated: Date | string
    googlePinged?: boolean
    bingPinged?: boolean
    createdAt?: Date | string
  }

  export type SitemapLogUncheckedCreateInput = {
    id?: string
    totalPages: number
    lastGenerated: Date | string
    googlePinged?: boolean
    bingPinged?: boolean
    createdAt?: Date | string
  }

  export type SitemapLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    lastGenerated?: DateTimeFieldUpdateOperationsInput | Date | string
    googlePinged?: BoolFieldUpdateOperationsInput | boolean
    bingPinged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    lastGenerated?: DateTimeFieldUpdateOperationsInput | Date | string
    googlePinged?: BoolFieldUpdateOperationsInput | boolean
    bingPinged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapLogCreateManyInput = {
    id?: string
    totalPages: number
    lastGenerated: Date | string
    googlePinged?: boolean
    bingPinged?: boolean
    createdAt?: Date | string
  }

  export type SitemapLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    lastGenerated?: DateTimeFieldUpdateOperationsInput | Date | string
    googlePinged?: BoolFieldUpdateOperationsInput | boolean
    bingPinged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SitemapLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalPages?: IntFieldUpdateOperationsInput | number
    lastGenerated?: DateTimeFieldUpdateOperationsInput | Date | string
    googlePinged?: BoolFieldUpdateOperationsInput | boolean
    bingPinged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    packageId: string
    packageName: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkInDate: Date | string
    checkOutDate: Date | string
    adults: number
    children: number
    infants: number
    totalPrice: number
    status?: string
    paymentStatus?: string
    specialRequests?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    packageId: string
    packageName: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkInDate: Date | string
    checkOutDate: Date | string
    adults: number
    children: number
    infants: number
    totalPrice: number
    status?: string
    paymentStatus?: string
    specialRequests?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    packageName?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    infants?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    packageName?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    infants?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id?: string
    packageId: string
    packageName: string
    customerName: string
    customerEmail: string
    customerPhone: string
    checkInDate: Date | string
    checkOutDate: Date | string
    adults: number
    children: number
    infants: number
    totalPrice: number
    status?: string
    paymentStatus?: string
    specialRequests?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    packageName?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    infants?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    packageName?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    customerEmail?: StringFieldUpdateOperationsInput | string
    customerPhone?: StringFieldUpdateOperationsInput | string
    checkInDate?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOutDate?: DateTimeFieldUpdateOperationsInput | Date | string
    adults?: IntFieldUpdateOperationsInput | number
    children?: IntFieldUpdateOperationsInput | number
    infants?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationMenuCreateInput = {
    id?: string
    name: string
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: NavigationItemCreateNestedManyWithoutMenuInput
  }

  export type NavigationMenuUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: NavigationItemUncheckedCreateNestedManyWithoutMenuInput
  }

  export type NavigationMenuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NavigationItemUpdateManyWithoutMenuNestedInput
  }

  export type NavigationMenuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NavigationItemUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type NavigationMenuCreateManyInput = {
    id?: string
    name: string
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavigationMenuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationMenuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationItemCreateInput = {
    id?: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationCreateNestedManyWithoutItemInput
    menu: NavigationMenuCreateNestedOneWithoutItemsInput
    parent?: NavigationItemCreateNestedOneWithoutChildrenInput
    children?: NavigationItemCreateNestedManyWithoutParentInput
  }

  export type NavigationItemUncheckedCreateInput = {
    id?: string
    menuId: string
    parentId?: string | null
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationUncheckedCreateNestedManyWithoutItemInput
    children?: NavigationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type NavigationItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUpdateManyWithoutItemNestedInput
    menu?: NavigationMenuUpdateOneRequiredWithoutItemsNestedInput
    parent?: NavigationItemUpdateOneWithoutChildrenNestedInput
    children?: NavigationItemUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUncheckedUpdateManyWithoutItemNestedInput
    children?: NavigationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemCreateManyInput = {
    id?: string
    menuId: string
    parentId?: string | null
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavigationItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationItemTranslationCreateInput = {
    id?: string
    language: string
    title: string
    url: string
    item: NavigationItemCreateNestedOneWithoutTranslationsInput
  }

  export type NavigationItemTranslationUncheckedCreateInput = {
    id?: string
    itemId: string
    language: string
    title: string
    url: string
  }

  export type NavigationItemTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    item?: NavigationItemUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type NavigationItemTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type NavigationItemTranslationCreateManyInput = {
    id?: string
    itemId: string
    language: string
    title: string
    url: string
  }

  export type NavigationItemTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type NavigationItemTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type BannerCreateInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: BannerTranslationCreateNestedManyWithoutBannerInput
    placements?: BannerPlacementCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: BannerTranslationUncheckedCreateNestedManyWithoutBannerInput
    placements?: BannerPlacementUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: BannerTranslationUpdateManyWithoutBannerNestedInput
    placements?: BannerPlacementUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: BannerTranslationUncheckedUpdateManyWithoutBannerNestedInput
    placements?: BannerPlacementUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerCreateManyInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerTranslationCreateInput = {
    id?: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    imageUrl?: string | null
    banner: BannerCreateNestedOneWithoutTranslationsInput
  }

  export type BannerTranslationUncheckedCreateInput = {
    id?: string
    bannerId: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    imageUrl?: string | null
  }

  export type BannerTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    banner?: BannerUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type BannerTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannerTranslationCreateManyInput = {
    id?: string
    bannerId: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    imageUrl?: string | null
  }

  export type BannerTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannerTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannerPlacementCreateInput = {
    id?: string
    location: string
    position?: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    banner: BannerCreateNestedOneWithoutPlacementsInput
  }

  export type BannerPlacementUncheckedCreateInput = {
    id?: string
    bannerId: string
    location: string
    position?: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BannerPlacementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    banner?: BannerUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type BannerPlacementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerPlacementCreateManyInput = {
    id?: string
    bannerId: string
    location: string
    position?: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BannerPlacementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerPlacementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bannerId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TopbarSettingsCreateInput = {
    id?: string
    isEnabled?: boolean
    phone?: string
    email?: string
    announcement?: string | null
    showLanguage?: boolean
    showSocial?: boolean
    socialLinks?: string | null
    backgroundColor?: string
    textColor?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TopbarSettingsUncheckedCreateInput = {
    id?: string
    isEnabled?: boolean
    phone?: string
    email?: string
    announcement?: string | null
    showLanguage?: boolean
    showSocial?: boolean
    socialLinks?: string | null
    backgroundColor?: string
    textColor?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TopbarSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    announcement?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguage?: BoolFieldUpdateOperationsInput | boolean
    showSocial?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopbarSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    announcement?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguage?: BoolFieldUpdateOperationsInput | boolean
    showSocial?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopbarSettingsCreateManyInput = {
    id?: string
    isEnabled?: boolean
    phone?: string
    email?: string
    announcement?: string | null
    showLanguage?: boolean
    showSocial?: boolean
    socialLinks?: string | null
    backgroundColor?: string
    textColor?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type TopbarSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    announcement?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguage?: BoolFieldUpdateOperationsInput | boolean
    showSocial?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopbarSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    announcement?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguage?: BoolFieldUpdateOperationsInput | boolean
    showSocial?: BoolFieldUpdateOperationsInput | boolean
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MobileMenuSettingsCreateInput = {
    id?: string
    menuType?: string
    position?: string
    animation?: string
    backgroundColor?: string
    textColor?: string
    iconColor?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MobileMenuSettingsUncheckedCreateInput = {
    id?: string
    menuType?: string
    position?: string
    animation?: string
    backgroundColor?: string
    textColor?: string
    iconColor?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MobileMenuSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuType?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    iconColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MobileMenuSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuType?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    iconColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MobileMenuSettingsCreateManyInput = {
    id?: string
    menuType?: string
    position?: string
    animation?: string
    backgroundColor?: string
    textColor?: string
    iconColor?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type MobileMenuSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuType?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    iconColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MobileMenuSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuType?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    iconColor?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSettingsCreateInput = {
    id?: string
    defaultLanguage?: string
    supportedLanguages?: string | null
    showLanguageSwitcher?: boolean
    languageSwitcherPosition?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LanguageSettingsUncheckedCreateInput = {
    id?: string
    defaultLanguage?: string
    supportedLanguages?: string | null
    showLanguageSwitcher?: boolean
    languageSwitcherPosition?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LanguageSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    supportedLanguages?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguageSwitcher?: BoolFieldUpdateOperationsInput | boolean
    languageSwitcherPosition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    supportedLanguages?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguageSwitcher?: BoolFieldUpdateOperationsInput | boolean
    languageSwitcherPosition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSettingsCreateManyInput = {
    id?: string
    defaultLanguage?: string
    supportedLanguages?: string | null
    showLanguageSwitcher?: boolean
    languageSwitcherPosition?: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LanguageSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    supportedLanguages?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguageSwitcher?: BoolFieldUpdateOperationsInput | boolean
    languageSwitcherPosition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LanguageSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultLanguage?: StringFieldUpdateOperationsInput | string
    supportedLanguages?: NullableStringFieldUpdateOperationsInput | string | null
    showLanguageSwitcher?: BoolFieldUpdateOperationsInput | boolean
    languageSwitcherPosition?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomIconCreateInput = {
    id?: string
    name: string
    svgContent: string
    category?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomIconUncheckedCreateInput = {
    id?: string
    name: string
    svgContent: string
    category?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomIconUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    svgContent?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomIconUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    svgContent?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomIconCreateManyInput = {
    id?: string
    name: string
    svgContent: string
    category?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomIconUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    svgContent?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomIconUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    svgContent?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageTranslationCreateInput = {
    id?: string
    packageId: string
    language: string
    title?: string | null
    description?: string | null
    longDescription?: string | null
    destinations?: string | null
    includes?: string | null
    excludes?: string | null
    highlights?: string | null
    itinerary?: string | null
    faqs?: string | null
    groupSize?: string | null
    difficulty?: string | null
    bestFor?: string | null
    departure?: string | null
    return?: string | null
    location?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageTranslationUncheckedCreateInput = {
    id?: string
    packageId: string
    language: string
    title?: string | null
    description?: string | null
    longDescription?: string | null
    destinations?: string | null
    includes?: string | null
    excludes?: string | null
    highlights?: string | null
    itinerary?: string | null
    faqs?: string | null
    groupSize?: string | null
    difficulty?: string | null
    bestFor?: string | null
    departure?: string | null
    return?: string | null
    location?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: NullableStringFieldUpdateOperationsInput | string | null
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: NullableStringFieldUpdateOperationsInput | string | null
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageTranslationCreateManyInput = {
    id?: string
    packageId: string
    language: string
    title?: string | null
    description?: string | null
    longDescription?: string | null
    destinations?: string | null
    includes?: string | null
    excludes?: string | null
    highlights?: string | null
    itinerary?: string | null
    faqs?: string | null
    groupSize?: string | null
    difficulty?: string | null
    bestFor?: string | null
    departure?: string | null
    return?: string | null
    location?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackageTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: NullableStringFieldUpdateOperationsInput | string | null
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: NullableStringFieldUpdateOperationsInput | string | null
    excludes?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    itinerary?: NullableStringFieldUpdateOperationsInput | string | null
    faqs?: NullableStringFieldUpdateOperationsInput | string | null
    groupSize?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    bestFor?: NullableStringFieldUpdateOperationsInput | string | null
    departure?: NullableStringFieldUpdateOperationsInput | string | null
    return?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTranslationCreateInput = {
    id?: string
    blogId: string
    language: string
    title?: string | null
    excerpt?: string | null
    content?: string | null
    category?: string | null
    tags?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTranslationUncheckedCreateInput = {
    id?: string
    blogId: string
    language: string
    title?: string | null
    excerpt?: string | null
    content?: string | null
    category?: string | null
    tags?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTranslationCreateManyInput = {
    id?: string
    blogId: string
    language: string
    title?: string | null
    excerpt?: string | null
    content?: string | null
    category?: string | null
    tags?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blogId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialTranslationCreateInput = {
    id?: string
    testimonialId: string
    language: string
    name?: string | null
    role?: string | null
    content?: string | null
    packageName?: string | null
    location?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialTranslationUncheckedCreateInput = {
    id?: string
    testimonialId: string
    language: string
    name?: string | null
    role?: string | null
    content?: string | null
    packageName?: string | null
    location?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialTranslationCreateManyInput = {
    id?: string
    testimonialId: string
    language: string
    name?: string | null
    role?: string | null
    content?: string | null
    packageName?: string | null
    location?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestimonialTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestimonialTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testimonialId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    packageName?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryTranslationCreateInput = {
    id?: string
    galleryId: string
    language: string
    title?: string | null
    description?: string | null
    tags?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GalleryTranslationUncheckedCreateInput = {
    id?: string
    galleryId: string
    language: string
    title?: string | null
    description?: string | null
    tags?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GalleryTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    galleryId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    galleryId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryTranslationCreateManyInput = {
    id?: string
    galleryId: string
    language: string
    title?: string | null
    description?: string | null
    tags?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GalleryTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    galleryId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GalleryTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    galleryId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentTranslationCreateInput = {
    id?: string
    sectionId: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    buttonText?: string | null
    phone?: string | null
    email?: string | null
    destinations?: string | null
    features?: string | null
    stats?: string | null
    packages?: string | null
    testimonials?: string | null
    posts?: string | null
    items?: string | null
    categories?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionContentTranslationUncheckedCreateInput = {
    id?: string
    sectionId: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    buttonText?: string | null
    phone?: string | null
    email?: string | null
    destinations?: string | null
    features?: string | null
    stats?: string | null
    packages?: string | null
    testimonials?: string | null
    posts?: string | null
    items?: string | null
    categories?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionContentTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentTranslationCreateManyInput = {
    id?: string
    sectionId: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    buttonText?: string | null
    phone?: string | null
    email?: string | null
    destinations?: string | null
    features?: string | null
    stats?: string | null
    packages?: string | null
    testimonials?: string | null
    posts?: string | null
    items?: string | null
    categories?: string | null
    isAutoTranslated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SectionContentTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionContentTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    destinations?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableStringFieldUpdateOperationsInput | string | null
    stats?: NullableStringFieldUpdateOperationsInput | string | null
    packages?: NullableStringFieldUpdateOperationsInput | string | null
    testimonials?: NullableStringFieldUpdateOperationsInput | string | null
    posts?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    isAutoTranslated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeySettingsCreateInput = {
    id?: string
    keys?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ApiKeySettingsUncheckedCreateInput = {
    id?: string
    keys?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ApiKeySettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keys?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeySettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keys?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeySettingsCreateManyInput = {
    id?: string
    keys?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ApiKeySettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keys?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeySettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keys?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    displayName: string
    firstName?: string | null
    lastName?: string | null
    role?: string
    status?: string
    avatar?: string | null
    bio?: string | null
    website?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    displayName: string
    firstName?: string | null
    lastName?: string | null
    role?: string
    status?: string
    avatar?: string | null
    bio?: string | null
    website?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    displayName: string
    firstName?: string | null
    lastName?: string | null
    role?: string
    status?: string
    avatar?: string | null
    bio?: string | null
    website?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SectionContentOrderByRelevanceInput = {
    fields: SectionContentOrderByRelevanceFieldEnum | SectionContentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SectionContentCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    ctaLink?: SortOrder
    buttonText?: SortOrder
    image?: SortOrder
    logo?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    backgroundVideo?: SortOrder
    destinations?: SortOrder
    features?: SortOrder
    stats?: SortOrder
    packages?: SortOrder
    testimonials?: SortOrder
    posts?: SortOrder
    items?: SortOrder
    categories?: SortOrder
    displayCount?: SortOrder
    featuredOnly?: SortOrder
    category?: SortOrder
    sortBy?: SortOrder
    layoutStyle?: SortOrder
    showFilters?: SortOrder
    enableLightbox?: SortOrder
    enableAutoSlide?: SortOrder
    autoSlideInterval?: SortOrder
    transitionEffect?: SortOrder
    animationSpeed?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SectionContentAvgOrderByAggregateInput = {
    displayCount?: SortOrder
    autoSlideInterval?: SortOrder
  }

  export type SectionContentMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    ctaLink?: SortOrder
    buttonText?: SortOrder
    image?: SortOrder
    logo?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    backgroundVideo?: SortOrder
    destinations?: SortOrder
    features?: SortOrder
    stats?: SortOrder
    packages?: SortOrder
    testimonials?: SortOrder
    posts?: SortOrder
    items?: SortOrder
    categories?: SortOrder
    displayCount?: SortOrder
    featuredOnly?: SortOrder
    category?: SortOrder
    sortBy?: SortOrder
    layoutStyle?: SortOrder
    showFilters?: SortOrder
    enableLightbox?: SortOrder
    enableAutoSlide?: SortOrder
    autoSlideInterval?: SortOrder
    transitionEffect?: SortOrder
    animationSpeed?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SectionContentMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    ctaLink?: SortOrder
    buttonText?: SortOrder
    image?: SortOrder
    logo?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    backgroundVideo?: SortOrder
    destinations?: SortOrder
    features?: SortOrder
    stats?: SortOrder
    packages?: SortOrder
    testimonials?: SortOrder
    posts?: SortOrder
    items?: SortOrder
    categories?: SortOrder
    displayCount?: SortOrder
    featuredOnly?: SortOrder
    category?: SortOrder
    sortBy?: SortOrder
    layoutStyle?: SortOrder
    showFilters?: SortOrder
    enableLightbox?: SortOrder
    enableAutoSlide?: SortOrder
    autoSlideInterval?: SortOrder
    transitionEffect?: SortOrder
    animationSpeed?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SectionContentSumOrderByAggregateInput = {
    displayCount?: SortOrder
    autoSlideInterval?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DestinationOrderByRelevanceInput = {
    fields: DestinationOrderByRelevanceFieldEnum | DestinationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DestinationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    visitors?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    highlights?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DestinationAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type DestinationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    visitors?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    highlights?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DestinationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    visitors?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    description?: SortOrder
    highlights?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type DestinationSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PackageOrderByRelevanceInput = {
    fields: PackageOrderByRelevanceFieldEnum | PackageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    gallery?: SortOrder
    faqs?: SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    departure?: SortOrder
    return?: SortOrder
    totalPeople?: SortOrder
    location?: SortOrder
    mapEmbedUrl?: SortOrder
    featured?: SortOrder
    available?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    totalPeople?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    gallery?: SortOrder
    faqs?: SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    departure?: SortOrder
    return?: SortOrder
    totalPeople?: SortOrder
    location?: SortOrder
    mapEmbedUrl?: SortOrder
    featured?: SortOrder
    available?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    discount?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    category?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    gallery?: SortOrder
    faqs?: SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    image?: SortOrder
    departure?: SortOrder
    return?: SortOrder
    totalPeople?: SortOrder
    location?: SortOrder
    mapEmbedUrl?: SortOrder
    featured?: SortOrder
    available?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    totalPeople?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BlogOrderByRelevanceInput = {
    fields: BlogOrderByRelevanceFieldEnum | BlogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    readTime?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    readTime?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    readTime?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    image?: SortOrder
    featured?: SortOrder
    status?: SortOrder
    localizedUrls?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialOrderByRelevanceInput = {
    fields: TestimonialOrderByRelevanceFieldEnum | TestimonialOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestimonialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    image?: SortOrder
    packageName?: SortOrder
    location?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TestimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    image?: SortOrder
    packageName?: SortOrder
    location?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    image?: SortOrder
    packageName?: SortOrder
    location?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TestimonialSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type GalleryItemOrderByRelevanceInput = {
    fields: GalleryItemOrderByRelevanceFieldEnum | GalleryItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GalleryItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GalleryItemAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type GalleryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GalleryItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    category?: SortOrder
    image?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GalleryItemSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
  }

  export type SettingsOrderByRelevanceInput = {
    fields: SettingsOrderByRelevanceFieldEnum | SettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    whatsappNumber?: SortOrder
    whatsappGreeting?: SortOrder
    providerName?: SortOrder
    memberSince?: SortOrder
    providerPhone?: SortOrder
    providerEmail?: SortOrder
    brandName?: SortOrder
    siteLogo?: SortOrder
    siteTagline?: SortOrder
    favicon?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    defaultOgImage?: SortOrder
    siteUrl?: SortOrder
    googleSiteVerification?: SortOrder
    bingSiteVerification?: SortOrder
    activeTemplate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    whatsappNumber?: SortOrder
    whatsappGreeting?: SortOrder
    providerName?: SortOrder
    memberSince?: SortOrder
    providerPhone?: SortOrder
    providerEmail?: SortOrder
    brandName?: SortOrder
    siteLogo?: SortOrder
    siteTagline?: SortOrder
    favicon?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    defaultOgImage?: SortOrder
    siteUrl?: SortOrder
    googleSiteVerification?: SortOrder
    bingSiteVerification?: SortOrder
    activeTemplate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    whatsappNumber?: SortOrder
    whatsappGreeting?: SortOrder
    providerName?: SortOrder
    memberSince?: SortOrder
    providerPhone?: SortOrder
    providerEmail?: SortOrder
    brandName?: SortOrder
    siteLogo?: SortOrder
    siteTagline?: SortOrder
    favicon?: SortOrder
    siteName?: SortOrder
    siteDescription?: SortOrder
    defaultOgImage?: SortOrder
    siteUrl?: SortOrder
    googleSiteVerification?: SortOrder
    bingSiteVerification?: SortOrder
    activeTemplate?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LocalizedUrlSettingsOrderByRelevanceInput = {
    fields: LocalizedUrlSettingsOrderByRelevanceFieldEnum | LocalizedUrlSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocalizedUrlSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    urlPathId?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    autoGenerate?: SortOrder
    customPattern?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LocalizedUrlSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    urlPathId?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    autoGenerate?: SortOrder
    customPattern?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LocalizedUrlSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    contentType?: SortOrder
    urlPathId?: SortOrder
    urlPathEn?: SortOrder
    urlPathDe?: SortOrder
    urlPathNl?: SortOrder
    urlPathZh?: SortOrder
    autoGenerate?: SortOrder
    customPattern?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SeoDataOrderByRelevanceInput = {
    fields: SeoDataOrderByRelevanceFieldEnum | SeoDataOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SeoDataPageTypePageSlugCompoundUniqueInput = {
    pageType: string
    pageSlug: string
  }

  export type SeoDataCountOrderByAggregateInput = {
    id?: SortOrder
    pageType?: SortOrder
    pageSlug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    canonicalUrl?: SortOrder
    ogImage?: SortOrder
    ogType?: SortOrder
    noIndex?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SeoDataMaxOrderByAggregateInput = {
    id?: SortOrder
    pageType?: SortOrder
    pageSlug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    canonicalUrl?: SortOrder
    ogImage?: SortOrder
    ogType?: SortOrder
    noIndex?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SeoDataMinOrderByAggregateInput = {
    id?: SortOrder
    pageType?: SortOrder
    pageSlug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    keywords?: SortOrder
    canonicalUrl?: SortOrder
    ogImage?: SortOrder
    ogType?: SortOrder
    noIndex?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SitemapLogOrderByRelevanceInput = {
    fields: SitemapLogOrderByRelevanceFieldEnum | SitemapLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SitemapLogCountOrderByAggregateInput = {
    id?: SortOrder
    totalPages?: SortOrder
    lastGenerated?: SortOrder
    googlePinged?: SortOrder
    bingPinged?: SortOrder
    createdAt?: SortOrder
  }

  export type SitemapLogAvgOrderByAggregateInput = {
    totalPages?: SortOrder
  }

  export type SitemapLogMaxOrderByAggregateInput = {
    id?: SortOrder
    totalPages?: SortOrder
    lastGenerated?: SortOrder
    googlePinged?: SortOrder
    bingPinged?: SortOrder
    createdAt?: SortOrder
  }

  export type SitemapLogMinOrderByAggregateInput = {
    id?: SortOrder
    totalPages?: SortOrder
    lastGenerated?: SortOrder
    googlePinged?: SortOrder
    bingPinged?: SortOrder
    createdAt?: SortOrder
  }

  export type SitemapLogSumOrderByAggregateInput = {
    totalPages?: SortOrder
  }

  export type BookingOrderByRelevanceInput = {
    fields: BookingOrderByRelevanceFieldEnum | BookingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    packageName?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    specialRequests?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    packageName?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    specialRequests?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    packageName?: SortOrder
    customerName?: SortOrder
    customerEmail?: SortOrder
    customerPhone?: SortOrder
    checkInDate?: SortOrder
    checkOutDate?: SortOrder
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    specialRequests?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    adults?: SortOrder
    children?: SortOrder
    infants?: SortOrder
    totalPrice?: SortOrder
  }

  export type NavigationItemListRelationFilter = {
    every?: NavigationItemWhereInput
    some?: NavigationItemWhereInput
    none?: NavigationItemWhereInput
  }

  export type NavigationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NavigationMenuOrderByRelevanceInput = {
    fields: NavigationMenuOrderByRelevanceFieldEnum | NavigationMenuOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NavigationMenuCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavigationMenuMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavigationMenuMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavigationItemTranslationListRelationFilter = {
    every?: NavigationItemTranslationWhereInput
    some?: NavigationItemTranslationWhereInput
    none?: NavigationItemTranslationWhereInput
  }

  export type NavigationMenuScalarRelationFilter = {
    is?: NavigationMenuWhereInput
    isNot?: NavigationMenuWhereInput
  }

  export type NavigationItemNullableScalarRelationFilter = {
    is?: NavigationItemWhereInput | null
    isNot?: NavigationItemWhereInput | null
  }

  export type NavigationItemTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NavigationItemOrderByRelevanceInput = {
    fields: NavigationItemOrderByRelevanceFieldEnum | NavigationItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NavigationItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isExternal?: SortOrder
    target?: SortOrder
    iconType?: SortOrder
    iconName?: SortOrder
    iconUrl?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    hoverColor?: SortOrder
    activeColor?: SortOrder
    fontFamily?: SortOrder
    fontSize?: SortOrder
    fontWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavigationItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NavigationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isExternal?: SortOrder
    target?: SortOrder
    iconType?: SortOrder
    iconName?: SortOrder
    iconUrl?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    hoverColor?: SortOrder
    activeColor?: SortOrder
    fontFamily?: SortOrder
    fontSize?: SortOrder
    fontWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavigationItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    isExternal?: SortOrder
    target?: SortOrder
    iconType?: SortOrder
    iconName?: SortOrder
    iconUrl?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    hoverColor?: SortOrder
    activeColor?: SortOrder
    fontFamily?: SortOrder
    fontSize?: SortOrder
    fontWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NavigationItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type NavigationItemScalarRelationFilter = {
    is?: NavigationItemWhereInput
    isNot?: NavigationItemWhereInput
  }

  export type NavigationItemTranslationOrderByRelevanceInput = {
    fields: NavigationItemTranslationOrderByRelevanceFieldEnum | NavigationItemTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NavigationItemTranslationItemIdLanguageCompoundUniqueInput = {
    itemId: string
    language: string
  }

  export type NavigationItemTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    url?: SortOrder
  }

  export type NavigationItemTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    url?: SortOrder
  }

  export type NavigationItemTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    url?: SortOrder
  }

  export type BannerTranslationListRelationFilter = {
    every?: BannerTranslationWhereInput
    some?: BannerTranslationWhereInput
    none?: BannerTranslationWhereInput
  }

  export type BannerPlacementListRelationFilter = {
    every?: BannerPlacementWhereInput
    some?: BannerPlacementWhereInput
    none?: BannerPlacementWhereInput
  }

  export type BannerTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerPlacementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerOrderByRelevanceInput = {
    fields: BannerOrderByRelevanceFieldEnum | BannerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    displayType?: SortOrder
    imageUrl?: SortOrder
    backgroundColor?: SortOrder
    overlayColor?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    isActive?: SortOrder
    customHtml?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    displayType?: SortOrder
    imageUrl?: SortOrder
    backgroundColor?: SortOrder
    overlayColor?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    isActive?: SortOrder
    customHtml?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    displayType?: SortOrder
    imageUrl?: SortOrder
    backgroundColor?: SortOrder
    overlayColor?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    isActive?: SortOrder
    customHtml?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerScalarRelationFilter = {
    is?: BannerWhereInput
    isNot?: BannerWhereInput
  }

  export type BannerTranslationOrderByRelevanceInput = {
    fields: BannerTranslationOrderByRelevanceFieldEnum | BannerTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BannerTranslationBannerIdLanguageCompoundUniqueInput = {
    bannerId: string
    language: string
  }

  export type BannerTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    imageUrl?: SortOrder
  }

  export type BannerTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    imageUrl?: SortOrder
  }

  export type BannerTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    imageUrl?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BannerPlacementOrderByRelevanceInput = {
    fields: BannerPlacementOrderByRelevanceFieldEnum | BannerPlacementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BannerPlacementCountOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    location?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type BannerPlacementAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type BannerPlacementMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    location?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type BannerPlacementMinOrderByAggregateInput = {
    id?: SortOrder
    bannerId?: SortOrder
    location?: SortOrder
    position?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type BannerPlacementSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TopbarSettingsOrderByRelevanceInput = {
    fields: TopbarSettingsOrderByRelevanceFieldEnum | TopbarSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TopbarSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    announcement?: SortOrder
    showLanguage?: SortOrder
    showSocial?: SortOrder
    socialLinks?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TopbarSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    announcement?: SortOrder
    showLanguage?: SortOrder
    showSocial?: SortOrder
    socialLinks?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TopbarSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    isEnabled?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    announcement?: SortOrder
    showLanguage?: SortOrder
    showSocial?: SortOrder
    socialLinks?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MobileMenuSettingsOrderByRelevanceInput = {
    fields: MobileMenuSettingsOrderByRelevanceFieldEnum | MobileMenuSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MobileMenuSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    menuType?: SortOrder
    position?: SortOrder
    animation?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    iconColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MobileMenuSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    menuType?: SortOrder
    position?: SortOrder
    animation?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    iconColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MobileMenuSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    menuType?: SortOrder
    position?: SortOrder
    animation?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    iconColor?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LanguageSettingsOrderByRelevanceInput = {
    fields: LanguageSettingsOrderByRelevanceFieldEnum | LanguageSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LanguageSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    defaultLanguage?: SortOrder
    supportedLanguages?: SortOrder
    showLanguageSwitcher?: SortOrder
    languageSwitcherPosition?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LanguageSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    defaultLanguage?: SortOrder
    supportedLanguages?: SortOrder
    showLanguageSwitcher?: SortOrder
    languageSwitcherPosition?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LanguageSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    defaultLanguage?: SortOrder
    supportedLanguages?: SortOrder
    showLanguageSwitcher?: SortOrder
    languageSwitcherPosition?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomIconOrderByRelevanceInput = {
    fields: CustomIconOrderByRelevanceFieldEnum | CustomIconOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomIconCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    svgContent?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomIconMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    svgContent?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomIconMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    svgContent?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageTranslationOrderByRelevanceInput = {
    fields: PackageTranslationOrderByRelevanceFieldEnum | PackageTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PackageTranslationPackageIdLanguageCompoundUniqueInput = {
    packageId: string
    language: string
  }

  export type PackageTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    faqs?: SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    departure?: SortOrder
    return?: SortOrder
    location?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    faqs?: SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    departure?: SortOrder
    return?: SortOrder
    location?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackageTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    packageId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    longDescription?: SortOrder
    destinations?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    highlights?: SortOrder
    itinerary?: SortOrder
    faqs?: SortOrder
    groupSize?: SortOrder
    difficulty?: SortOrder
    bestFor?: SortOrder
    departure?: SortOrder
    return?: SortOrder
    location?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTranslationOrderByRelevanceInput = {
    fields: BlogTranslationOrderByRelevanceFieldEnum | BlogTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BlogTranslationBlogIdLanguageCompoundUniqueInput = {
    blogId: string
    language: string
  }

  export type BlogTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    blogId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    content?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialTranslationOrderByRelevanceInput = {
    fields: TestimonialTranslationOrderByRelevanceFieldEnum | TestimonialTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestimonialTranslationTestimonialIdLanguageCompoundUniqueInput = {
    testimonialId: string
    language: string
  }

  export type TestimonialTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    testimonialId?: SortOrder
    language?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    packageName?: SortOrder
    location?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    testimonialId?: SortOrder
    language?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    packageName?: SortOrder
    location?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestimonialTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    testimonialId?: SortOrder
    language?: SortOrder
    name?: SortOrder
    role?: SortOrder
    content?: SortOrder
    packageName?: SortOrder
    location?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GalleryTranslationOrderByRelevanceInput = {
    fields: GalleryTranslationOrderByRelevanceFieldEnum | GalleryTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GalleryTranslationGalleryIdLanguageCompoundUniqueInput = {
    galleryId: string
    language: string
  }

  export type GalleryTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    galleryId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GalleryTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    galleryId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GalleryTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    galleryId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionContentTranslationOrderByRelevanceInput = {
    fields: SectionContentTranslationOrderByRelevanceFieldEnum | SectionContentTranslationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SectionContentTranslationSectionIdLanguageCompoundUniqueInput = {
    sectionId: string
    language: string
  }

  export type SectionContentTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    buttonText?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    destinations?: SortOrder
    features?: SortOrder
    stats?: SortOrder
    packages?: SortOrder
    testimonials?: SortOrder
    posts?: SortOrder
    items?: SortOrder
    categories?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionContentTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    buttonText?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    destinations?: SortOrder
    features?: SortOrder
    stats?: SortOrder
    packages?: SortOrder
    testimonials?: SortOrder
    posts?: SortOrder
    items?: SortOrder
    categories?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SectionContentTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    ctaText?: SortOrder
    buttonText?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    destinations?: SortOrder
    features?: SortOrder
    stats?: SortOrder
    packages?: SortOrder
    testimonials?: SortOrder
    posts?: SortOrder
    items?: SortOrder
    categories?: SortOrder
    isAutoTranslated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeySettingsOrderByRelevanceInput = {
    fields: ApiKeySettingsOrderByRelevanceFieldEnum | ApiKeySettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ApiKeySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    keys?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    keys?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    keys?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    displayName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    website?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NavigationItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<NavigationItemCreateWithoutMenuInput, NavigationItemUncheckedCreateWithoutMenuInput> | NavigationItemCreateWithoutMenuInput[] | NavigationItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutMenuInput | NavigationItemCreateOrConnectWithoutMenuInput[]
    createMany?: NavigationItemCreateManyMenuInputEnvelope
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
  }

  export type NavigationItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<NavigationItemCreateWithoutMenuInput, NavigationItemUncheckedCreateWithoutMenuInput> | NavigationItemCreateWithoutMenuInput[] | NavigationItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutMenuInput | NavigationItemCreateOrConnectWithoutMenuInput[]
    createMany?: NavigationItemCreateManyMenuInputEnvelope
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
  }

  export type NavigationItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<NavigationItemCreateWithoutMenuInput, NavigationItemUncheckedCreateWithoutMenuInput> | NavigationItemCreateWithoutMenuInput[] | NavigationItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutMenuInput | NavigationItemCreateOrConnectWithoutMenuInput[]
    upsert?: NavigationItemUpsertWithWhereUniqueWithoutMenuInput | NavigationItemUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: NavigationItemCreateManyMenuInputEnvelope
    set?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    disconnect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    delete?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    update?: NavigationItemUpdateWithWhereUniqueWithoutMenuInput | NavigationItemUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: NavigationItemUpdateManyWithWhereWithoutMenuInput | NavigationItemUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: NavigationItemScalarWhereInput | NavigationItemScalarWhereInput[]
  }

  export type NavigationItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<NavigationItemCreateWithoutMenuInput, NavigationItemUncheckedCreateWithoutMenuInput> | NavigationItemCreateWithoutMenuInput[] | NavigationItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutMenuInput | NavigationItemCreateOrConnectWithoutMenuInput[]
    upsert?: NavigationItemUpsertWithWhereUniqueWithoutMenuInput | NavigationItemUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: NavigationItemCreateManyMenuInputEnvelope
    set?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    disconnect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    delete?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    update?: NavigationItemUpdateWithWhereUniqueWithoutMenuInput | NavigationItemUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: NavigationItemUpdateManyWithWhereWithoutMenuInput | NavigationItemUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: NavigationItemScalarWhereInput | NavigationItemScalarWhereInput[]
  }

  export type NavigationItemTranslationCreateNestedManyWithoutItemInput = {
    create?: XOR<NavigationItemTranslationCreateWithoutItemInput, NavigationItemTranslationUncheckedCreateWithoutItemInput> | NavigationItemTranslationCreateWithoutItemInput[] | NavigationItemTranslationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: NavigationItemTranslationCreateOrConnectWithoutItemInput | NavigationItemTranslationCreateOrConnectWithoutItemInput[]
    createMany?: NavigationItemTranslationCreateManyItemInputEnvelope
    connect?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
  }

  export type NavigationMenuCreateNestedOneWithoutItemsInput = {
    create?: XOR<NavigationMenuCreateWithoutItemsInput, NavigationMenuUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NavigationMenuCreateOrConnectWithoutItemsInput
    connect?: NavigationMenuWhereUniqueInput
  }

  export type NavigationItemCreateNestedOneWithoutChildrenInput = {
    create?: XOR<NavigationItemCreateWithoutChildrenInput, NavigationItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: NavigationItemCreateOrConnectWithoutChildrenInput
    connect?: NavigationItemWhereUniqueInput
  }

  export type NavigationItemCreateNestedManyWithoutParentInput = {
    create?: XOR<NavigationItemCreateWithoutParentInput, NavigationItemUncheckedCreateWithoutParentInput> | NavigationItemCreateWithoutParentInput[] | NavigationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutParentInput | NavigationItemCreateOrConnectWithoutParentInput[]
    createMany?: NavigationItemCreateManyParentInputEnvelope
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
  }

  export type NavigationItemTranslationUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<NavigationItemTranslationCreateWithoutItemInput, NavigationItemTranslationUncheckedCreateWithoutItemInput> | NavigationItemTranslationCreateWithoutItemInput[] | NavigationItemTranslationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: NavigationItemTranslationCreateOrConnectWithoutItemInput | NavigationItemTranslationCreateOrConnectWithoutItemInput[]
    createMany?: NavigationItemTranslationCreateManyItemInputEnvelope
    connect?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
  }

  export type NavigationItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<NavigationItemCreateWithoutParentInput, NavigationItemUncheckedCreateWithoutParentInput> | NavigationItemCreateWithoutParentInput[] | NavigationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutParentInput | NavigationItemCreateOrConnectWithoutParentInput[]
    createMany?: NavigationItemCreateManyParentInputEnvelope
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
  }

  export type NavigationItemTranslationUpdateManyWithoutItemNestedInput = {
    create?: XOR<NavigationItemTranslationCreateWithoutItemInput, NavigationItemTranslationUncheckedCreateWithoutItemInput> | NavigationItemTranslationCreateWithoutItemInput[] | NavigationItemTranslationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: NavigationItemTranslationCreateOrConnectWithoutItemInput | NavigationItemTranslationCreateOrConnectWithoutItemInput[]
    upsert?: NavigationItemTranslationUpsertWithWhereUniqueWithoutItemInput | NavigationItemTranslationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: NavigationItemTranslationCreateManyItemInputEnvelope
    set?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    disconnect?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    delete?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    connect?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    update?: NavigationItemTranslationUpdateWithWhereUniqueWithoutItemInput | NavigationItemTranslationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: NavigationItemTranslationUpdateManyWithWhereWithoutItemInput | NavigationItemTranslationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: NavigationItemTranslationScalarWhereInput | NavigationItemTranslationScalarWhereInput[]
  }

  export type NavigationMenuUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<NavigationMenuCreateWithoutItemsInput, NavigationMenuUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NavigationMenuCreateOrConnectWithoutItemsInput
    upsert?: NavigationMenuUpsertWithoutItemsInput
    connect?: NavigationMenuWhereUniqueInput
    update?: XOR<XOR<NavigationMenuUpdateToOneWithWhereWithoutItemsInput, NavigationMenuUpdateWithoutItemsInput>, NavigationMenuUncheckedUpdateWithoutItemsInput>
  }

  export type NavigationItemUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<NavigationItemCreateWithoutChildrenInput, NavigationItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: NavigationItemCreateOrConnectWithoutChildrenInput
    upsert?: NavigationItemUpsertWithoutChildrenInput
    disconnect?: NavigationItemWhereInput | boolean
    delete?: NavigationItemWhereInput | boolean
    connect?: NavigationItemWhereUniqueInput
    update?: XOR<XOR<NavigationItemUpdateToOneWithWhereWithoutChildrenInput, NavigationItemUpdateWithoutChildrenInput>, NavigationItemUncheckedUpdateWithoutChildrenInput>
  }

  export type NavigationItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<NavigationItemCreateWithoutParentInput, NavigationItemUncheckedCreateWithoutParentInput> | NavigationItemCreateWithoutParentInput[] | NavigationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutParentInput | NavigationItemCreateOrConnectWithoutParentInput[]
    upsert?: NavigationItemUpsertWithWhereUniqueWithoutParentInput | NavigationItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NavigationItemCreateManyParentInputEnvelope
    set?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    disconnect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    delete?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    update?: NavigationItemUpdateWithWhereUniqueWithoutParentInput | NavigationItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NavigationItemUpdateManyWithWhereWithoutParentInput | NavigationItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NavigationItemScalarWhereInput | NavigationItemScalarWhereInput[]
  }

  export type NavigationItemTranslationUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<NavigationItemTranslationCreateWithoutItemInput, NavigationItemTranslationUncheckedCreateWithoutItemInput> | NavigationItemTranslationCreateWithoutItemInput[] | NavigationItemTranslationUncheckedCreateWithoutItemInput[]
    connectOrCreate?: NavigationItemTranslationCreateOrConnectWithoutItemInput | NavigationItemTranslationCreateOrConnectWithoutItemInput[]
    upsert?: NavigationItemTranslationUpsertWithWhereUniqueWithoutItemInput | NavigationItemTranslationUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: NavigationItemTranslationCreateManyItemInputEnvelope
    set?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    disconnect?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    delete?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    connect?: NavigationItemTranslationWhereUniqueInput | NavigationItemTranslationWhereUniqueInput[]
    update?: NavigationItemTranslationUpdateWithWhereUniqueWithoutItemInput | NavigationItemTranslationUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: NavigationItemTranslationUpdateManyWithWhereWithoutItemInput | NavigationItemTranslationUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: NavigationItemTranslationScalarWhereInput | NavigationItemTranslationScalarWhereInput[]
  }

  export type NavigationItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<NavigationItemCreateWithoutParentInput, NavigationItemUncheckedCreateWithoutParentInput> | NavigationItemCreateWithoutParentInput[] | NavigationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NavigationItemCreateOrConnectWithoutParentInput | NavigationItemCreateOrConnectWithoutParentInput[]
    upsert?: NavigationItemUpsertWithWhereUniqueWithoutParentInput | NavigationItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NavigationItemCreateManyParentInputEnvelope
    set?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    disconnect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    delete?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    connect?: NavigationItemWhereUniqueInput | NavigationItemWhereUniqueInput[]
    update?: NavigationItemUpdateWithWhereUniqueWithoutParentInput | NavigationItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NavigationItemUpdateManyWithWhereWithoutParentInput | NavigationItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NavigationItemScalarWhereInput | NavigationItemScalarWhereInput[]
  }

  export type NavigationItemCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<NavigationItemCreateWithoutTranslationsInput, NavigationItemUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: NavigationItemCreateOrConnectWithoutTranslationsInput
    connect?: NavigationItemWhereUniqueInput
  }

  export type NavigationItemUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<NavigationItemCreateWithoutTranslationsInput, NavigationItemUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: NavigationItemCreateOrConnectWithoutTranslationsInput
    upsert?: NavigationItemUpsertWithoutTranslationsInput
    connect?: NavigationItemWhereUniqueInput
    update?: XOR<XOR<NavigationItemUpdateToOneWithWhereWithoutTranslationsInput, NavigationItemUpdateWithoutTranslationsInput>, NavigationItemUncheckedUpdateWithoutTranslationsInput>
  }

  export type BannerTranslationCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerTranslationCreateWithoutBannerInput, BannerTranslationUncheckedCreateWithoutBannerInput> | BannerTranslationCreateWithoutBannerInput[] | BannerTranslationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerTranslationCreateOrConnectWithoutBannerInput | BannerTranslationCreateOrConnectWithoutBannerInput[]
    createMany?: BannerTranslationCreateManyBannerInputEnvelope
    connect?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
  }

  export type BannerPlacementCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerPlacementCreateWithoutBannerInput, BannerPlacementUncheckedCreateWithoutBannerInput> | BannerPlacementCreateWithoutBannerInput[] | BannerPlacementUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerPlacementCreateOrConnectWithoutBannerInput | BannerPlacementCreateOrConnectWithoutBannerInput[]
    createMany?: BannerPlacementCreateManyBannerInputEnvelope
    connect?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
  }

  export type BannerTranslationUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerTranslationCreateWithoutBannerInput, BannerTranslationUncheckedCreateWithoutBannerInput> | BannerTranslationCreateWithoutBannerInput[] | BannerTranslationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerTranslationCreateOrConnectWithoutBannerInput | BannerTranslationCreateOrConnectWithoutBannerInput[]
    createMany?: BannerTranslationCreateManyBannerInputEnvelope
    connect?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
  }

  export type BannerPlacementUncheckedCreateNestedManyWithoutBannerInput = {
    create?: XOR<BannerPlacementCreateWithoutBannerInput, BannerPlacementUncheckedCreateWithoutBannerInput> | BannerPlacementCreateWithoutBannerInput[] | BannerPlacementUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerPlacementCreateOrConnectWithoutBannerInput | BannerPlacementCreateOrConnectWithoutBannerInput[]
    createMany?: BannerPlacementCreateManyBannerInputEnvelope
    connect?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
  }

  export type BannerTranslationUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerTranslationCreateWithoutBannerInput, BannerTranslationUncheckedCreateWithoutBannerInput> | BannerTranslationCreateWithoutBannerInput[] | BannerTranslationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerTranslationCreateOrConnectWithoutBannerInput | BannerTranslationCreateOrConnectWithoutBannerInput[]
    upsert?: BannerTranslationUpsertWithWhereUniqueWithoutBannerInput | BannerTranslationUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerTranslationCreateManyBannerInputEnvelope
    set?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    disconnect?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    delete?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    connect?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    update?: BannerTranslationUpdateWithWhereUniqueWithoutBannerInput | BannerTranslationUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerTranslationUpdateManyWithWhereWithoutBannerInput | BannerTranslationUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerTranslationScalarWhereInput | BannerTranslationScalarWhereInput[]
  }

  export type BannerPlacementUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerPlacementCreateWithoutBannerInput, BannerPlacementUncheckedCreateWithoutBannerInput> | BannerPlacementCreateWithoutBannerInput[] | BannerPlacementUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerPlacementCreateOrConnectWithoutBannerInput | BannerPlacementCreateOrConnectWithoutBannerInput[]
    upsert?: BannerPlacementUpsertWithWhereUniqueWithoutBannerInput | BannerPlacementUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerPlacementCreateManyBannerInputEnvelope
    set?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    disconnect?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    delete?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    connect?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    update?: BannerPlacementUpdateWithWhereUniqueWithoutBannerInput | BannerPlacementUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerPlacementUpdateManyWithWhereWithoutBannerInput | BannerPlacementUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerPlacementScalarWhereInput | BannerPlacementScalarWhereInput[]
  }

  export type BannerTranslationUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerTranslationCreateWithoutBannerInput, BannerTranslationUncheckedCreateWithoutBannerInput> | BannerTranslationCreateWithoutBannerInput[] | BannerTranslationUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerTranslationCreateOrConnectWithoutBannerInput | BannerTranslationCreateOrConnectWithoutBannerInput[]
    upsert?: BannerTranslationUpsertWithWhereUniqueWithoutBannerInput | BannerTranslationUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerTranslationCreateManyBannerInputEnvelope
    set?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    disconnect?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    delete?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    connect?: BannerTranslationWhereUniqueInput | BannerTranslationWhereUniqueInput[]
    update?: BannerTranslationUpdateWithWhereUniqueWithoutBannerInput | BannerTranslationUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerTranslationUpdateManyWithWhereWithoutBannerInput | BannerTranslationUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerTranslationScalarWhereInput | BannerTranslationScalarWhereInput[]
  }

  export type BannerPlacementUncheckedUpdateManyWithoutBannerNestedInput = {
    create?: XOR<BannerPlacementCreateWithoutBannerInput, BannerPlacementUncheckedCreateWithoutBannerInput> | BannerPlacementCreateWithoutBannerInput[] | BannerPlacementUncheckedCreateWithoutBannerInput[]
    connectOrCreate?: BannerPlacementCreateOrConnectWithoutBannerInput | BannerPlacementCreateOrConnectWithoutBannerInput[]
    upsert?: BannerPlacementUpsertWithWhereUniqueWithoutBannerInput | BannerPlacementUpsertWithWhereUniqueWithoutBannerInput[]
    createMany?: BannerPlacementCreateManyBannerInputEnvelope
    set?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    disconnect?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    delete?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    connect?: BannerPlacementWhereUniqueInput | BannerPlacementWhereUniqueInput[]
    update?: BannerPlacementUpdateWithWhereUniqueWithoutBannerInput | BannerPlacementUpdateWithWhereUniqueWithoutBannerInput[]
    updateMany?: BannerPlacementUpdateManyWithWhereWithoutBannerInput | BannerPlacementUpdateManyWithWhereWithoutBannerInput[]
    deleteMany?: BannerPlacementScalarWhereInput | BannerPlacementScalarWhereInput[]
  }

  export type BannerCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<BannerCreateWithoutTranslationsInput, BannerUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutTranslationsInput
    connect?: BannerWhereUniqueInput
  }

  export type BannerUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<BannerCreateWithoutTranslationsInput, BannerUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutTranslationsInput
    upsert?: BannerUpsertWithoutTranslationsInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutTranslationsInput, BannerUpdateWithoutTranslationsInput>, BannerUncheckedUpdateWithoutTranslationsInput>
  }

  export type BannerCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<BannerCreateWithoutPlacementsInput, BannerUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutPlacementsInput
    connect?: BannerWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BannerUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<BannerCreateWithoutPlacementsInput, BannerUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: BannerCreateOrConnectWithoutPlacementsInput
    upsert?: BannerUpsertWithoutPlacementsInput
    connect?: BannerWhereUniqueInput
    update?: XOR<XOR<BannerUpdateToOneWithWhereWithoutPlacementsInput, BannerUpdateWithoutPlacementsInput>, BannerUncheckedUpdateWithoutPlacementsInput>
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NavigationItemCreateWithoutMenuInput = {
    id?: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationCreateNestedManyWithoutItemInput
    parent?: NavigationItemCreateNestedOneWithoutChildrenInput
    children?: NavigationItemCreateNestedManyWithoutParentInput
  }

  export type NavigationItemUncheckedCreateWithoutMenuInput = {
    id?: string
    parentId?: string | null
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationUncheckedCreateNestedManyWithoutItemInput
    children?: NavigationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type NavigationItemCreateOrConnectWithoutMenuInput = {
    where: NavigationItemWhereUniqueInput
    create: XOR<NavigationItemCreateWithoutMenuInput, NavigationItemUncheckedCreateWithoutMenuInput>
  }

  export type NavigationItemCreateManyMenuInputEnvelope = {
    data: NavigationItemCreateManyMenuInput | NavigationItemCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type NavigationItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: NavigationItemWhereUniqueInput
    update: XOR<NavigationItemUpdateWithoutMenuInput, NavigationItemUncheckedUpdateWithoutMenuInput>
    create: XOR<NavigationItemCreateWithoutMenuInput, NavigationItemUncheckedCreateWithoutMenuInput>
  }

  export type NavigationItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: NavigationItemWhereUniqueInput
    data: XOR<NavigationItemUpdateWithoutMenuInput, NavigationItemUncheckedUpdateWithoutMenuInput>
  }

  export type NavigationItemUpdateManyWithWhereWithoutMenuInput = {
    where: NavigationItemScalarWhereInput
    data: XOR<NavigationItemUpdateManyMutationInput, NavigationItemUncheckedUpdateManyWithoutMenuInput>
  }

  export type NavigationItemScalarWhereInput = {
    AND?: NavigationItemScalarWhereInput | NavigationItemScalarWhereInput[]
    OR?: NavigationItemScalarWhereInput[]
    NOT?: NavigationItemScalarWhereInput | NavigationItemScalarWhereInput[]
    id?: StringFilter<"NavigationItem"> | string
    menuId?: StringFilter<"NavigationItem"> | string
    parentId?: StringNullableFilter<"NavigationItem"> | string | null
    order?: IntFilter<"NavigationItem"> | number
    isActive?: BoolFilter<"NavigationItem"> | boolean
    isExternal?: BoolFilter<"NavigationItem"> | boolean
    target?: StringFilter<"NavigationItem"> | string
    iconType?: StringFilter<"NavigationItem"> | string
    iconName?: StringNullableFilter<"NavigationItem"> | string | null
    iconUrl?: StringNullableFilter<"NavigationItem"> | string | null
    backgroundColor?: StringNullableFilter<"NavigationItem"> | string | null
    textColor?: StringNullableFilter<"NavigationItem"> | string | null
    hoverColor?: StringNullableFilter<"NavigationItem"> | string | null
    activeColor?: StringNullableFilter<"NavigationItem"> | string | null
    fontFamily?: StringNullableFilter<"NavigationItem"> | string | null
    fontSize?: StringNullableFilter<"NavigationItem"> | string | null
    fontWeight?: StringNullableFilter<"NavigationItem"> | string | null
    createdAt?: DateTimeFilter<"NavigationItem"> | Date | string
    updatedAt?: DateTimeFilter<"NavigationItem"> | Date | string
  }

  export type NavigationItemTranslationCreateWithoutItemInput = {
    id?: string
    language: string
    title: string
    url: string
  }

  export type NavigationItemTranslationUncheckedCreateWithoutItemInput = {
    id?: string
    language: string
    title: string
    url: string
  }

  export type NavigationItemTranslationCreateOrConnectWithoutItemInput = {
    where: NavigationItemTranslationWhereUniqueInput
    create: XOR<NavigationItemTranslationCreateWithoutItemInput, NavigationItemTranslationUncheckedCreateWithoutItemInput>
  }

  export type NavigationItemTranslationCreateManyItemInputEnvelope = {
    data: NavigationItemTranslationCreateManyItemInput | NavigationItemTranslationCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type NavigationMenuCreateWithoutItemsInput = {
    id?: string
    name: string
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavigationMenuUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    location: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavigationMenuCreateOrConnectWithoutItemsInput = {
    where: NavigationMenuWhereUniqueInput
    create: XOR<NavigationMenuCreateWithoutItemsInput, NavigationMenuUncheckedCreateWithoutItemsInput>
  }

  export type NavigationItemCreateWithoutChildrenInput = {
    id?: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationCreateNestedManyWithoutItemInput
    menu: NavigationMenuCreateNestedOneWithoutItemsInput
    parent?: NavigationItemCreateNestedOneWithoutChildrenInput
  }

  export type NavigationItemUncheckedCreateWithoutChildrenInput = {
    id?: string
    menuId: string
    parentId?: string | null
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationUncheckedCreateNestedManyWithoutItemInput
  }

  export type NavigationItemCreateOrConnectWithoutChildrenInput = {
    where: NavigationItemWhereUniqueInput
    create: XOR<NavigationItemCreateWithoutChildrenInput, NavigationItemUncheckedCreateWithoutChildrenInput>
  }

  export type NavigationItemCreateWithoutParentInput = {
    id?: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationCreateNestedManyWithoutItemInput
    menu: NavigationMenuCreateNestedOneWithoutItemsInput
    children?: NavigationItemCreateNestedManyWithoutParentInput
  }

  export type NavigationItemUncheckedCreateWithoutParentInput = {
    id?: string
    menuId: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: NavigationItemTranslationUncheckedCreateNestedManyWithoutItemInput
    children?: NavigationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type NavigationItemCreateOrConnectWithoutParentInput = {
    where: NavigationItemWhereUniqueInput
    create: XOR<NavigationItemCreateWithoutParentInput, NavigationItemUncheckedCreateWithoutParentInput>
  }

  export type NavigationItemCreateManyParentInputEnvelope = {
    data: NavigationItemCreateManyParentInput | NavigationItemCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type NavigationItemTranslationUpsertWithWhereUniqueWithoutItemInput = {
    where: NavigationItemTranslationWhereUniqueInput
    update: XOR<NavigationItemTranslationUpdateWithoutItemInput, NavigationItemTranslationUncheckedUpdateWithoutItemInput>
    create: XOR<NavigationItemTranslationCreateWithoutItemInput, NavigationItemTranslationUncheckedCreateWithoutItemInput>
  }

  export type NavigationItemTranslationUpdateWithWhereUniqueWithoutItemInput = {
    where: NavigationItemTranslationWhereUniqueInput
    data: XOR<NavigationItemTranslationUpdateWithoutItemInput, NavigationItemTranslationUncheckedUpdateWithoutItemInput>
  }

  export type NavigationItemTranslationUpdateManyWithWhereWithoutItemInput = {
    where: NavigationItemTranslationScalarWhereInput
    data: XOR<NavigationItemTranslationUpdateManyMutationInput, NavigationItemTranslationUncheckedUpdateManyWithoutItemInput>
  }

  export type NavigationItemTranslationScalarWhereInput = {
    AND?: NavigationItemTranslationScalarWhereInput | NavigationItemTranslationScalarWhereInput[]
    OR?: NavigationItemTranslationScalarWhereInput[]
    NOT?: NavigationItemTranslationScalarWhereInput | NavigationItemTranslationScalarWhereInput[]
    id?: StringFilter<"NavigationItemTranslation"> | string
    itemId?: StringFilter<"NavigationItemTranslation"> | string
    language?: StringFilter<"NavigationItemTranslation"> | string
    title?: StringFilter<"NavigationItemTranslation"> | string
    url?: StringFilter<"NavigationItemTranslation"> | string
  }

  export type NavigationMenuUpsertWithoutItemsInput = {
    update: XOR<NavigationMenuUpdateWithoutItemsInput, NavigationMenuUncheckedUpdateWithoutItemsInput>
    create: XOR<NavigationMenuCreateWithoutItemsInput, NavigationMenuUncheckedCreateWithoutItemsInput>
    where?: NavigationMenuWhereInput
  }

  export type NavigationMenuUpdateToOneWithWhereWithoutItemsInput = {
    where?: NavigationMenuWhereInput
    data: XOR<NavigationMenuUpdateWithoutItemsInput, NavigationMenuUncheckedUpdateWithoutItemsInput>
  }

  export type NavigationMenuUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationMenuUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationItemUpsertWithoutChildrenInput = {
    update: XOR<NavigationItemUpdateWithoutChildrenInput, NavigationItemUncheckedUpdateWithoutChildrenInput>
    create: XOR<NavigationItemCreateWithoutChildrenInput, NavigationItemUncheckedCreateWithoutChildrenInput>
    where?: NavigationItemWhereInput
  }

  export type NavigationItemUpdateToOneWithWhereWithoutChildrenInput = {
    where?: NavigationItemWhereInput
    data: XOR<NavigationItemUpdateWithoutChildrenInput, NavigationItemUncheckedUpdateWithoutChildrenInput>
  }

  export type NavigationItemUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUpdateManyWithoutItemNestedInput
    menu?: NavigationMenuUpdateOneRequiredWithoutItemsNestedInput
    parent?: NavigationItemUpdateOneWithoutChildrenNestedInput
  }

  export type NavigationItemUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUncheckedUpdateManyWithoutItemNestedInput
  }

  export type NavigationItemUpsertWithWhereUniqueWithoutParentInput = {
    where: NavigationItemWhereUniqueInput
    update: XOR<NavigationItemUpdateWithoutParentInput, NavigationItemUncheckedUpdateWithoutParentInput>
    create: XOR<NavigationItemCreateWithoutParentInput, NavigationItemUncheckedCreateWithoutParentInput>
  }

  export type NavigationItemUpdateWithWhereUniqueWithoutParentInput = {
    where: NavigationItemWhereUniqueInput
    data: XOR<NavigationItemUpdateWithoutParentInput, NavigationItemUncheckedUpdateWithoutParentInput>
  }

  export type NavigationItemUpdateManyWithWhereWithoutParentInput = {
    where: NavigationItemScalarWhereInput
    data: XOR<NavigationItemUpdateManyMutationInput, NavigationItemUncheckedUpdateManyWithoutParentInput>
  }

  export type NavigationItemCreateWithoutTranslationsInput = {
    id?: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: NavigationMenuCreateNestedOneWithoutItemsInput
    parent?: NavigationItemCreateNestedOneWithoutChildrenInput
    children?: NavigationItemCreateNestedManyWithoutParentInput
  }

  export type NavigationItemUncheckedCreateWithoutTranslationsInput = {
    id?: string
    menuId: string
    parentId?: string | null
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: NavigationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type NavigationItemCreateOrConnectWithoutTranslationsInput = {
    where: NavigationItemWhereUniqueInput
    create: XOR<NavigationItemCreateWithoutTranslationsInput, NavigationItemUncheckedCreateWithoutTranslationsInput>
  }

  export type NavigationItemUpsertWithoutTranslationsInput = {
    update: XOR<NavigationItemUpdateWithoutTranslationsInput, NavigationItemUncheckedUpdateWithoutTranslationsInput>
    create: XOR<NavigationItemCreateWithoutTranslationsInput, NavigationItemUncheckedCreateWithoutTranslationsInput>
    where?: NavigationItemWhereInput
  }

  export type NavigationItemUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: NavigationItemWhereInput
    data: XOR<NavigationItemUpdateWithoutTranslationsInput, NavigationItemUncheckedUpdateWithoutTranslationsInput>
  }

  export type NavigationItemUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: NavigationMenuUpdateOneRequiredWithoutItemsNestedInput
    parent?: NavigationItemUpdateOneWithoutChildrenNestedInput
    children?: NavigationItemUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: NavigationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BannerTranslationCreateWithoutBannerInput = {
    id?: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    imageUrl?: string | null
  }

  export type BannerTranslationUncheckedCreateWithoutBannerInput = {
    id?: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    imageUrl?: string | null
  }

  export type BannerTranslationCreateOrConnectWithoutBannerInput = {
    where: BannerTranslationWhereUniqueInput
    create: XOR<BannerTranslationCreateWithoutBannerInput, BannerTranslationUncheckedCreateWithoutBannerInput>
  }

  export type BannerTranslationCreateManyBannerInputEnvelope = {
    data: BannerTranslationCreateManyBannerInput | BannerTranslationCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type BannerPlacementCreateWithoutBannerInput = {
    id?: string
    location: string
    position?: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BannerPlacementUncheckedCreateWithoutBannerInput = {
    id?: string
    location: string
    position?: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BannerPlacementCreateOrConnectWithoutBannerInput = {
    where: BannerPlacementWhereUniqueInput
    create: XOR<BannerPlacementCreateWithoutBannerInput, BannerPlacementUncheckedCreateWithoutBannerInput>
  }

  export type BannerPlacementCreateManyBannerInputEnvelope = {
    data: BannerPlacementCreateManyBannerInput | BannerPlacementCreateManyBannerInput[]
    skipDuplicates?: boolean
  }

  export type BannerTranslationUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerTranslationWhereUniqueInput
    update: XOR<BannerTranslationUpdateWithoutBannerInput, BannerTranslationUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerTranslationCreateWithoutBannerInput, BannerTranslationUncheckedCreateWithoutBannerInput>
  }

  export type BannerTranslationUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerTranslationWhereUniqueInput
    data: XOR<BannerTranslationUpdateWithoutBannerInput, BannerTranslationUncheckedUpdateWithoutBannerInput>
  }

  export type BannerTranslationUpdateManyWithWhereWithoutBannerInput = {
    where: BannerTranslationScalarWhereInput
    data: XOR<BannerTranslationUpdateManyMutationInput, BannerTranslationUncheckedUpdateManyWithoutBannerInput>
  }

  export type BannerTranslationScalarWhereInput = {
    AND?: BannerTranslationScalarWhereInput | BannerTranslationScalarWhereInput[]
    OR?: BannerTranslationScalarWhereInput[]
    NOT?: BannerTranslationScalarWhereInput | BannerTranslationScalarWhereInput[]
    id?: StringFilter<"BannerTranslation"> | string
    bannerId?: StringFilter<"BannerTranslation"> | string
    language?: StringFilter<"BannerTranslation"> | string
    title?: StringNullableFilter<"BannerTranslation"> | string | null
    subtitle?: StringNullableFilter<"BannerTranslation"> | string | null
    description?: StringNullableFilter<"BannerTranslation"> | string | null
    ctaText?: StringNullableFilter<"BannerTranslation"> | string | null
    ctaUrl?: StringNullableFilter<"BannerTranslation"> | string | null
    imageUrl?: StringNullableFilter<"BannerTranslation"> | string | null
  }

  export type BannerPlacementUpsertWithWhereUniqueWithoutBannerInput = {
    where: BannerPlacementWhereUniqueInput
    update: XOR<BannerPlacementUpdateWithoutBannerInput, BannerPlacementUncheckedUpdateWithoutBannerInput>
    create: XOR<BannerPlacementCreateWithoutBannerInput, BannerPlacementUncheckedCreateWithoutBannerInput>
  }

  export type BannerPlacementUpdateWithWhereUniqueWithoutBannerInput = {
    where: BannerPlacementWhereUniqueInput
    data: XOR<BannerPlacementUpdateWithoutBannerInput, BannerPlacementUncheckedUpdateWithoutBannerInput>
  }

  export type BannerPlacementUpdateManyWithWhereWithoutBannerInput = {
    where: BannerPlacementScalarWhereInput
    data: XOR<BannerPlacementUpdateManyMutationInput, BannerPlacementUncheckedUpdateManyWithoutBannerInput>
  }

  export type BannerPlacementScalarWhereInput = {
    AND?: BannerPlacementScalarWhereInput | BannerPlacementScalarWhereInput[]
    OR?: BannerPlacementScalarWhereInput[]
    NOT?: BannerPlacementScalarWhereInput | BannerPlacementScalarWhereInput[]
    id?: StringFilter<"BannerPlacement"> | string
    bannerId?: StringFilter<"BannerPlacement"> | string
    location?: StringFilter<"BannerPlacement"> | string
    position?: IntFilter<"BannerPlacement"> | number
    isActive?: BoolFilter<"BannerPlacement"> | boolean
    startDate?: DateTimeNullableFilter<"BannerPlacement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BannerPlacement"> | Date | string | null
  }

  export type BannerCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    placements?: BannerPlacementCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutTranslationsInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    placements?: BannerPlacementUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutTranslationsInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutTranslationsInput, BannerUncheckedCreateWithoutTranslationsInput>
  }

  export type BannerUpsertWithoutTranslationsInput = {
    update: XOR<BannerUpdateWithoutTranslationsInput, BannerUncheckedUpdateWithoutTranslationsInput>
    create: XOR<BannerCreateWithoutTranslationsInput, BannerUncheckedCreateWithoutTranslationsInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutTranslationsInput, BannerUncheckedUpdateWithoutTranslationsInput>
  }

  export type BannerUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placements?: BannerPlacementUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placements?: BannerPlacementUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type BannerCreateWithoutPlacementsInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: BannerTranslationCreateNestedManyWithoutBannerInput
  }

  export type BannerUncheckedCreateWithoutPlacementsInput = {
    id?: string
    slug: string
    name: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    displayType?: string
    imageUrl?: string | null
    backgroundColor?: string | null
    overlayColor?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    customHtml?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: BannerTranslationUncheckedCreateNestedManyWithoutBannerInput
  }

  export type BannerCreateOrConnectWithoutPlacementsInput = {
    where: BannerWhereUniqueInput
    create: XOR<BannerCreateWithoutPlacementsInput, BannerUncheckedCreateWithoutPlacementsInput>
  }

  export type BannerUpsertWithoutPlacementsInput = {
    update: XOR<BannerUpdateWithoutPlacementsInput, BannerUncheckedUpdateWithoutPlacementsInput>
    create: XOR<BannerCreateWithoutPlacementsInput, BannerUncheckedCreateWithoutPlacementsInput>
    where?: BannerWhereInput
  }

  export type BannerUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: BannerWhereInput
    data: XOR<BannerUpdateWithoutPlacementsInput, BannerUncheckedUpdateWithoutPlacementsInput>
  }

  export type BannerUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: BannerTranslationUpdateManyWithoutBannerNestedInput
  }

  export type BannerUncheckedUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    displayType?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    overlayColor?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customHtml?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: BannerTranslationUncheckedUpdateManyWithoutBannerNestedInput
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    displayName: string
    firstName?: string | null
    lastName?: string | null
    role?: string
    status?: string
    avatar?: string | null
    bio?: string | null
    website?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    displayName: string
    firstName?: string | null
    lastName?: string | null
    role?: string
    status?: string
    avatar?: string | null
    bio?: string | null
    website?: string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationItemCreateManyMenuInput = {
    id?: string
    parentId?: string | null
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavigationItemUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUpdateManyWithoutItemNestedInput
    parent?: NavigationItemUpdateOneWithoutChildrenNestedInput
    children?: NavigationItemUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUncheckedUpdateManyWithoutItemNestedInput
    children?: NavigationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemUncheckedUpdateManyWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NavigationItemTranslationCreateManyItemInput = {
    id?: string
    language: string
    title: string
    url: string
  }

  export type NavigationItemCreateManyParentInput = {
    id?: string
    menuId: string
    order?: number
    isActive?: boolean
    isExternal?: boolean
    target?: string
    iconType?: string
    iconName?: string | null
    iconUrl?: string | null
    backgroundColor?: string | null
    textColor?: string | null
    hoverColor?: string | null
    activeColor?: string | null
    fontFamily?: string | null
    fontSize?: string | null
    fontWeight?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NavigationItemTranslationUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type NavigationItemTranslationUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type NavigationItemTranslationUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type NavigationItemUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUpdateManyWithoutItemNestedInput
    menu?: NavigationMenuUpdateOneRequiredWithoutItemsNestedInput
    children?: NavigationItemUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: NavigationItemTranslationUncheckedUpdateManyWithoutItemNestedInput
    children?: NavigationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type NavigationItemUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isExternal?: BoolFieldUpdateOperationsInput | boolean
    target?: StringFieldUpdateOperationsInput | string
    iconType?: StringFieldUpdateOperationsInput | string
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundColor?: NullableStringFieldUpdateOperationsInput | string | null
    textColor?: NullableStringFieldUpdateOperationsInput | string | null
    hoverColor?: NullableStringFieldUpdateOperationsInput | string | null
    activeColor?: NullableStringFieldUpdateOperationsInput | string | null
    fontFamily?: NullableStringFieldUpdateOperationsInput | string | null
    fontSize?: NullableStringFieldUpdateOperationsInput | string | null
    fontWeight?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerTranslationCreateManyBannerInput = {
    id?: string
    language: string
    title?: string | null
    subtitle?: string | null
    description?: string | null
    ctaText?: string | null
    ctaUrl?: string | null
    imageUrl?: string | null
  }

  export type BannerPlacementCreateManyBannerInput = {
    id?: string
    location: string
    position?: number
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BannerTranslationUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannerTranslationUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannerTranslationUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BannerPlacementUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerPlacementUncheckedUpdateWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerPlacementUncheckedUpdateManyWithoutBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}